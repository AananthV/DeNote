{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/arraydiff/index.js",
    "node_modules/async/dist/async.js",
    "node_modules/browserchannel/dist/bcsocket-uncompressed.js",
    "node_modules/browserify/node_modules/punycode/punycode.js",
    "node_modules/derby-templates/index.js",
    "node_modules/derby-templates/lib/contexts.js",
    "node_modules/derby-templates/lib/expressions.js",
    "node_modules/derby-templates/lib/operatorFns.js",
    "node_modules/derby-templates/lib/options.js",
    "node_modules/derby-templates/lib/templates.js",
    "node_modules/derby-templates/lib/util.js",
    "node_modules/derby/lib/App.js",
    "node_modules/derby/lib/Controller.js",
    "node_modules/derby/lib/Derby.js",
    "node_modules/derby/lib/Dom.js",
    "node_modules/derby/lib/Page.js",
    "node_modules/derby/lib/_views.js",
    "node_modules/derby/lib/components.js",
    "node_modules/derby/lib/documentListeners.js",
    "node_modules/derby/lib/eventmodel.js",
    "node_modules/derby/lib/textDiff.js",
    "node_modules/events/events.js",
    "node_modules/hat/index.js",
    "node_modules/ot-json0/lib/bootstrapTransform.js",
    "node_modules/ot-json0/lib/index.js",
    "node_modules/ot-json0/lib/json0.js",
    "node_modules/ot-json0/lib/text0.js",
    "node_modules/path-browserify/index.js",
    "node_modules/process/browser.js",
    "node_modules/qs/lib/formats.js",
    "node_modules/qs/lib/index.js",
    "node_modules/qs/lib/parse.js",
    "node_modules/qs/lib/stringify.js",
    "node_modules/qs/lib/utils.js",
    "node_modules/querystring-es3/decode.js",
    "node_modules/querystring-es3/encode.js",
    "node_modules/querystring-es3/index.js",
    "node_modules/racer-highway/lib/browser/index.js",
    "node_modules/racer-highway/lib/browser/socket.js",
    "node_modules/racer/lib/Model/CollectionCounter.js",
    "node_modules/racer/lib/Model/Doc.js",
    "node_modules/racer/lib/Model/LocalDoc.js",
    "node_modules/racer/lib/Model/Model.js",
    "node_modules/racer/lib/Model/Query.js",
    "node_modules/racer/lib/Model/RemoteDoc.js",
    "node_modules/racer/lib/Model/collections.js",
    "node_modules/racer/lib/Model/connection.js",
    "node_modules/racer/lib/Model/contexts.js",
    "node_modules/racer/lib/Model/defaultFns.js",
    "node_modules/racer/lib/Model/events.js",
    "node_modules/racer/lib/Model/filter.js",
    "node_modules/racer/lib/Model/fn.js",
    "node_modules/racer/lib/Model/index.js",
    "node_modules/racer/lib/Model/mutators.js",
    "node_modules/racer/lib/Model/paths.js",
    "node_modules/racer/lib/Model/ref.js",
    "node_modules/racer/lib/Model/refList.js",
    "node_modules/racer/lib/Model/setDiff.js",
    "node_modules/racer/lib/Model/subscriptions.js",
    "node_modules/racer/lib/Model/unbundle.js",
    "node_modules/racer/lib/Racer.js",
    "node_modules/racer/lib/util.js",
    "node_modules/racer/node_modules/fast-deep-equal/index.js",
    "node_modules/racer/node_modules/uuid/rng-browser.js",
    "node_modules/racer/node_modules/uuid/uuid.js",
    "node_modules/saddle/index.js",
    "node_modules/serialize-object/index.js",
    "node_modules/sharedb/lib/client/connection.js",
    "node_modules/sharedb/lib/client/doc.js",
    "node_modules/sharedb/lib/client/index.js",
    "node_modules/sharedb/lib/client/presence/doc-presence.js",
    "node_modules/sharedb/lib/client/presence/local-doc-presence.js",
    "node_modules/sharedb/lib/client/presence/local-presence.js",
    "node_modules/sharedb/lib/client/presence/presence.js",
    "node_modules/sharedb/lib/client/presence/remote-doc-presence.js",
    "node_modules/sharedb/lib/client/presence/remote-presence.js",
    "node_modules/sharedb/lib/client/query.js",
    "node_modules/sharedb/lib/client/snapshot-request/snapshot-request.js",
    "node_modules/sharedb/lib/client/snapshot-request/snapshot-timestamp-request.js",
    "node_modules/sharedb/lib/client/snapshot-request/snapshot-version-request.js",
    "node_modules/sharedb/lib/emitter.js",
    "node_modules/sharedb/lib/error.js",
    "node_modules/sharedb/lib/logger/index.js",
    "node_modules/sharedb/lib/logger/logger.js",
    "node_modules/sharedb/lib/ot.js",
    "node_modules/sharedb/lib/snapshot.js",
    "node_modules/sharedb/lib/types.js",
    "node_modules/sharedb/lib/util.js",
    "node_modules/timers-browserify/main.js",
    "node_modules/tracks/lib/History.js",
    "node_modules/tracks/lib/browser.js",
    "node_modules/tracks/lib/router.js",
    "node_modules/tracks/vendor/express/router/route.js",
    "node_modules/tracks/vendor/express/utils.js",
    "node_modules/url/url.js",
    "node_modules/url/util.js",
    "src/Apps/auth/Components/register/index.ts",
    "src/Apps/auth/Components/register/register.ts",
    "src/Apps/auth/auth.ts",
    "src/Apps/base/application.ts",
    "node_modules/derby",
    "node_modules/racer/lib/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACz+KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnsFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrhBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACptBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5ZA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACptBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACt0CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC1xBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACv+BA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChBA,uCAAqC;AAA5B,mGAAA,OAAO,OAAA;;;;;;;;;;;;;;;;;;ACAhB,+BAAkC;AAElC;IAAA;QACI,UAAK,GAAW,CAAC,CAAC;IACtB,CAAC;IAAD,mBAAC;AAAD,CAFA,AAEC,IAAA;AAED;IAAgC,qCAAuB;IAAvD;;IAsBA,CAAC;IAbG,gCAAI,GAAJ;QACI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC;IAC3E,CAAC;IAED,kCAAM,GAAN;QACI,gCAAgC;QAChC,yBAAyB;QACzB,2DAA2D;IAC/D,CAAC;IAED,oCAAQ,GAAR;QACI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;IACzC,CAAC;IApBM,sBAAI,GAAG,8DAA8D,CAAC;IACtE,iCAAe,GAAG,YAAY,CAAC;IAC/B,oBAAE,GAAG,eAAe,CAAC;IAmBhC,wBAAC;CAtBD,AAsBC,CAtB+B,iBAAS,GAsBxC;AAED,kBAAe,iBAAiB,CAAC;;;;;;;;;AC9BjC,gDAA0B;AAK1B,mEAAsD;AACtD,mDAA2D;AAE3D,IAAM,UAAU,GAAG;IACf,kBAAiB;CACpB,CAAA;AAED,IAAM,GAAG,GAAG,eAAK,CAAC,SAAS,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;AAEhD,oDAAoD;AAEpD,GAAG,CAAC,SAAS,CAAC,yDAAyD,CAAC,CAAC;AAEzE,kCAAoB,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;AAEtC,kBAAe,GAAG,CAAC;;;;;;;;ACpBN,QAAA,oBAAoB,GAAG,UAAC,QAAa,EAAE,UAAiB;IACjE,UAAU,CAAC,OAAO,CAAC,UAAA,SAAS;QACxB,QAAQ,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;IAClC,CAAC,CAAC,CAAC;AACP,CAAC,CAAA;AAEY,QAAA,gBAAgB,GAAG,cAAO,CAAC,CAAC;;;ACNzC;AACA;AACA;AACA;;ACHA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "module.exports = arrayDiff;\n\n// Based on some rough benchmarking, this algorithm is about O(2n) worst case,\n// and it can compute diffs on random arrays of length 1024 in about 34ms,\n// though just a few changes on an array of length 1024 takes about 0.5ms\n\narrayDiff.InsertDiff = InsertDiff;\narrayDiff.RemoveDiff = RemoveDiff;\narrayDiff.MoveDiff = MoveDiff;\n\nfunction InsertDiff(index, values) {\n  this.index = index;\n  this.values = values;\n}\nInsertDiff.prototype.type = 'insert';\nInsertDiff.prototype.toJSON = function() {\n  return {\n    type: this.type,\n    index: this.index,\n    values: this.values\n  };\n};\n\nfunction RemoveDiff(index, howMany) {\n  this.index = index;\n  this.howMany = howMany;\n}\nRemoveDiff.prototype.type = 'remove';\nRemoveDiff.prototype.toJSON = function() {\n  return {\n    type: this.type,\n    index: this.index,\n    howMany: this.howMany\n  };\n};\n\nfunction MoveDiff(from, to, howMany) {\n  this.from = from;\n  this.to = to;\n  this.howMany = howMany;\n}\nMoveDiff.prototype.type = 'move';\nMoveDiff.prototype.toJSON = function() {\n  return {\n    type: this.type,\n    from: this.from,\n    to: this.to,\n    howMany: this.howMany\n  };\n};\n\nfunction strictEqual(a, b) {\n  return a === b;\n}\n\nfunction arrayDiff(before, after, equalFn) {\n  if (!equalFn) equalFn = strictEqual;\n\n  // Find all items in both the before and after array, and represent them\n  // as moves. Many of these \"moves\" may end up being discarded in the last\n  // pass if they are from an index to the same index, but we don't know this\n  // up front, since we haven't yet offset the indices.\n  //\n  // Also keep a map of all the indices accounted for in the before and after\n  // arrays. These maps are used next to create insert and remove diffs.\n  var beforeLength = before.length;\n  var afterLength = after.length;\n  var moves = [];\n  var beforeMarked = {};\n  var afterMarked = {};\n  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {\n    var beforeItem = before[beforeIndex];\n    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {\n      if (afterMarked[afterIndex]) continue;\n      if (!equalFn(beforeItem, after[afterIndex])) continue;\n      var from = beforeIndex;\n      var to = afterIndex;\n      var howMany = 0;\n      do {\n        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;\n        howMany++;\n      } while (\n        beforeIndex < beforeLength &&\n        afterIndex < afterLength &&\n        equalFn(before[beforeIndex], after[afterIndex]) &&\n        !afterMarked[afterIndex]\n      );\n      moves.push(new MoveDiff(from, to, howMany));\n      beforeIndex--;\n      break;\n    }\n  }\n\n  // Create a remove for all of the items in the before array that were\n  // not marked as being matched in the after array as well\n  var removes = [];\n  for (beforeIndex = 0; beforeIndex < beforeLength;) {\n    if (beforeMarked[beforeIndex]) {\n      beforeIndex++;\n      continue;\n    }\n    var index = beforeIndex;\n    var howMany = 0;\n    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {\n      howMany++;\n    }\n    removes.push(new RemoveDiff(index, howMany));\n  }\n\n  // Create an insert for all of the items in the after array that were\n  // not marked as being matched in the before array as well\n  var inserts = [];\n  for (var afterIndex = 0; afterIndex < afterLength;) {\n    if (afterMarked[afterIndex]) {\n      afterIndex++;\n      continue;\n    }\n    var index = afterIndex;\n    var howMany = 0;\n    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {\n      howMany++;\n    }\n    var values = after.slice(index, index + howMany);\n    inserts.push(new InsertDiff(index, values));\n  }\n\n  var insertsLength = inserts.length;\n  var removesLength = removes.length;\n  var movesLength = moves.length;\n  var i, j;\n\n  // Offset subsequent removes and moves by removes\n  var count = 0;\n  for (i = 0; i < removesLength; i++) {\n    var remove = removes[i];\n    remove.index -= count;\n    count += remove.howMany;\n    for (j = 0; j < movesLength; j++) {\n      var move = moves[j];\n      if (move.from >= remove.index) move.from -= remove.howMany;\n    }\n  }\n\n  // Offset moves by inserts\n  for (i = insertsLength; i--;) {\n    var insert = inserts[i];\n    var howMany = insert.values.length;\n    for (j = movesLength; j--;) {\n      var move = moves[j];\n      if (move.to >= insert.index) move.to -= howMany;\n    }\n  }\n\n  // Offset the to of moves by later moves\n  for (i = movesLength; i-- > 1;) {\n    var move = moves[i];\n    if (move.to === move.from) continue;\n    for (j = i; j--;) {\n      var earlier = moves[j];\n      if (earlier.to >= move.to) earlier.to -= move.howMany;\n      if (earlier.to >= move.from) earlier.to += move.howMany;\n    }\n  }\n\n  // Only output moves that end up having an effect after offsetting\n  var outputMoves = [];\n\n  // Offset the from of moves by earlier moves\n  for (i = 0; i < movesLength; i++) {\n    var move = moves[i];\n    if (move.to === move.from) continue;\n    outputMoves.push(move);\n    for (j = i + 1; j < movesLength; j++) {\n      var later = moves[j];\n      if (later.from >= move.from) later.from -= move.howMany;\n      if (later.from >= move.to) later.from += move.howMany;\n    }\n  }\n\n  return removes.concat(outputMoves, inserts);\n}\n",
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.async = global.async || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction slice(arrayLike, start) {\n    start = start|0;\n    var newLen = Math.max(arrayLike.length - start, 0);\n    var newArr = Array(newLen);\n    for(var idx = 0; idx < newLen; idx++)  {\n        newArr[idx] = arrayLike[start + idx];\n    }\n    return newArr;\n}\n\n/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @returns {Function} the partially-applied function\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */\nvar apply = function(fn/*, ...args*/) {\n    var args = slice(arguments, 1);\n    return function(/*callArgs*/) {\n        var callArgs = slice(arguments);\n        return fn.apply(null, args.concat(callArgs));\n    };\n};\n\nvar initialParams = function (fn) {\n    return function (/*...args, callback*/) {\n        var args = slice(arguments);\n        var callback = args.pop();\n        fn.call(this, args, callback);\n    };\n};\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nvar hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return function (fn/*, ...args*/) {\n        var args = slice(arguments, 1);\n        defer(function () {\n            fn.apply(null, args);\n        });\n    };\n}\n\nvar _defer;\n\nif (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nvar setImmediate$1 = wrap(_defer);\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    return initialParams(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (isObject(result) && typeof result.then === 'function') {\n            result.then(function(value) {\n                invokeCallback(callback, null, value);\n            }, function(err) {\n                invokeCallback(callback, err.message ? err : new Error(err));\n            });\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (e) {\n        setImmediate$1(rethrow, e);\n    }\n}\n\nfunction rethrow(error) {\n    throw error;\n}\n\nvar supportsSymbol = typeof Symbol === 'function';\n\nfunction isAsync(fn) {\n    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction wrapAsync(asyncFn) {\n    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n}\n\nfunction applyEach$1(eachfn) {\n    return function(fns/*, ...args*/) {\n        var args = slice(arguments, 1);\n        var go = initialParams(function(args, callback) {\n            var that = this;\n            return eachfn(fns, function (fn, cb) {\n                wrapAsync(fn).apply(that, args.concat(cb));\n            }, callback);\n        });\n        if (args.length) {\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n}\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar Symbol$1 = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]';\nvar undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]';\nvar funcTag = '[object Function]';\nvar genTag = '[object GeneratorFunction]';\nvar proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nvar breakLoop = {};\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nfunction once(fn) {\n    return function () {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\nvar getIterator = function (coll) {\n    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n};\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto$3.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER$1 : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/** `Object#toString` result references. */\nvar argsTag$1 = '[object Arguments]';\nvar arrayTag = '[object Array]';\nvar boolTag = '[object Boolean]';\nvar dateTag = '[object Date]';\nvar errorTag = '[object Error]';\nvar funcTag$1 = '[object Function]';\nvar mapTag = '[object Map]';\nvar numberTag = '[object Number]';\nvar objectTag = '[object Object]';\nvar regexpTag = '[object RegExp]';\nvar setTag = '[object Set]';\nvar stringTag = '[object String]';\nvar weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]';\nvar dataViewTag = '[object DataView]';\nvar float32Tag = '[object Float32Array]';\nvar float64Tag = '[object Float64Array]';\nvar int8Tag = '[object Int8Array]';\nvar int16Tag = '[object Int16Array]';\nvar int32Tag = '[object Int32Array]';\nvar uint8Tag = '[object Uint8Array]';\nvar uint8ClampedTag = '[object Uint8ClampedArray]';\nvar uint16Tag = '[object Uint16Array]';\nvar uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag$1] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/** Detect free variable `exports`. */\nvar freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports$1 && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$1.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$5 = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;\n\n  return value === proto;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? {value: coll[i], key: i} : null;\n    }\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done)\n            return null;\n        i++;\n        return {value: item.value, key: i};\n    }\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = keys(obj);\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        return i < len ? {value: obj[key], key: key} : null;\n    };\n}\n\nfunction iterator(coll) {\n    if (isArrayLike(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\n\nfunction onlyOnce(fn) {\n    return function() {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nfunction _eachOfLimit(limit) {\n    return function (obj, iteratee, callback) {\n        callback = once(callback || noop);\n        if (limit <= 0 || !obj) {\n            return callback(null);\n        }\n        var nextElem = iterator(obj);\n        var done = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            }\n            else if (value === breakLoop || (done && running <= 0)) {\n                done = true;\n                return callback(null);\n            }\n            else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish () {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachOfLimit(coll, limit, iteratee, callback) {\n    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);\n}\n\nfunction doLimit(fn, limit) {\n    return function (iterable, iteratee, callback) {\n        return fn(iterable, limit, iteratee, callback);\n    };\n}\n\n// eachOf implementation optimized for array-likes\nfunction eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback || noop);\n    var index = 0,\n        completed = 0,\n        length = coll.length;\n    if (length === 0) {\n        callback(null);\n    }\n\n    function iteratorCallback(err, value) {\n        if (err) {\n            callback(err);\n        } else if ((++completed === length) || value === breakLoop) {\n            callback(null);\n        }\n    }\n\n    for (; index < length; index++) {\n        iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n}\n\n// a generic version of eachOf which can handle array, object, and iterator cases.\nvar eachOfGeneric = doLimit(eachOfLimit, Infinity);\n\n/**\n * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEachOf\n * @category Collection\n * @see [async.each]{@link module:Collections.each}\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each\n * item in `coll`.\n * The `key` is the item's key, or index in the case of an array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * var obj = {dev: \"/dev.json\", test: \"/test.json\", prod: \"/prod.json\"};\n * var configs = {};\n *\n * async.forEachOf(obj, function (value, key, callback) {\n *     fs.readFile(__dirname + value, \"utf8\", function (err, data) {\n *         if (err) return callback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }, function (err) {\n *     if (err) console.error(err.message);\n *     // configs is now a map of JSON data\n *     doSomethingWith(configs);\n * });\n */\nvar eachOf = function(coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    eachOfImplementation(coll, wrapAsync(iteratee), callback);\n};\n\nfunction doParallel(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOf, obj, wrapAsync(iteratee), callback);\n    };\n}\n\nfunction _asyncMap(eachfn, arr, iteratee, callback) {\n    callback = callback || noop;\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n    var _iteratee = wrapAsync(iteratee);\n\n    eachfn(arr, function (value, _, callback) {\n        var index = counter++;\n        _iteratee(value, function (err, v) {\n            results[index] = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callback\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines).\n *\n * @name map\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @example\n *\n * async.map(['file1','file2','file3'], fs.stat, function(err, results) {\n *     // results is now an array of stats for each file\n * });\n */\nvar map = doParallel(_asyncMap);\n\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, `fns`, then it will return a function which lets you pass in the\n * arguments as if it were a single function call. If more arguments are\n * provided, `callback` is required while `args` is still optional.\n *\n * @name applyEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s\n * to all call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument, `fns`, is provided, it will\n * return a function which lets you pass in the arguments as if it were a single\n * function call. The signature is `(..args, callback)`. If invoked with any\n * arguments, `callback` is required.\n * @example\n *\n * async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async.applyEach([enableSearch, updateSchema]),\n *     callback\n * );\n */\nvar applyEach = applyEach$1(map);\n\nfunction doParallelLimit(fn) {\n    return function (obj, limit, iteratee, callback) {\n        return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);\n    };\n}\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapLimit = doParallelLimit(_asyncMap);\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapSeries = doLimit(mapLimit, 1);\n\n/**\n * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument is provided, it will return\n * a function which lets you pass in the arguments as if it were a single\n * function call.\n */\nvar applyEachSeries = applyEach$1(mapSeries);\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns undefined\n * @example\n *\n * async.auto({\n *     // this function will just be passed a callback\n *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n *     showData: ['readData', function(results, cb) {\n *         // results.readData is the file's contents\n *         // ...\n *     }]\n * }, callback);\n *\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         console.log('in write_file', JSON.stringify(results));\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         console.log('in email_link', JSON.stringify(results));\n *         // once the file is written let's email a link to it...\n *         // results.write_file contains the filename returned by write_file.\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('results = ', results);\n * });\n */\nvar auto = function (tasks, concurrency, callback) {\n    if (typeof concurrency === 'function') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || noop);\n    var keys$$1 = keys(tasks);\n    var numTasks = keys$$1.length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    baseForOwn(tasks, function (task, key) {\n        if (!isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        arrayEach(dependencies, function (dependencyName) {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key +\n                    '` has a non-existent dependency `' +\n                    dependencyName + '` in ' +\n                    dependencies.join(', '));\n            }\n            addListener(dependencyName, function () {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(function () {\n            runTask(key, task);\n        });\n    }\n\n    function processQueue() {\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while(readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        arrayEach(taskListeners, function (fn) {\n            fn();\n        });\n        processQueue();\n    }\n\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = onlyOnce(function(err, result) {\n            runningTasks--;\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            }\n            if (err) {\n                var safeResults = {};\n                baseForOwn(results, function(val, rkey) {\n                    safeResults[rkey] = val;\n                });\n                safeResults[key] = result;\n                hasError = true;\n                listeners = Object.create(null);\n\n                callback(err, safeResults);\n            } else {\n                results[key] = result;\n                taskComplete(key);\n            }\n        });\n\n        runningTasks++;\n        var taskFn = wrapAsync(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            arrayEach(getDependents(currentTask), function (dependent) {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error(\n                'async.auto cannot execute tasks due to a recursive dependency'\n            );\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        baseForOwn(tasks, function (task, key) {\n            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n};\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;\nvar symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the last unmatched string symbol.\n */\nfunction charsEndIndex(strSymbols, chrSymbols) {\n  var index = strSymbols.length;\n\n  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the first unmatched string symbol.\n */\nfunction charsStartIndex(strSymbols, chrSymbols) {\n  var index = -1,\n      length = strSymbols.length;\n\n  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;\nvar rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange$1 = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange$1 = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange$1 = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;\nvar rsVarRange$1 = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange$1 + ']';\nvar rsCombo = '[' + rsComboRange$1 + ']';\nvar rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nvar rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';\nvar rsNonAstral = '[^' + rsAstralRange$1 + ']';\nvar rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nvar rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nvar rsZWJ$1 = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?';\nvar rsOptVar = '[' + rsVarRange$1 + ']?';\nvar rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/**\n * Removes leading and trailing whitespace or specified characters from `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to trim.\n * @param {string} [chars=whitespace] The characters to trim.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {string} Returns the trimmed string.\n * @example\n *\n * _.trim('  abc  ');\n * // => 'abc'\n *\n * _.trim('-_-abc-_-', '_-');\n * // => 'abc'\n *\n * _.map(['  foo  ', '  bar  '], _.trim);\n * // => ['foo', 'bar']\n */\nfunction trim(string, chars, guard) {\n  string = toString(string);\n  if (string && (guard || chars === undefined)) {\n    return string.replace(reTrim, '');\n  }\n  if (!string || !(chars = baseToString(chars))) {\n    return string;\n  }\n  var strSymbols = stringToArray(string),\n      chrSymbols = stringToArray(chars),\n      start = charsStartIndex(strSymbols, chrSymbols),\n      end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n  return castSlice(strSymbols, start, end).join('');\n}\n\nvar FN_ARGS = /^(?:async\\s+)?(function)?\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\nfunction parseParams(func) {\n    func = func.toString().replace(STRIP_COMMENTS, '');\n    func = func.match(FN_ARGS)[2].replace(' ', '');\n    func = func ? func.split(FN_ARG_SPLIT) : [];\n    func = func.map(function (arg){\n        return trim(arg.replace(FN_ARG, ''));\n    });\n    return func;\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    baseForOwn(tasks, function (taskFn, key) {\n        var params;\n        var fnIsAsync = isAsync(taskFn);\n        var hasNoDeps =\n            (!fnIsAsync && taskFn.length === 1) ||\n            (fnIsAsync && taskFn.length === 0);\n\n        if (isArray(taskFn)) {\n            params = taskFn.slice(0, -1);\n            taskFn = taskFn[taskFn.length - 1];\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = arrayMap(params, function (name) {\n                return results[name];\n            });\n            newArgs.push(taskCb);\n            wrapAsync(taskFn).apply(null, newArgs);\n        }\n    });\n\n    auto(newTasks, callback);\n}\n\n// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n// used for queues. This implementation assumes that the node provided by the user can be modified\n// to adjust the next and last properties. We implement only the minimal functionality\n// for queue support.\nfunction DLL() {\n    this.head = this.tail = null;\n    this.length = 0;\n}\n\nfunction setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n}\n\nDLL.prototype.removeLink = function(node) {\n    if (node.prev) node.prev.next = node.next;\n    else this.head = node.next;\n    if (node.next) node.next.prev = node.prev;\n    else this.tail = node.prev;\n\n    node.prev = node.next = null;\n    this.length -= 1;\n    return node;\n};\n\nDLL.prototype.empty = function () {\n    while(this.head) this.shift();\n    return this;\n};\n\nDLL.prototype.insertAfter = function(node, newNode) {\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next) node.next.prev = newNode;\n    else this.tail = newNode;\n    node.next = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.insertBefore = function(node, newNode) {\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev) node.prev.next = newNode;\n    else this.head = newNode;\n    node.prev = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.unshift = function(node) {\n    if (this.head) this.insertBefore(this.head, node);\n    else setInitial(this, node);\n};\n\nDLL.prototype.push = function(node) {\n    if (this.tail) this.insertAfter(this.tail, node);\n    else setInitial(this, node);\n};\n\nDLL.prototype.shift = function() {\n    return this.head && this.removeLink(this.head);\n};\n\nDLL.prototype.pop = function() {\n    return this.tail && this.removeLink(this.tail);\n};\n\nDLL.prototype.toArray = function () {\n    var arr = Array(this.length);\n    var curr = this.head;\n    for(var idx = 0; idx < this.length; idx++) {\n        arr[idx] = curr.data;\n        curr = curr.next;\n    }\n    return arr;\n};\n\nDLL.prototype.remove = function (testFn) {\n    var curr = this.head;\n    while(!!curr) {\n        var next = curr.next;\n        if (testFn(curr)) {\n            this.removeLink(curr);\n        }\n        curr = next;\n    }\n    return this;\n};\n\nfunction queue(worker, concurrency, payload) {\n    if (concurrency == null) {\n        concurrency = 1;\n    }\n    else if(concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    var _worker = wrapAsync(worker);\n    var numRunning = 0;\n    var workersList = [];\n\n    var processingScheduled = false;\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function() {\n                q.drain();\n            });\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                callback: callback || noop\n            };\n\n            if (insertAtFront) {\n                q._tasks.unshift(item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n\n        if (!processingScheduled) {\n            processingScheduled = true;\n            setImmediate$1(function() {\n                processingScheduled = false;\n                q.process();\n            });\n        }\n    }\n\n    function _next(tasks) {\n        return function(err){\n            numRunning -= 1;\n\n            for (var i = 0, l = tasks.length; i < l; i++) {\n                var task = tasks[i];\n\n                var index = baseIndexOf(workersList, task, 0);\n                if (index === 0) {\n                    workersList.shift();\n                } else if (index > 0) {\n                    workersList.splice(index, 1);\n                }\n\n                task.callback.apply(task, arguments);\n\n                if (err != null) {\n                    q.error(err, task.data);\n                }\n            }\n\n            if (numRunning <= (q.concurrency - q.buffer) ) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n            q.process();\n        };\n    }\n\n    var isProcessing = false;\n    var q = {\n        _tasks: new DLL(),\n        concurrency: concurrency,\n        payload: payload,\n        saturated: noop,\n        unsaturated:noop,\n        buffer: concurrency / 4,\n        empty: noop,\n        drain: noop,\n        error: noop,\n        started: false,\n        paused: false,\n        push: function (data, callback) {\n            _insert(data, false, callback);\n        },\n        kill: function () {\n            q.drain = noop;\n            q._tasks.empty();\n        },\n        unshift: function (data, callback) {\n            _insert(data, true, callback);\n        },\n        remove: function (testFn) {\n            q._tasks.remove(testFn);\n        },\n        process: function () {\n            // Avoid trying to start too many processing operations. This can occur\n            // when callbacks resolve synchronously (#1267).\n            if (isProcessing) {\n                return;\n            }\n            isProcessing = true;\n            while(!q.paused && numRunning < q.concurrency && q._tasks.length){\n                var tasks = [], data = [];\n                var l = q._tasks.length;\n                if (q.payload) l = Math.min(l, q.payload);\n                for (var i = 0; i < l; i++) {\n                    var node = q._tasks.shift();\n                    tasks.push(node);\n                    workersList.push(node);\n                    data.push(node.data);\n                }\n\n                numRunning += 1;\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n\n                if (numRunning === q.concurrency) {\n                    q.saturated();\n                }\n\n                var cb = onlyOnce(_next(tasks));\n                _worker(data, cb);\n            }\n            isProcessing = false;\n        },\n        length: function () {\n            return q._tasks.length;\n        },\n        running: function () {\n            return numRunning;\n        },\n        workersList: function () {\n            return workersList;\n        },\n        idle: function() {\n            return q._tasks.length + numRunning === 0;\n        },\n        pause: function () {\n            q.paused = true;\n        },\n        resume: function () {\n            if (q.paused === false) { return; }\n            q.paused = false;\n            setImmediate$1(q.process);\n        }\n    };\n    return q;\n}\n\n/**\n * A cargo of tasks for the worker function to complete. Cargo inherits all of\n * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.\n * @typedef {Object} CargoObject\n * @memberOf module:ControlFlow\n * @property {Function} length - A function returning the number of items\n * waiting to be processed. Invoke like `cargo.length()`.\n * @property {number} payload - An `integer` for determining how many tasks\n * should be process per round. This property can be changed after a `cargo` is\n * created to alter the payload on-the-fly.\n * @property {Function} push - Adds `task` to the `queue`. The callback is\n * called once the `worker` has finished processing the task. Instead of a\n * single task, an array of `tasks` can be submitted. The respective callback is\n * used for every task in the list. Invoke like `cargo.push(task, [callback])`.\n * @property {Function} saturated - A callback that is called when the\n * `queue.length()` hits the concurrency and further tasks will be queued.\n * @property {Function} empty - A callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - A callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke like `cargo.idle()`.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke like `cargo.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke like `cargo.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.\n */\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargo.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n */\nfunction cargo(worker, payload) {\n    return queue(worker, 1, payload);\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachOfSeries = doLimit(eachOfLimit, 1);\n\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf module:Collections\n * @method\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @example\n *\n * async.reduce([1,2,3], 0, function(memo, item, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         callback(null, memo + item)\n *     });\n * }, function(err, result) {\n *     // result is now equal to the last value of memo, which is 6\n * });\n */\nfunction reduce(coll, memo, iteratee, callback) {\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    eachOfSeries(coll, function(x, i, callback) {\n        _iteratee(memo, x, function(err, v) {\n            memo = v;\n            callback(err);\n        });\n    }, function(err) {\n        callback(err, memo);\n    });\n}\n\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.compose]{@link module:ControlFlow.compose}\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */\nfunction seq(/*...functions*/) {\n    var _functions = arrayMap(arguments, wrapAsync);\n    return function(/*...args*/) {\n        var args = slice(arguments);\n        var that = this;\n\n        var cb = args[args.length - 1];\n        if (typeof cb == 'function') {\n            args.pop();\n        } else {\n            cb = noop;\n        }\n\n        reduce(_functions, args, function(newargs, fn, cb) {\n            fn.apply(that, newargs.concat(function(err/*, ...nextargs*/) {\n                var nextargs = slice(arguments, 1);\n                cb(err, nextargs);\n            }));\n        },\n        function(err, results) {\n            cb.apply(that, [err].concat(results));\n        });\n    };\n}\n\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */\nvar compose = function(/*...args*/) {\n    return seq.apply(null, slice(arguments).reverse());\n};\n\nvar _concat = Array.prototype.concat;\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.\n *\n * @name concatLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatLimit = function(coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(coll, limit, function(val, callback) {\n        _iteratee(val, function(err /*, ...args*/) {\n            if (err) return callback(err);\n            return callback(null, slice(arguments, 1));\n        });\n    }, function(err, mapResults) {\n        var result = [];\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                result = _concat.apply(result, mapResults[i]);\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. There is no guarantee that the\n * results array will be returned in the original order of `coll` passed to the\n * `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @example\n *\n * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {\n *     // files is now a list of filenames that exist in the 3 directories\n * });\n */\nvar concat = doLimit(concatLimit, Infinity);\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n * The iteratee should complete with an array an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatSeries = doLimit(concatLimit, 1);\n\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n * [`auto`]{@link module:ControlFlow.auto}.\n *\n * @name constant\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {AsyncFunction} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */\nvar constant = function(/*...values*/) {\n    var values = slice(arguments);\n    var args = [null].concat(values);\n    return function (/*...ignoredArgs, callback*/) {\n        var callback = arguments[arguments.length - 1];\n        return callback.apply(this, args);\n    };\n};\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nfunction _createTester(check, getResult) {\n    return function(eachfn, arr, iteratee, cb) {\n        cb = cb || noop;\n        var testPassed = false;\n        var testResult;\n        eachfn(arr, function(value, _, callback) {\n            iteratee(value, function(err, result) {\n                if (err) {\n                    callback(err);\n                } else if (check(result) && !testResult) {\n                    testPassed = true;\n                    testResult = getResult(true, value);\n                    callback(null, breakLoop);\n                } else {\n                    callback();\n                }\n            });\n        }, function(err) {\n            if (err) {\n                cb(err);\n            } else {\n                cb(null, testPassed ? testResult : getResult(false));\n            }\n        });\n    };\n}\n\nfunction _findGetResult(v, x) {\n    return x;\n}\n\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @example\n *\n * async.detect(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // result now equals the first file in the list that exists\n * });\n */\nvar detect = doParallel(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findLimit\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectLimit = doParallelLimit(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findSeries\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectSeries = doLimit(detectLimit, 1);\n\nfunction consoleFunc(name) {\n    return function (fn/*, ...args*/) {\n        var args = slice(arguments, 1);\n        args.push(function (err/*, ...args*/) {\n            var args = slice(arguments, 1);\n            if (typeof console === 'object') {\n                if (err) {\n                    if (console.error) {\n                        console.error(err);\n                    }\n                } else if (console[name]) {\n                    arrayEach(args, function (x) {\n                        console[name](x);\n                    });\n                }\n            }\n        });\n        wrapAsync(fn).apply(null, args);\n    };\n}\n\n/**\n * Logs the result of an [`async` function]{@link AsyncFunction} to the\n * `console` using `console.dir` to display the properties of the resulting object.\n * Only works in Node.js or in browsers that support `console.dir` and\n * `console.error` (such as FF and Chrome).\n * If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name dir\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */\nvar dir = consoleFunc('dir');\n\n/**\n * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in\n * the order of operations, the arguments `test` and `fn` are switched.\n *\n * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.\n * @name doDuring\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.during]{@link module:ControlFlow.during}\n * @category Control Flow\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `fn`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error if one occurred, otherwise `null`.\n */\nfunction doDuring(fn, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync(fn);\n    var _test = wrapAsync(test);\n\n    function next(err/*, ...args*/) {\n        if (err) return callback(err);\n        var args = slice(arguments, 1);\n        args.push(check);\n        _test.apply(this, args);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    check(null, true);\n\n}\n\n/**\n * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `iteratee` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - A function which is called each time `test`\n * passes. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped.\n * `callback` will be passed an error and any arguments passed to the final\n * `iteratee`'s callback. Invoked with (err, [results]);\n */\nfunction doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    var next = function(err/*, ...args*/) {\n        if (err) return callback(err);\n        var args = slice(arguments, 1);\n        if (test.apply(this, args)) return _iteratee(next);\n        callback.apply(null, [null].concat(args));\n    };\n    _iteratee(next);\n}\n\n/**\n * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction doUntil(iteratee, test, callback) {\n    doWhilst(iteratee, function() {\n        return !test.apply(this, arguments);\n    }, callback);\n}\n\n/**\n * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that\n * is passed a callback in the form of `function (err, truth)`. If error is\n * passed to `test` or `fn`, the main callback is immediately called with the\n * value of the error.\n *\n * @name during\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (callback).\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error, if one occurred, otherwise `null`.\n * @example\n *\n * var count = 0;\n *\n * async.during(\n *     function (callback) {\n *         return callback(null, count < 5);\n *     },\n *     function (callback) {\n *         count++;\n *         setTimeout(callback, 1000);\n *     },\n *     function (err) {\n *         // 5 seconds have passed\n *     }\n * );\n */\nfunction during(test, fn, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync(fn);\n    var _test = wrapAsync(test);\n\n    function next(err) {\n        if (err) return callback(err);\n        _test(check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    _test(check);\n}\n\nfunction _withoutIndex(iteratee) {\n    return function (value, index, callback) {\n        return iteratee(value, callback);\n    };\n}\n\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEach\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to\n * each item in `coll`. Invoked with (item, callback).\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * // assuming openFiles is an array of file names and saveFile is a function\n * // to save the modified contents of that file:\n *\n * async.each(openFiles, saveFile, function(err){\n *   // if any of the saves produced an error, err would equal that error\n * });\n *\n * // assuming openFiles is an array of file names\n * async.each(openFiles, function(file, callback) {\n *\n *     // Perform operation on file here.\n *     console.log('Processing file ' + file);\n *\n *     if( file.length > 32 ) {\n *       console.log('This file name is too long');\n *       callback('File name too long');\n *     } else {\n *       // Do work to process file here\n *       console.log('File processed');\n *       callback();\n *     }\n * }, function(err) {\n *     // if any of the file processing produced an error, err would equal that error\n *     if( err ) {\n *       // One of the iterations produced an error.\n *       // All processing will now stop.\n *       console.log('A file failed to process');\n *     } else {\n *       console.log('All files have been processed successfully');\n *     }\n * });\n */\nfunction eachLimit(coll, iteratee, callback) {\n    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachLimit$1(coll, limit, iteratee, callback) {\n    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachSeries = doLimit(eachLimit$1, 1);\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    if (isAsync(fn)) return fn;\n    return initialParams(function (args, callback) {\n        var sync = true;\n        args.push(function () {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate$1(function () {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    });\n}\n\nfunction notId(v) {\n    return !v;\n}\n\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf module:Collections\n * @method\n * @alias all\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @example\n *\n * async.every(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then every file exists\n * });\n */\nvar every = doParallel(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everyLimit = doParallelLimit(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in series.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everySeries = doLimit(everyLimit, 1);\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nfunction filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            truthValues[index] = !!v;\n            callback(err);\n        });\n    }, function (err) {\n        if (err) return callback(err);\n        var results = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (truthValues[i]) results.push(arr[i]);\n        }\n        callback(null, results);\n    });\n}\n\nfunction filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            if (err) {\n                callback(err);\n            } else {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            }\n        });\n    }, function (err) {\n        if (err) {\n            callback(err);\n        } else {\n            callback(null, arrayMap(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), baseProperty('value')));\n        }\n    });\n}\n\nfunction _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    filter(eachfn, coll, wrapAsync(iteratee), callback || noop);\n}\n\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf module:Collections\n * @method\n * @alias select\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.filter(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of the existing files\n * });\n */\nvar filter = doParallel(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar filterLimit = doParallelLimit(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n */\nvar filterSeries = doLimit(filterLimit, 1);\n\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the callback then `errback` is called with the\n * error, and execution stops, otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} fn - an async function to call repeatedly.\n * Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */\nfunction forever(fn, errback) {\n    var done = onlyOnce(errback || noop);\n    var task = wrapAsync(ensureAsync(fn));\n\n    function next(err) {\n        if (err) return done(err);\n        task(next);\n    }\n    next();\n}\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n *\n * @name groupByLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupByLimit = function(coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(coll, limit, function(val, callback) {\n        _iteratee(val, function(err, key) {\n            if (err) return callback(err);\n            return callback(null, {key: key, val: val});\n        });\n    }, function(err, mapResults) {\n        var result = {};\n        // from MDN, handle object having an `hasOwnProperty` prop\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                var key = mapResults[i].key;\n                var val = mapResults[i].val;\n\n                if (hasOwnProperty.call(result, key)) {\n                    result[key].push(val);\n                } else {\n                    result[key] = [val];\n                }\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Returns a new object, where each value corresponds to an array of items, from\n * `coll`, that returned the corresponding key. That is, the keys of the object\n * correspond to the values passed to the `iteratee` callback.\n *\n * Note: Since this function applies the `iteratee` to each item in parallel,\n * there is no guarantee that the `iteratee` functions will complete in order.\n * However, the values for each key in the `result` will be in the same order as\n * the original `coll`. For Objects, the values will roughly be in the order of\n * the original Objects' keys (but this can vary across JavaScript engines).\n *\n * @name groupBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @example\n *\n * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {\n *     db.findById(userId, function(err, user) {\n *         if (err) return callback(err);\n *         return callback(null, user.age);\n *     });\n * }, function(err, result) {\n *     // result is object containing the userIds grouped by age\n *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};\n * });\n */\nvar groupBy = doLimit(groupByLimit, Infinity);\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n *\n * @name groupBySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupBySeries = doLimit(groupByLimit, 1);\n\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */\nvar log = consoleFunc('log');\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nfunction mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback || noop);\n    var newObj = {};\n    var _iteratee = wrapAsync(iteratee);\n    eachOfLimit(obj, limit, function(val, key, next) {\n        _iteratee(val, key, function (err, result) {\n            if (err) return next(err);\n            newObj[key] = result;\n            next();\n        });\n    }, function (err) {\n        callback(err, newObj);\n    });\n}\n\n/**\n * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @example\n *\n * async.mapValues({\n *     f1: 'file1',\n *     f2: 'file2',\n *     f3: 'file3'\n * }, function (file, key, callback) {\n *   fs.stat(file, callback);\n * }, function(err, result) {\n *     // result is now a map of stats for each file, e.g.\n *     // {\n *     //     f1: [stats for file1],\n *     //     f2: [stats for file2],\n *     //     f3: [stats for file3]\n *     // }\n * });\n */\n\nvar mapValues = doLimit(mapValuesLimit, Infinity);\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nvar mapValuesSeries = doLimit(mapValuesLimit, 1);\n\nfunction has(obj, key) {\n    return key in obj;\n}\n\n/**\n * Caches the results of an async function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {AsyncFunction} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */\nfunction memoize(fn, hasher) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    hasher = hasher || identity;\n    var _fn = wrapAsync(fn);\n    var memoized = initialParams(function memoized(args, callback) {\n        var key = hasher.apply(null, args);\n        if (has(memo, key)) {\n            setImmediate$1(function() {\n                callback.apply(null, memo[key]);\n            });\n        } else if (has(queues, key)) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [callback];\n            _fn.apply(null, args.concat(function(/*args*/) {\n                var args = slice(arguments);\n                memo[key] = args;\n                var q = queues[key];\n                delete queues[key];\n                for (var i = 0, l = q.length; i < l; i++) {\n                    q[i].apply(null, args);\n                }\n            }));\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `process.nextTick`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.setImmediate]{@link module:Utils.setImmediate}\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nvar _defer$1;\n\nif (hasNextTick) {\n    _defer$1 = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n} else {\n    _defer$1 = fallback;\n}\n\nvar nextTick = wrap(_defer$1);\n\nfunction _parallel(eachfn, tasks, callback) {\n    callback = callback || noop;\n    var results = isArrayLike(tasks) ? [] : {};\n\n    eachfn(tasks, function (task, key, callback) {\n        wrapAsync(task)(function (err, result) {\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            }\n            results[key] = result;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n * execution of other tasks when a task fails.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n *\n * @example\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // the results array will equal ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equals to: {one: 1, two: 2}\n * });\n */\nfunction parallelLimit(tasks, callback) {\n    _parallel(eachOf, tasks, callback);\n}\n\n/**\n * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallelLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.parallel]{@link module:ControlFlow.parallel}\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n */\nfunction parallelLimit$1(tasks, limit, callback) {\n    _parallel(_eachOfLimit(limit), tasks, callback);\n}\n\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Object} QueueObject\n * @memberOf module:ControlFlow\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {boolean} started - a boolean indicating whether or not any\n * items have been pushed and processed by the queue.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {Function} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {Function} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {Function} remove - remove items from the queue that match a test\n * function.  The test function will be passed an object with a `data` property,\n * and a `priority` property, if this is a\n * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.\n * Invoked with `queue.remove(testFn)`, where `testFn` is of the form\n * `function ({data, priority}) {}` and returns a Boolean.\n * @property {Function} saturated - a callback that is called when the number of\n * running workers hits the `concurrency` limit, and further tasks will be\n * queued.\n * @property {Function} unsaturated - a callback that is called when the number\n * of running workers is less than the `concurrency` & `buffer` limits, and\n * further tasks will not be queued.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - a callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} error - a callback that is called when a task errors.\n * Has the signature `function(error, task)`.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. No more tasks\n * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.\n */\n\n/**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`. Invoked with (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain = function() {\n *     console.log('all items have been processed');\n * };\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * q.push({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */\nvar queue$1 = function (worker, concurrency) {\n    var _worker = wrapAsync(worker);\n    return queue(function (items, cb) {\n        _worker(items[0], cb);\n    }, concurrency, 1);\n};\n\n/**\n * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`.\n * Invoked with (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * The `unshift` method was removed.\n */\nvar priorityQueue = function(worker, concurrency) {\n    // Start with a normal queue\n    var q = queue$1(worker, concurrency);\n\n    // Override push to accept second parameter representing priority\n    q.push = function(data, priority, callback) {\n        if (callback == null) callback = noop;\n        if (typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function() {\n                q.drain();\n            });\n        }\n\n        priority = priority || 0;\n        var nextNode = q._tasks.head;\n        while (nextNode && priority >= nextNode.priority) {\n            nextNode = nextNode.next;\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                priority: priority,\n                callback: callback\n            };\n\n            if (nextNode) {\n                q._tasks.insertBefore(nextNode, item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    };\n\n    // Remove unshift function\n    delete q.unshift;\n\n    return q;\n};\n\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any of the `tasks` complete or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n * to run. Each function can complete with an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns undefined\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */\nfunction race(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    for (var i = 0, l = tasks.length; i < l; i++) {\n        wrapAsync(tasks[i])(callback);\n    }\n}\n\n/**\n * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reduce]{@link module:Collections.reduce}\n * @alias foldr\n * @category Collection\n * @param {Array} array - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n */\nfunction reduceRight (array, memo, iteratee, callback) {\n    var reversed = slice(array).reverse();\n    reduce(reversed, memo, iteratee, callback);\n}\n\n/**\n * Wraps the async function in another function that always completes with a\n * result object, even when it errors.\n *\n * The result object has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */\nfunction reflect(fn) {\n    var _fn = wrapAsync(fn);\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push(function callback(error, cbArg) {\n            if (error) {\n                reflectCallback(null, { error: error });\n            } else {\n                var value;\n                if (arguments.length <= 2) {\n                    value = cbArg;\n                } else {\n                    value = slice(arguments, 1);\n                }\n                reflectCallback(null, { value: value });\n            }\n        });\n\n        return _fn.apply(this, args);\n    });\n}\n\n/**\n * A helper function that wraps an array or an object of functions with `reflect`.\n *\n * @name reflectAll\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.reflect]{@link module:Utils.reflect}\n * @category Util\n * @param {Array|Object|Iterable} tasks - The collection of\n * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n * @returns {Array} Returns an array of async functions, each wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n *\n * // an example using an object instead of an array\n * let tasks = {\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         callback('two');\n *     },\n *     three: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'three');\n *         }, 100);\n *     }\n * };\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results.one.value = 'one'\n *     // results.two.error = 'two'\n *     // results.three.value = 'three'\n * });\n */\nfunction reflectAll(tasks) {\n    var results;\n    if (isArray(tasks)) {\n        results = arrayMap(tasks, reflect);\n    } else {\n        results = {};\n        baseForOwn(tasks, function(task, key) {\n            results[key] = reflect.call(this, task);\n        });\n    }\n    return results;\n}\n\nfunction reject$1(eachfn, arr, iteratee, callback) {\n    _filter(eachfn, arr, function(value, cb) {\n        iteratee(value, function(err, v) {\n            cb(err, !v);\n        });\n    }, callback);\n}\n\n/**\n * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.reject(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of missing files\n *     createFiles(results);\n * });\n */\nvar reject = doParallel(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectLimit = doParallelLimit(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectSeries = doLimit(rejectLimit, 1);\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant$1(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant$1(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ?\n                t.interval :\n                constant$1(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || noop;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || noop;\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = wrapAsync(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task(function(err) {\n            if (err && attempt++ < options.times &&\n                (typeof options.errorFilter != 'function' ||\n                    options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\n            } else {\n                callback.apply(null, arguments);\n            }\n        });\n    }\n\n    retryAttempt();\n}\n\n/**\n * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n * wraps a task and makes it retryable, rather than immediately calling it\n * with retries.\n *\n * @name retryable\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.retry]{@link module:ControlFlow.retry}\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`\n * @param {AsyncFunction} task - the asynchronous function to wrap.\n * This function will be passed any arguments passed to the returned wrapper.\n * Invoked with (...args, callback).\n * @returns {AsyncFunction} The wrapped function, which when invoked, will\n * retry on an error, based on the parameters specified in `opts`.\n * This function will accept the same parameters as `task`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */\nvar retryable = function (opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    var _task = wrapAsync(task);\n    return initialParams(function (args, callback) {\n        function taskFn(cb) {\n            _task.apply(null, args.concat(cb));\n        }\n\n        if (opts) retry(opts, taskFn, callback);\n        else retry(taskFn, callback);\n\n    });\n};\n\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing\n * [async functions]{@link AsyncFunction} to run in series.\n * Each function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @example\n * async.series([\n *     function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     },\n *     function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // results is now equal to ['one', 'two']\n * });\n *\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback){\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equal to: {one: 1, two: 2}\n * });\n */\nfunction series(tasks, callback) {\n    _parallel(eachOfSeries, tasks, callback);\n}\n\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf module:Collections\n * @method\n * @alias any\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @example\n *\n * async.some(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then at least one of the files exists\n * });\n */\nvar some = doParallel(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anyLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someLimit = doParallelLimit(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anySeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in series.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someSeries = doLimit(someLimit, 1);\n\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a value to use as the sort criteria as\n * its `result`.\n * Invoked with (item, callback).\n * @param {Function} callback - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @example\n *\n * async.sortBy(['file1','file2','file3'], function(file, callback) {\n *     fs.stat(file, function(err, stats) {\n *         callback(err, stats.mtime);\n *     });\n * }, function(err, results) {\n *     // results is now the original array of files sorted by\n *     // modified date\n * });\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x);\n * }, function(err,result) {\n *     // result callback\n * });\n *\n * // descending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around\n * }, function(err,result) {\n *     // result callback\n * });\n */\nfunction sortBy (coll, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    map(coll, function (x, callback) {\n        _iteratee(x, function (err, criteria) {\n            if (err) return callback(err);\n            callback(null, {value: x, criteria: criteria});\n        });\n    }, function (err, results) {\n        if (err) return callback(err);\n        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));\n    });\n\n    function comparator(left, right) {\n        var a = left.criteria, b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} asyncFn - The async function to limit in time.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n * of the control flow functions.\n * Invoke this function with the same parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */\nfunction timeout(asyncFn, milliseconds, info) {\n    var fn = wrapAsync(asyncFn);\n\n    return initialParams(function (args, callback) {\n        var timedOut = false;\n        var timer;\n\n        function timeoutCallback() {\n            var name = asyncFn.name || 'anonymous';\n            var error  = new Error('Callback function \"' + name + '\" timed out.');\n            error.code = 'ETIMEDOUT';\n            if (info) {\n                error.info = info;\n            }\n            timedOut = true;\n            callback(error);\n        }\n\n        args.push(function () {\n            if (!timedOut) {\n                callback.apply(null, arguments);\n                clearTimeout(timer);\n            }\n        });\n\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        fn.apply(null, args);\n    });\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil;\nvar nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name timesLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n */\nfunction timeLimit(count, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);\n}\n\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with [map]{@link module:Collections.map}.\n *\n * @name times\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */\nvar times = doLimit(timeLimit, Infinity);\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n */\nvar timesSeries = doLimit(timeLimit, 1);\n\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in series, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @example\n *\n * async.transform([1,2,3], function(acc, item, index, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         acc.push(item * 2)\n *         callback(null)\n *     });\n * }, function(err, result) {\n *     // result is now equal to [2, 4, 6]\n * });\n *\n * @example\n *\n * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {\n *     setImmediate(function () {\n *         obj[key] = val * 2;\n *         callback();\n *     })\n * }, function (err, result) {\n *     // result is equal to {a: 2, b: 4, c: 6}\n * })\n */\nfunction transform (coll, accumulator, iteratee, callback) {\n    if (arguments.length <= 3) {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = isArray(coll) ? [] : {};\n    }\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n\n    eachOf(coll, function(v, k, cb) {\n        _iteratee(accumulator, v, k, cb);\n    }, function(err) {\n        callback(err, accumulator);\n    });\n}\n\n/**\n * It runs each task in series but stops whenever any of the functions were\n * successful. If one of the tasks were successful, the `callback` will be\n * passed the result of the successful task. If all tasks fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name tryEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing functions to\n * run, each function is passed a `callback(err, result)` it must call on\n * completion with an error `err` (which can be `null`) and an optional `result`\n * value.\n * @param {Function} [callback] - An optional callback which is called when one\n * of the tasks has succeeded, or all have failed. It receives the `err` and\n * `result` arguments of the last attempt at completing the `task`. Invoked with\n * (err, results).\n * @example\n * async.tryEach([\n *     function getDataFromFirstWebsite(callback) {\n *         // Try getting the data from the first website\n *         callback(err, data);\n *     },\n *     function getDataFromSecondWebsite(callback) {\n *         // First website failed,\n *         // Try getting the data from the backup website\n *         callback(err, data);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     Now do something with the data.\n * });\n *\n */\nfunction tryEach(tasks, callback) {\n    var error = null;\n    var result;\n    callback = callback || noop;\n    eachSeries(tasks, function(task, callback) {\n        wrapAsync(task)(function (err, res/*, ...args*/) {\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            } else {\n                result = res;\n            }\n            error = err;\n            callback(!err);\n        });\n    }, function () {\n        callback(error, result);\n    });\n}\n\n/**\n * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.memoize]{@link module:Utils.memoize}\n * @category Util\n * @param {AsyncFunction} fn - the memoized function\n * @returns {AsyncFunction} a function that calls the original unmemoized function\n */\nfunction unmemoize(fn) {\n    return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n    };\n}\n\n/**\n * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns undefined\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function() { return count < 5; },\n *     function(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */\nfunction whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    if (!test()) return callback(null);\n    var next = function(err/*, ...args*/) {\n        if (err) return callback(err);\n        if (test()) return _iteratee(next);\n        var args = slice(arguments, 1);\n        callback.apply(null, [null].concat(args));\n    };\n    _iteratee(next);\n}\n\n/**\n * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `iteratee`'s callback.\n *\n * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n *\n * @name until\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction until(test, iteratee, callback) {\n    whilst(function() {\n        return !test.apply(this, arguments);\n    }, iteratee, callback);\n}\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nvar waterfall = function(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = wrapAsync(tasks[taskIndex++]);\n        args.push(onlyOnce(next));\n        task.apply(null, args);\n    }\n\n    function next(err/*, ...args*/) {\n        if (err || taskIndex === tasks.length) {\n            return callback.apply(null, arguments);\n        }\n        nextTask(slice(arguments, 1));\n    }\n\n    nextTask([]);\n};\n\n/**\n * An \"async function\" in the context of Async is an asynchronous function with\n * a variable number of parameters, with the final parameter being a callback.\n * (`function (arg1, arg2, ..., callback) {}`)\n * The final callback is of the form `callback(err, results...)`, which must be\n * called once the function is completed.  The callback should be called with a\n * Error as its first argument to signal that an error occurred.\n * Otherwise, if no error occurred, it should be called with `null` as the first\n * argument, and any additional `result` arguments that may apply, to signal\n * successful completion.\n * The callback must be called exactly once, ideally on a later tick of the\n * JavaScript event loop.\n *\n * This type of function is also referred to as a \"Node-style async function\",\n * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n * library are themselves CPS/Node-style async functions, or functions that\n * return CPS/Node-style async functions.\n *\n * Wherever we accept a Node-style async function, we also directly accept an\n * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n * In this case, the `async` function will not be passed a final callback\n * argument, and any thrown error will be used as the `err` argument of the\n * implicit callback, and the return value will be used as the `result` value.\n * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n * argument, and a `resolved` value becomes the `result`.)\n *\n * Note, due to JavaScript limitations, we can only detect native `async`\n * functions and not transpilied implementations.\n * Your environment must have `async`/`await` support for this to work.\n * (e.g. Node > v7.6, or a recent version of a modern browser).\n * If you are using `async` functions through a transpiler (e.g. Babel), you\n * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n * because the `async function` will be compiled to an ordinary function that\n * returns a promise.\n *\n * @typedef {Function} AsyncFunction\n * @static\n */\n\n/**\n * Async is a utility module which provides straight-forward, powerful functions\n * for working with asynchronous JavaScript. Although originally designed for\n * use with [Node.js](http://nodejs.org) and installable via\n * `npm install --save async`, it can also be used directly in the browser.\n * @module async\n * @see AsyncFunction\n */\n\n\n/**\n * A collection of `async` functions for manipulating collections, such as\n * arrays and objects.\n * @module Collections\n */\n\n/**\n * A collection of `async` functions for controlling the flow through a script.\n * @module ControlFlow\n */\n\n/**\n * A collection of `async` utility functions.\n * @module Utils\n */\n\nvar index = {\n    apply: apply,\n    applyEach: applyEach,\n    applyEachSeries: applyEachSeries,\n    asyncify: asyncify,\n    auto: auto,\n    autoInject: autoInject,\n    cargo: cargo,\n    compose: compose,\n    concat: concat,\n    concatLimit: concatLimit,\n    concatSeries: concatSeries,\n    constant: constant,\n    detect: detect,\n    detectLimit: detectLimit,\n    detectSeries: detectSeries,\n    dir: dir,\n    doDuring: doDuring,\n    doUntil: doUntil,\n    doWhilst: doWhilst,\n    during: during,\n    each: eachLimit,\n    eachLimit: eachLimit$1,\n    eachOf: eachOf,\n    eachOfLimit: eachOfLimit,\n    eachOfSeries: eachOfSeries,\n    eachSeries: eachSeries,\n    ensureAsync: ensureAsync,\n    every: every,\n    everyLimit: everyLimit,\n    everySeries: everySeries,\n    filter: filter,\n    filterLimit: filterLimit,\n    filterSeries: filterSeries,\n    forever: forever,\n    groupBy: groupBy,\n    groupByLimit: groupByLimit,\n    groupBySeries: groupBySeries,\n    log: log,\n    map: map,\n    mapLimit: mapLimit,\n    mapSeries: mapSeries,\n    mapValues: mapValues,\n    mapValuesLimit: mapValuesLimit,\n    mapValuesSeries: mapValuesSeries,\n    memoize: memoize,\n    nextTick: nextTick,\n    parallel: parallelLimit,\n    parallelLimit: parallelLimit$1,\n    priorityQueue: priorityQueue,\n    queue: queue$1,\n    race: race,\n    reduce: reduce,\n    reduceRight: reduceRight,\n    reflect: reflect,\n    reflectAll: reflectAll,\n    reject: reject,\n    rejectLimit: rejectLimit,\n    rejectSeries: rejectSeries,\n    retry: retry,\n    retryable: retryable,\n    seq: seq,\n    series: series,\n    setImmediate: setImmediate$1,\n    some: some,\n    someLimit: someLimit,\n    someSeries: someSeries,\n    sortBy: sortBy,\n    timeout: timeout,\n    times: times,\n    timesLimit: timeLimit,\n    timesSeries: timesSeries,\n    transform: transform,\n    tryEach: tryEach,\n    unmemoize: unmemoize,\n    until: until,\n    waterfall: waterfall,\n    whilst: whilst,\n\n    // aliases\n    all: every,\n    allLimit: everyLimit,\n    allSeries: everySeries,\n    any: some,\n    anyLimit: someLimit,\n    anySeries: someSeries,\n    find: detect,\n    findLimit: detectLimit,\n    findSeries: detectSeries,\n    forEach: eachLimit,\n    forEachSeries: eachSeries,\n    forEachLimit: eachLimit$1,\n    forEachOf: eachOf,\n    forEachOfSeries: eachOfSeries,\n    forEachOfLimit: eachOfLimit,\n    inject: reduce,\n    foldl: reduce,\n    foldr: reduceRight,\n    select: filter,\n    selectLimit: filterLimit,\n    selectSeries: filterSeries,\n    wrapSync: asyncify\n};\n\nexports['default'] = index;\nexports.apply = apply;\nexports.applyEach = applyEach;\nexports.applyEachSeries = applyEachSeries;\nexports.asyncify = asyncify;\nexports.auto = auto;\nexports.autoInject = autoInject;\nexports.cargo = cargo;\nexports.compose = compose;\nexports.concat = concat;\nexports.concatLimit = concatLimit;\nexports.concatSeries = concatSeries;\nexports.constant = constant;\nexports.detect = detect;\nexports.detectLimit = detectLimit;\nexports.detectSeries = detectSeries;\nexports.dir = dir;\nexports.doDuring = doDuring;\nexports.doUntil = doUntil;\nexports.doWhilst = doWhilst;\nexports.during = during;\nexports.each = eachLimit;\nexports.eachLimit = eachLimit$1;\nexports.eachOf = eachOf;\nexports.eachOfLimit = eachOfLimit;\nexports.eachOfSeries = eachOfSeries;\nexports.eachSeries = eachSeries;\nexports.ensureAsync = ensureAsync;\nexports.every = every;\nexports.everyLimit = everyLimit;\nexports.everySeries = everySeries;\nexports.filter = filter;\nexports.filterLimit = filterLimit;\nexports.filterSeries = filterSeries;\nexports.forever = forever;\nexports.groupBy = groupBy;\nexports.groupByLimit = groupByLimit;\nexports.groupBySeries = groupBySeries;\nexports.log = log;\nexports.map = map;\nexports.mapLimit = mapLimit;\nexports.mapSeries = mapSeries;\nexports.mapValues = mapValues;\nexports.mapValuesLimit = mapValuesLimit;\nexports.mapValuesSeries = mapValuesSeries;\nexports.memoize = memoize;\nexports.nextTick = nextTick;\nexports.parallel = parallelLimit;\nexports.parallelLimit = parallelLimit$1;\nexports.priorityQueue = priorityQueue;\nexports.queue = queue$1;\nexports.race = race;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.reflect = reflect;\nexports.reflectAll = reflectAll;\nexports.reject = reject;\nexports.rejectLimit = rejectLimit;\nexports.rejectSeries = rejectSeries;\nexports.retry = retry;\nexports.retryable = retryable;\nexports.seq = seq;\nexports.series = series;\nexports.setImmediate = setImmediate$1;\nexports.some = some;\nexports.someLimit = someLimit;\nexports.someSeries = someSeries;\nexports.sortBy = sortBy;\nexports.timeout = timeout;\nexports.times = times;\nexports.timesLimit = timeLimit;\nexports.timesSeries = timesSeries;\nexports.transform = transform;\nexports.tryEach = tryEach;\nexports.unmemoize = unmemoize;\nexports.until = until;\nexports.waterfall = waterfall;\nexports.whilst = whilst;\nexports.all = every;\nexports.allLimit = everyLimit;\nexports.allSeries = everySeries;\nexports.any = some;\nexports.anyLimit = someLimit;\nexports.anySeries = someSeries;\nexports.find = detect;\nexports.findLimit = detectLimit;\nexports.findSeries = detectSeries;\nexports.forEach = eachLimit;\nexports.forEachSeries = eachSeries;\nexports.forEachLimit = eachLimit$1;\nexports.forEachOf = eachOf;\nexports.forEachOfSeries = eachOfSeries;\nexports.forEachOfLimit = eachOfLimit;\nexports.inject = reduce;\nexports.foldl = reduce;\nexports.foldr = reduceRight;\nexports.select = filter;\nexports.selectLimit = filterLimit;\nexports.selectSeries = filterSeries;\nexports.wrapSync = asyncify;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n",
    "(function(){\nvar f, aa = aa || {}, l = this;\nfunction ba(a) {\n  a = a.split(\".\");\n  for (var b = l, c;c = a.shift();) {\n    if (null != b[c]) {\n      b = b[c];\n    } else {\n      return null;\n    }\n  }\n  return b;\n}\nfunction ca() {\n}\nfunction da(a) {\n  var b = typeof a;\n  if (\"object\" == b) {\n    if (a) {\n      if (a instanceof Array) {\n        return \"array\";\n      }\n      if (a instanceof Object) {\n        return b;\n      }\n      var c = Object.prototype.toString.call(a);\n      if (\"[object Window]\" == c) {\n        return \"object\";\n      }\n      if (\"[object Array]\" == c || \"number\" == typeof a.length && \"undefined\" != typeof a.splice && \"undefined\" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable(\"splice\")) {\n        return \"array\";\n      }\n      if (\"[object Function]\" == c || \"undefined\" != typeof a.call && \"undefined\" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable(\"call\")) {\n        return \"function\";\n      }\n    } else {\n      return \"null\";\n    }\n  } else {\n    if (\"function\" == b && \"undefined\" == typeof a.call) {\n      return \"object\";\n    }\n  }\n  return b;\n}\nfunction m(a) {\n  return \"array\" == da(a);\n}\nfunction ea(a) {\n  var b = da(a);\n  return \"array\" == b || \"object\" == b && \"number\" == typeof a.length;\n}\nfunction n(a) {\n  return \"string\" == typeof a;\n}\nfunction fa(a) {\n  return \"function\" == da(a);\n}\nvar ga = \"closure_uid_\" + (1E9 * Math.random() >>> 0), ha = 0;\nfunction ia(a, b, c) {\n  return a.call.apply(a.bind, arguments);\n}\nfunction ja(a, b, c) {\n  if (!a) {\n    throw Error();\n  }\n  if (2 < arguments.length) {\n    var d = Array.prototype.slice.call(arguments, 2);\n    return function() {\n      var c = Array.prototype.slice.call(arguments);\n      Array.prototype.unshift.apply(c, d);\n      return a.apply(b, c);\n    };\n  }\n  return function() {\n    return a.apply(b, arguments);\n  };\n}\nfunction p(a, b, c) {\n  p = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf(\"native code\") ? ia : ja;\n  return p.apply(null, arguments);\n}\nvar q = Date.now || function() {\n  return+new Date;\n};\nfunction s(a, b) {\n  function c() {\n  }\n  c.prototype = b.prototype;\n  a.pa = b.prototype;\n  a.prototype = new c;\n  a.Hc = function(a, c, g) {\n    var h = Array.prototype.slice.call(arguments, 2);\n    return b.prototype[c].apply(a, h);\n  };\n}\n;function ka(a, b) {\n  for (var c = a.split(\"%s\"), d = \"\", e = Array.prototype.slice.call(arguments, 1);e.length && 1 < c.length;) {\n    d += c.shift() + e.shift();\n  }\n  return d + c.join(\"%s\");\n}\nfunction la(a) {\n  if (!ma.test(a)) {\n    return a;\n  }\n  -1 != a.indexOf(\"&\") && (a = a.replace(na, \"&amp;\"));\n  -1 != a.indexOf(\"<\") && (a = a.replace(oa, \"&lt;\"));\n  -1 != a.indexOf(\">\") && (a = a.replace(pa, \"&gt;\"));\n  -1 != a.indexOf('\"') && (a = a.replace(qa, \"&quot;\"));\n  -1 != a.indexOf(\"'\") && (a = a.replace(ra, \"&#39;\"));\n  return a;\n}\nvar na = /&/g, oa = /</g, pa = />/g, qa = /\"/g, ra = /'/g, ma = /[&<>\"']/;\nfunction sa() {\n  return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ q()).toString(36);\n}\nfunction ta(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n;var x, ua, va, wa;\nfunction xa() {\n  return l.navigator ? l.navigator.userAgent : null;\n}\nwa = va = ua = x = !1;\nvar ya;\nif (ya = xa()) {\n  var za = l.navigator;\n  x = 0 == ya.lastIndexOf(\"Opera\", 0);\n  ua = !x && (-1 != ya.indexOf(\"MSIE\") || -1 != ya.indexOf(\"Trident\"));\n  va = !x && -1 != ya.indexOf(\"WebKit\");\n  wa = !x && !va && !ua && \"Gecko\" == za.product;\n}\nvar Aa = x, y = ua, Ba = wa, z = va;\nfunction Ca() {\n  var a = l.document;\n  return a ? a.documentMode : void 0;\n}\nvar Da;\na: {\n  var Ea = \"\", Fa;\n  if (Aa && l.opera) {\n    var Ga = l.opera.version, Ea = \"function\" == typeof Ga ? Ga() : Ga\n  } else {\n    if (Ba ? Fa = /rv\\:([^\\);]+)(\\)|;)/ : y ? Fa = /\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/ : z && (Fa = /WebKit\\/(\\S+)/), Fa) {\n      var Ha = Fa.exec(xa()), Ea = Ha ? Ha[1] : \"\"\n    }\n  }\n  if (y) {\n    var Ia = Ca();\n    if (Ia > parseFloat(Ea)) {\n      Da = String(Ia);\n      break a;\n    }\n  }\n  Da = Ea;\n}\nvar Ja = {};\nfunction A(a) {\n  var b;\n  if (!(b = Ja[a])) {\n    b = 0;\n    for (var c = String(Da).replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, \"\").split(\".\"), d = String(a).replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, \"\").split(\".\"), e = Math.max(c.length, d.length), g = 0;0 == b && g < e;g++) {\n      var h = c[g] || \"\", k = d[g] || \"\", u = RegExp(\"(\\\\d*)(\\\\D*)\", \"g\"), K = RegExp(\"(\\\\d*)(\\\\D*)\", \"g\");\n      do {\n        var v = u.exec(h) || [\"\", \"\", \"\"], r = K.exec(k) || [\"\", \"\", \"\"];\n        if (0 == v[0].length && 0 == r[0].length) {\n          break;\n        }\n        b = ta(0 == v[1].length ? 0 : parseInt(v[1], 10), 0 == r[1].length ? 0 : parseInt(r[1], 10)) || ta(0 == v[2].length, 0 == r[2].length) || ta(v[2], r[2]);\n      } while (0 == b);\n    }\n    b = Ja[a] = 0 <= b;\n  }\n  return b;\n}\nvar La = l.document, Ma = La && y ? Ca() || (\"CSS1Compat\" == La.compatMode ? parseInt(Da, 10) : 5) : void 0;\nfunction Na(a) {\n  Error.captureStackTrace ? Error.captureStackTrace(this, Na) : this.stack = Error().stack || \"\";\n  a && (this.message = String(a));\n}\ns(Na, Error);\nNa.prototype.name = \"CustomError\";\nfunction Oa(a, b) {\n  b.unshift(a);\n  Na.call(this, ka.apply(null, b));\n  b.shift();\n}\ns(Oa, Na);\nOa.prototype.name = \"AssertionError\";\nfunction Pa(a, b) {\n  throw new Oa(\"Failure\" + (a ? \": \" + a : \"\"), Array.prototype.slice.call(arguments, 1));\n}\n;var Qa = RegExp(\"^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\\\?([^#]*))?(?:#(.*))?$\");\nfunction Ra(a) {\n  if (Sa) {\n    Sa = !1;\n    var b = l.location;\n    if (b) {\n      var c = b.href;\n      if (c && (c = (c = Ra(c)[3] || null) && decodeURIComponent(c)) && c != b.hostname) {\n        throw Sa = !0, Error();\n      }\n    }\n  }\n  return a.match(Qa);\n}\nvar Sa = z;\nfunction Ta(a) {\n  var b = [], c = 0, d;\n  for (d in a) {\n    b[c++] = a[d];\n  }\n  return b;\n}\nfunction Ua(a) {\n  var b = [], c = 0, d;\n  for (d in a) {\n    b[c++] = d;\n  }\n  return b;\n}\nvar Va = \"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");\nfunction Wa(a, b) {\n  for (var c, d, e = 1;e < arguments.length;e++) {\n    d = arguments[e];\n    for (c in d) {\n      a[c] = d[c];\n    }\n    for (var g = 0;g < Va.length;g++) {\n      c = Va[g], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);\n    }\n  }\n}\n;var B = Array.prototype, Xa = B.indexOf ? function(a, b, c) {\n  return B.indexOf.call(a, b, c);\n} : function(a, b, c) {\n  c = null == c ? 0 : 0 > c ? Math.max(0, a.length + c) : c;\n  if (n(a)) {\n    return n(b) && 1 == b.length ? a.indexOf(b, c) : -1;\n  }\n  for (;c < a.length;c++) {\n    if (c in a && a[c] === b) {\n      return c;\n    }\n  }\n  return-1;\n}, Ya = B.forEach ? function(a, b, c) {\n  B.forEach.call(a, b, c);\n} : function(a, b, c) {\n  for (var d = a.length, e = n(a) ? a.split(\"\") : a, g = 0;g < d;g++) {\n    g in e && b.call(c, e[g], g, a);\n  }\n};\nfunction Za(a) {\n  var b;\n  a: {\n    b = $a;\n    for (var c = a.length, d = n(a) ? a.split(\"\") : a, e = 0;e < c;e++) {\n      if (e in d && b.call(void 0, d[e], e, a)) {\n        b = e;\n        break a;\n      }\n    }\n    b = -1;\n  }\n  return 0 > b ? null : n(a) ? a.charAt(b) : a[b];\n}\nfunction ab(a) {\n  return B.concat.apply(B, arguments);\n}\nfunction bb(a) {\n  var b = a.length;\n  if (0 < b) {\n    for (var c = Array(b), d = 0;d < b;d++) {\n      c[d] = a[d];\n    }\n    return c;\n  }\n  return[];\n}\n;function cb(a, b) {\n  this.O = {};\n  this.j = [];\n  this.o = 0;\n  var c = arguments.length;\n  if (1 < c) {\n    if (c % 2) {\n      throw Error(\"Uneven number of arguments\");\n    }\n    for (var d = 0;d < c;d += 2) {\n      this.set(arguments[d], arguments[d + 1]);\n    }\n  } else {\n    if (a) {\n      a instanceof cb ? (c = a.ca(), d = a.N()) : (c = Ua(a), d = Ta(a));\n      for (var e = 0;e < c.length;e++) {\n        this.set(c[e], d[e]);\n      }\n    }\n  }\n}\nf = cb.prototype;\nf.N = function() {\n  db(this);\n  for (var a = [], b = 0;b < this.j.length;b++) {\n    a.push(this.O[this.j[b]]);\n  }\n  return a;\n};\nf.ca = function() {\n  db(this);\n  return this.j.concat();\n};\nf.wa = function(a) {\n  return C(this.O, a);\n};\nf.remove = function(a) {\n  return C(this.O, a) ? (delete this.O[a], this.o--, this.j.length > 2 * this.o && db(this), !0) : !1;\n};\nfunction db(a) {\n  if (a.o != a.j.length) {\n    for (var b = 0, c = 0;b < a.j.length;) {\n      var d = a.j[b];\n      C(a.O, d) && (a.j[c++] = d);\n      b++;\n    }\n    a.j.length = c;\n  }\n  if (a.o != a.j.length) {\n    for (var e = {}, c = b = 0;b < a.j.length;) {\n      d = a.j[b], C(e, d) || (a.j[c++] = d, e[d] = 1), b++;\n    }\n    a.j.length = c;\n  }\n}\nf.get = function(a, b) {\n  return C(this.O, a) ? this.O[a] : b;\n};\nf.set = function(a, b) {\n  C(this.O, a) || (this.o++, this.j.push(a));\n  this.O[a] = b;\n};\nf.n = function() {\n  return new cb(this);\n};\nfunction C(a, b) {\n  return Object.prototype.hasOwnProperty.call(a, b);\n}\n;function eb(a) {\n  if (\"function\" == typeof a.N) {\n    return a.N();\n  }\n  if (n(a)) {\n    return a.split(\"\");\n  }\n  if (ea(a)) {\n    for (var b = [], c = a.length, d = 0;d < c;d++) {\n      b.push(a[d]);\n    }\n    return b;\n  }\n  return Ta(a);\n}\nfunction D(a, b, c) {\n  if (\"function\" == typeof a.forEach) {\n    a.forEach(b, c);\n  } else {\n    if (ea(a) || n(a)) {\n      Ya(a, b, c);\n    } else {\n      var d;\n      if (\"function\" == typeof a.ca) {\n        d = a.ca();\n      } else {\n        if (\"function\" != typeof a.N) {\n          if (ea(a) || n(a)) {\n            d = [];\n            for (var e = a.length, g = 0;g < e;g++) {\n              d.push(g);\n            }\n          } else {\n            d = Ua(a);\n          }\n        } else {\n          d = void 0;\n        }\n      }\n      for (var e = eb(a), g = e.length, h = 0;h < g;h++) {\n        b.call(c, e[h], d && d[h], a);\n      }\n    }\n  }\n}\n;function E(a, b) {\n  var c;\n  if (a instanceof E) {\n    this.D = void 0 !== b ? b : a.D, fb(this, a.oa), c = a.eb, F(this), this.eb = c, gb(this, a.ja), hb(this, a.Ca), ib(this, a.I), jb(this, a.R.n()), c = a.Na, F(this), this.Na = c;\n  } else {\n    if (a && (c = Ra(String(a)))) {\n      this.D = !!b;\n      fb(this, c[1] || \"\", !0);\n      var d = c[2] || \"\";\n      F(this);\n      this.eb = d ? decodeURIComponent(d) : \"\";\n      gb(this, c[3] || \"\", !0);\n      hb(this, c[4]);\n      ib(this, c[5] || \"\", !0);\n      jb(this, c[6] || \"\", !0);\n      c = c[7] || \"\";\n      F(this);\n      this.Na = c ? decodeURIComponent(c) : \"\";\n    } else {\n      this.D = !!b, this.R = new kb(null, 0, this.D);\n    }\n  }\n}\nf = E.prototype;\nf.oa = \"\";\nf.eb = \"\";\nf.ja = \"\";\nf.Ca = null;\nf.I = \"\";\nf.Na = \"\";\nf.oc = !1;\nf.D = !1;\nf.toString = function() {\n  var a = [], b = this.oa;\n  b && a.push(lb(b, mb), \":\");\n  if (b = this.ja) {\n    a.push(\"//\");\n    var c = this.eb;\n    c && a.push(lb(c, mb), \"@\");\n    a.push(encodeURIComponent(String(b)));\n    b = this.Ca;\n    null != b && a.push(\":\", String(b));\n  }\n  if (b = this.I) {\n    this.ja && \"/\" != b.charAt(0) && a.push(\"/\"), a.push(lb(b, \"/\" == b.charAt(0) ? nb : ob));\n  }\n  (b = this.R.toString()) && a.push(\"?\", b);\n  (b = this.Na) && a.push(\"#\", lb(b, pb));\n  return a.join(\"\");\n};\nf.n = function() {\n  return new E(this);\n};\nfunction fb(a, b, c) {\n  F(a);\n  a.oa = c ? b ? decodeURIComponent(b) : \"\" : b;\n  a.oa && (a.oa = a.oa.replace(/:$/, \"\"));\n}\nfunction gb(a, b, c) {\n  F(a);\n  a.ja = c ? b ? decodeURIComponent(b) : \"\" : b;\n}\nfunction hb(a, b) {\n  F(a);\n  if (b) {\n    b = Number(b);\n    if (isNaN(b) || 0 > b) {\n      throw Error(\"Bad port number \" + b);\n    }\n    a.Ca = b;\n  } else {\n    a.Ca = null;\n  }\n}\nfunction ib(a, b, c) {\n  F(a);\n  a.I = c ? b ? decodeURIComponent(b) : \"\" : b;\n}\nfunction jb(a, b, c) {\n  F(a);\n  b instanceof kb ? (a.R = b, a.R.ub(a.D)) : (c || (b = lb(b, qb)), a.R = new kb(b, 0, a.D));\n}\nfunction G(a, b, c) {\n  F(a);\n  a.R.set(b, c);\n}\nfunction rb(a, b, c) {\n  F(a);\n  m(c) || (c = [String(c)]);\n  sb(a.R, b, c);\n}\nfunction H(a) {\n  F(a);\n  G(a, \"zx\", sa());\n  return a;\n}\nfunction F(a) {\n  if (a.oc) {\n    throw Error(\"Tried to modify a read-only Uri\");\n  }\n}\nf.ub = function(a) {\n  this.D = a;\n  this.R && this.R.ub(a);\n  return this;\n};\nfunction tb(a) {\n  return a instanceof E ? a.n() : new E(a, void 0);\n}\nfunction ub(a, b, c, d) {\n  var e = new E(null, void 0);\n  a && fb(e, a);\n  b && gb(e, b);\n  c && hb(e, c);\n  d && ib(e, d);\n  return e;\n}\nfunction lb(a, b) {\n  return n(a) ? encodeURI(a).replace(b, vb) : null;\n}\nfunction vb(a) {\n  a = a.charCodeAt(0);\n  return \"%\" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);\n}\nvar mb = /[#\\/\\?@]/g, ob = /[\\#\\?:]/g, nb = /[\\#\\?]/g, qb = /[\\#\\?@]/g, pb = /#/g;\nfunction kb(a, b, c) {\n  this.C = a || null;\n  this.D = !!c;\n}\nfunction I(a) {\n  if (!a.h && (a.h = new cb, a.o = 0, a.C)) {\n    for (var b = a.C.split(\"&\"), c = 0;c < b.length;c++) {\n      var d = b[c].indexOf(\"=\"), e = null, g = null;\n      0 <= d ? (e = b[c].substring(0, d), g = b[c].substring(d + 1)) : e = b[c];\n      e = decodeURIComponent(e.replace(/\\+/g, \" \"));\n      e = J(a, e);\n      a.add(e, g ? decodeURIComponent(g.replace(/\\+/g, \" \")) : \"\");\n    }\n  }\n}\nf = kb.prototype;\nf.h = null;\nf.o = null;\nf.add = function(a, b) {\n  I(this);\n  this.C = null;\n  a = J(this, a);\n  var c = this.h.get(a);\n  c || this.h.set(a, c = []);\n  c.push(b);\n  this.o++;\n  return this;\n};\nf.remove = function(a) {\n  I(this);\n  a = J(this, a);\n  return this.h.wa(a) ? (this.C = null, this.o -= this.h.get(a).length, this.h.remove(a)) : !1;\n};\nf.wa = function(a) {\n  I(this);\n  a = J(this, a);\n  return this.h.wa(a);\n};\nf.ca = function() {\n  I(this);\n  for (var a = this.h.N(), b = this.h.ca(), c = [], d = 0;d < b.length;d++) {\n    for (var e = a[d], g = 0;g < e.length;g++) {\n      c.push(b[d]);\n    }\n  }\n  return c;\n};\nf.N = function(a) {\n  I(this);\n  var b = [];\n  if (n(a)) {\n    this.wa(a) && (b = ab(b, this.h.get(J(this, a))));\n  } else {\n    a = this.h.N();\n    for (var c = 0;c < a.length;c++) {\n      b = ab(b, a[c]);\n    }\n  }\n  return b;\n};\nf.set = function(a, b) {\n  I(this);\n  this.C = null;\n  a = J(this, a);\n  this.wa(a) && (this.o -= this.h.get(a).length);\n  this.h.set(a, [b]);\n  this.o++;\n  return this;\n};\nf.get = function(a, b) {\n  var c = a ? this.N(a) : [];\n  return 0 < c.length ? String(c[0]) : b;\n};\nfunction sb(a, b, c) {\n  a.remove(b);\n  0 < c.length && (a.C = null, a.h.set(J(a, b), bb(c)), a.o += c.length);\n}\nf.toString = function() {\n  if (this.C) {\n    return this.C;\n  }\n  if (!this.h) {\n    return \"\";\n  }\n  for (var a = [], b = this.h.ca(), c = 0;c < b.length;c++) {\n    for (var d = b[c], e = encodeURIComponent(String(d)), d = this.N(d), g = 0;g < d.length;g++) {\n      var h = e;\n      \"\" !== d[g] && (h += \"=\" + encodeURIComponent(String(d[g])));\n      a.push(h);\n    }\n  }\n  return this.C = a.join(\"&\");\n};\nf.n = function() {\n  var a = new kb;\n  a.C = this.C;\n  this.h && (a.h = this.h.n(), a.o = this.o);\n  return a;\n};\nfunction J(a, b) {\n  var c = String(b);\n  a.D && (c = c.toLowerCase());\n  return c;\n}\nf.ub = function(a) {\n  a && !this.D && (I(this), this.C = null, D(this.h, function(a, c) {\n    var d = c.toLowerCase();\n    c != d && (this.remove(c), sb(this, d, a));\n  }, this));\n  this.D = a;\n};\nfunction wb(a) {\n  a = String(a);\n  if (/^\\s*$/.test(a) ? 0 : /^[\\],:{}\\s\\u2028\\u2029]*$/.test(a.replace(/\\\\[\"\\\\\\/bfnrtu]/g, \"@\").replace(/\"[^\"\\\\\\n\\r\\u2028\\u2029\\x00-\\x08\\x0a-\\x1f]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, \"]\").replace(/(?:^|:|,)(?:[\\s\\u2028\\u2029]*\\[)+/g, \"\"))) {\n    try {\n      return eval(\"(\" + a + \")\");\n    } catch (b) {\n    }\n  }\n  throw Error(\"Invalid JSON string: \" + a);\n}\nfunction xb(a) {\n  return eval(\"(\" + a + \")\");\n}\nfunction yb(a) {\n  var b = [];\n  zb(new Ab, a, b);\n  return b.join(\"\");\n}\nfunction Ab() {\n  this.Ya = void 0;\n}\nfunction zb(a, b, c) {\n  switch(typeof b) {\n    case \"string\":\n      Bb(b, c);\n      break;\n    case \"number\":\n      c.push(isFinite(b) && !isNaN(b) ? b : \"null\");\n      break;\n    case \"boolean\":\n      c.push(b);\n      break;\n    case \"undefined\":\n      c.push(\"null\");\n      break;\n    case \"object\":\n      if (null == b) {\n        c.push(\"null\");\n        break;\n      }\n      if (m(b)) {\n        var d = b.length;\n        c.push(\"[\");\n        for (var e = \"\", g = 0;g < d;g++) {\n          c.push(e), e = b[g], zb(a, a.Ya ? a.Ya.call(b, String(g), e) : e, c), e = \",\";\n        }\n        c.push(\"]\");\n        break;\n      }\n      c.push(\"{\");\n      d = \"\";\n      for (g in b) {\n        Object.prototype.hasOwnProperty.call(b, g) && (e = b[g], \"function\" != typeof e && (c.push(d), Bb(g, c), c.push(\":\"), zb(a, a.Ya ? a.Ya.call(b, g, e) : e, c), d = \",\"));\n      }\n      c.push(\"}\");\n      break;\n    case \"function\":\n      break;\n    default:\n      throw Error(\"Unknown type: \" + typeof b);;\n  }\n}\nvar Cb = {'\"':'\\\\\"', \"\\\\\":\"\\\\\\\\\", \"/\":\"\\\\/\", \"\\b\":\"\\\\b\", \"\\f\":\"\\\\f\", \"\\n\":\"\\\\n\", \"\\r\":\"\\\\r\", \"\\t\":\"\\\\t\", \"\\x0B\":\"\\\\u000b\"}, Db = /\\uffff/.test(\"\\uffff\") ? /[\\\\\\\"\\x00-\\x1f\\x7f-\\uffff]/g : /[\\\\\\\"\\x00-\\x1f\\x7f-\\xff]/g;\nfunction Bb(a, b) {\n  b.push('\"', a.replace(Db, function(a) {\n    if (a in Cb) {\n      return Cb[a];\n    }\n    var b = a.charCodeAt(0), e = \"\\\\u\";\n    16 > b ? e += \"000\" : 256 > b ? e += \"00\" : 4096 > b && (e += \"0\");\n    return Cb[a] = e + b.toString(16);\n  }), '\"');\n}\n;function Eb(a) {\n  return Fb(a || arguments.callee.caller, []);\n}\nfunction Fb(a, b) {\n  var c = [];\n  if (0 <= Xa(b, a)) {\n    c.push(\"[...circular reference...]\");\n  } else {\n    if (a && 50 > b.length) {\n      c.push(Gb(a) + \"(\");\n      for (var d = a.arguments, e = 0;e < d.length;e++) {\n        0 < e && c.push(\", \");\n        var g;\n        g = d[e];\n        switch(typeof g) {\n          case \"object\":\n            g = g ? \"object\" : \"null\";\n            break;\n          case \"string\":\n            break;\n          case \"number\":\n            g = String(g);\n            break;\n          case \"boolean\":\n            g = g ? \"true\" : \"false\";\n            break;\n          case \"function\":\n            g = (g = Gb(g)) ? g : \"[fn]\";\n            break;\n          default:\n            g = typeof g;\n        }\n        40 < g.length && (g = g.substr(0, 40) + \"...\");\n        c.push(g);\n      }\n      b.push(a);\n      c.push(\")\\n\");\n      try {\n        c.push(Fb(a.caller, b));\n      } catch (h) {\n        c.push(\"[exception trying to get caller]\\n\");\n      }\n    } else {\n      a ? c.push(\"[...long stack...]\") : c.push(\"[end]\");\n    }\n  }\n  return c.join(\"\");\n}\nfunction Gb(a) {\n  if (Hb[a]) {\n    return Hb[a];\n  }\n  a = String(a);\n  if (!Hb[a]) {\n    var b = /function ([^\\(]+)/.exec(a);\n    Hb[a] = b ? b[1] : \"[Anonymous]\";\n  }\n  return Hb[a];\n}\nvar Hb = {};\nfunction Ib(a, b, c, d, e) {\n  this.reset(a, b, c, d, e);\n}\nIb.prototype.Fb = null;\nIb.prototype.Eb = null;\nvar Jb = 0;\nIb.prototype.reset = function(a, b, c, d, e) {\n  \"number\" == typeof e || Jb++;\n  d || q();\n  this.Aa = a;\n  this.qc = b;\n  delete this.Fb;\n  delete this.Eb;\n};\nIb.prototype.$b = function(a) {\n  this.Aa = a;\n};\nfunction L(a) {\n  this.rc = a;\n}\nL.prototype.Sa = null;\nL.prototype.Aa = null;\nL.prototype.jb = null;\nL.prototype.Jb = null;\nfunction Kb(a, b) {\n  this.name = a;\n  this.value = b;\n}\nKb.prototype.toString = function() {\n  return this.name;\n};\nvar Lb = new Kb(\"SEVERE\", 1E3), Mb = new Kb(\"WARNING\", 900), Nb = new Kb(\"INFO\", 800), Ob = new Kb(\"CONFIG\", 700), Pb = new Kb(\"FINE\", 500);\nf = L.prototype;\nf.getParent = function() {\n  return this.Sa;\n};\nf.$b = function(a) {\n  this.Aa = a;\n};\nfunction Qb(a) {\n  if (a.Aa) {\n    return a.Aa;\n  }\n  if (a.Sa) {\n    return Qb(a.Sa);\n  }\n  Pa(\"Root logger has no level set.\");\n  return null;\n}\nf.log = function(a, b, c) {\n  if (a.value >= Qb(this).value) {\n    for (fa(b) && (b = b()), a = this.mc(a, b, c), b = \"log:\" + a.qc, l.console && (l.console.timeStamp ? l.console.timeStamp(b) : l.console.markTimeline && l.console.markTimeline(b)), l.msWriteProfilerMark && l.msWriteProfilerMark(b), b = this;b;) {\n      c = b;\n      var d = a;\n      if (c.Jb) {\n        for (var e = 0, g = void 0;g = c.Jb[e];e++) {\n          g(d);\n        }\n      }\n      b = b.getParent();\n    }\n  }\n};\nf.mc = function(a, b, c) {\n  var d = new Ib(a, String(b), this.rc);\n  if (c) {\n    d.Fb = c;\n    var e;\n    var g = arguments.callee.caller;\n    try {\n      var h;\n      var k = ba(\"window.location.href\");\n      if (n(c)) {\n        h = {message:c, name:\"Unknown error\", lineNumber:\"Not available\", fileName:k, stack:\"Not available\"};\n      } else {\n        var u, K, v = !1;\n        try {\n          u = c.lineNumber || c.Ic || \"Not available\";\n        } catch (r) {\n          u = \"Not available\", v = !0;\n        }\n        try {\n          K = c.fileName || c.filename || c.sourceURL || l.$googDebugFname || k;\n        } catch (Ka) {\n          K = \"Not available\", v = !0;\n        }\n        h = !v && c.lineNumber && c.fileName && c.stack && c.message && c.name ? c : {message:c.message || \"Not available\", name:c.name || \"UnknownError\", lineNumber:u, fileName:K, stack:c.stack || \"Not available\"};\n      }\n      e = \"Message: \" + la(h.message) + '\\nUrl: <a href=\"view-source:' + h.fileName + '\" target=\"_new\">' + h.fileName + \"</a>\\nLine: \" + h.lineNumber + \"\\n\\nBrowser stack:\\n\" + la(h.stack + \"-> \") + \"[end]\\n\\nJS stack traversal:\\n\" + la(Eb(g) + \"-> \");\n    } catch (w) {\n      e = \"Exception trying to expose exception! You win, we lose. \" + w;\n    }\n    d.Eb = e;\n  }\n  return d;\n};\nf.J = function(a, b) {\n  this.log(Lb, a, b);\n};\nf.Z = function(a, b) {\n  this.log(Mb, a, b);\n};\nf.info = function(a, b) {\n  this.log(Nb, a, b);\n};\nvar Rb = {}, Sb = null;\nfunction Tb(a) {\n  Sb || (Sb = new L(\"\"), Rb[\"\"] = Sb, Sb.$b(Ob));\n  var b;\n  if (!(b = Rb[a])) {\n    b = new L(a);\n    var c = a.lastIndexOf(\".\"), d = a.substr(c + 1), c = Tb(a.substr(0, c));\n    c.jb || (c.jb = {});\n    c.jb[d] = b;\n    b.Sa = c;\n    Rb[a] = b;\n  }\n  return b;\n}\n;function M(a, b) {\n  a && a.log(Pb, b, void 0);\n}\n;function N() {\n  this.r = Tb(\"goog.net.BrowserChannel\");\n}\nfunction Ub(a, b, c, d) {\n  a.info(\"XMLHTTP TEXT (\" + b + \"): \" + Vb(a, c) + (d ? \" \" + d : \"\"));\n}\nN.prototype.debug = function(a) {\n  this.info(a);\n};\nfunction Wb(a, b, c) {\n  a.J((c || \"Exception\") + b);\n}\nN.prototype.info = function(a) {\n  var b = this.r;\n  b && b.info(a, void 0);\n};\nN.prototype.Z = function(a) {\n  var b = this.r;\n  b && b.Z(a, void 0);\n};\nN.prototype.J = function(a) {\n  var b = this.r;\n  b && b.J(a, void 0);\n};\nfunction Vb(a, b) {\n  if (!b || b == Xb) {\n    return b;\n  }\n  try {\n    var c = xb(b);\n    if (c) {\n      for (var d = 0;d < c.length;d++) {\n        if (m(c[d])) {\n          var e = c[d];\n          if (!(2 > e.length)) {\n            var g = e[1];\n            if (m(g) && !(1 > g.length)) {\n              var h = g[0];\n              if (\"noop\" != h && \"stop\" != h) {\n                for (var k = 1;k < g.length;k++) {\n                  g[k] = \"\";\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return yb(c);\n  } catch (u) {\n    return a.debug(\"Exception parsing expected JS array - probably was not JS\"), b;\n  }\n}\n;function Yb(a, b) {\n  this.P = b ? xb : wb;\n}\nYb.prototype.parse = function(a) {\n  return this.P(a);\n};\nfunction O() {\n  0 != Zb && ($b[this[ga] || (this[ga] = ++ha)] = this);\n}\nvar Zb = 0, $b = {};\nO.prototype.mb = !1;\nO.prototype.Ja = function() {\n  if (!this.mb && (this.mb = !0, this.u(), 0 != Zb)) {\n    var a = this[ga] || (this[ga] = ++ha);\n    delete $b[a];\n  }\n};\nO.prototype.u = function() {\n  if (this.Pb) {\n    for (;this.Pb.length;) {\n      this.Pb.shift()();\n    }\n  }\n};\nvar ac = \"closure_listenable_\" + (1E6 * Math.random() | 0);\nfunction bc(a) {\n  try {\n    return!(!a || !a[ac]);\n  } catch (b) {\n    return!1;\n  }\n}\nvar cc = 0;\nfunction dc(a, b, c, d, e) {\n  this.fa = a;\n  this.Ua = null;\n  this.src = b;\n  this.type = c;\n  this.capture = !!d;\n  this.Oa = e;\n  this.key = ++cc;\n  this.na = this.Ia = !1;\n}\nfunction ec(a) {\n  a.na = !0;\n  a.fa = null;\n  a.Ua = null;\n  a.src = null;\n  a.Oa = null;\n}\n;function P(a) {\n  this.src = a;\n  this.s = {};\n  this.Ga = 0;\n}\nP.prototype.add = function(a, b, c, d, e) {\n  var g = this.s[a];\n  g || (g = this.s[a] = [], this.Ga++);\n  var h = fc(g, b, d, e);\n  -1 < h ? (a = g[h], c || (a.Ia = !1)) : (a = new dc(b, this.src, a, !!d, e), a.Ia = c, g.push(a));\n  return a;\n};\nP.prototype.remove = function(a, b, c, d) {\n  if (!(a in this.s)) {\n    return!1;\n  }\n  var e = this.s[a];\n  b = fc(e, b, c, d);\n  return-1 < b ? (ec(e[b]), B.splice.call(e, b, 1), 0 == e.length && (delete this.s[a], this.Ga--), !0) : !1;\n};\nfunction gc(a, b) {\n  var c = b.type;\n  if (!(c in a.s)) {\n    return!1;\n  }\n  var d = a.s[c], e = Xa(d, b), g;\n  (g = 0 <= e) && B.splice.call(d, e, 1);\n  g && (ec(b), 0 == a.s[c].length && (delete a.s[c], a.Ga--));\n  return g;\n}\nP.prototype.Xa = function(a) {\n  var b = 0, c;\n  for (c in this.s) {\n    if (!a || c == a) {\n      for (var d = this.s[c], e = 0;e < d.length;e++) {\n        ++b, ec(d[e]);\n      }\n      delete this.s[c];\n      this.Ga--;\n    }\n  }\n  return b;\n};\nP.prototype.ya = function(a, b, c, d) {\n  a = this.s[a];\n  var e = -1;\n  a && (e = fc(a, b, c, d));\n  return-1 < e ? a[e] : null;\n};\nfunction fc(a, b, c, d) {\n  for (var e = 0;e < a.length;++e) {\n    var g = a[e];\n    if (!g.na && g.fa == b && g.capture == !!c && g.Oa == d) {\n      return e;\n    }\n  }\n  return-1;\n}\n;var hc = !y || y && 9 <= Ma, ic = y && !A(\"9\");\n!z || A(\"528\");\nBa && A(\"1.9b\") || y && A(\"8\") || Aa && A(\"9.5\") || z && A(\"528\");\nBa && !A(\"8\") || y && A(\"9\");\nfunction Q(a, b) {\n  this.type = a;\n  this.currentTarget = this.target = b;\n}\nf = Q.prototype;\nf.u = function() {\n};\nf.Ja = function() {\n};\nf.ga = !1;\nf.defaultPrevented = !1;\nf.Yb = !0;\nf.preventDefault = function() {\n  this.defaultPrevented = !0;\n  this.Yb = !1;\n};\nfunction jc(a) {\n  jc[\" \"](a);\n  return a;\n}\njc[\" \"] = ca;\nfunction kc(a, b) {\n  Q.call(this, a ? a.type : \"\");\n  this.relatedTarget = this.currentTarget = this.target = null;\n  this.charCode = this.keyCode = this.button = this.screenY = this.screenX = this.clientY = this.clientX = this.offsetY = this.offsetX = 0;\n  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1;\n  this.Db = this.state = null;\n  if (a) {\n    var c = this.type = a.type;\n    this.target = a.target || a.srcElement;\n    this.currentTarget = b;\n    var d = a.relatedTarget;\n    if (d) {\n      if (Ba) {\n        var e;\n        a: {\n          try {\n            jc(d.nodeName);\n            e = !0;\n            break a;\n          } catch (g) {\n          }\n          e = !1;\n        }\n        e || (d = null);\n      }\n    } else {\n      \"mouseover\" == c ? d = a.fromElement : \"mouseout\" == c && (d = a.toElement);\n    }\n    this.relatedTarget = d;\n    this.offsetX = z || void 0 !== a.offsetX ? a.offsetX : a.layerX;\n    this.offsetY = z || void 0 !== a.offsetY ? a.offsetY : a.layerY;\n    this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX;\n    this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY;\n    this.screenX = a.screenX || 0;\n    this.screenY = a.screenY || 0;\n    this.button = a.button;\n    this.keyCode = a.keyCode || 0;\n    this.charCode = a.charCode || (\"keypress\" == c ? a.keyCode : 0);\n    this.ctrlKey = a.ctrlKey;\n    this.altKey = a.altKey;\n    this.shiftKey = a.shiftKey;\n    this.metaKey = a.metaKey;\n    this.state = a.state;\n    this.Db = a;\n    a.defaultPrevented && this.preventDefault();\n    delete this.ga;\n  }\n}\ns(kc, Q);\nkc.prototype.preventDefault = function() {\n  kc.pa.preventDefault.call(this);\n  var a = this.Db;\n  if (a.preventDefault) {\n    a.preventDefault();\n  } else {\n    if (a.returnValue = !1, ic) {\n      try {\n        if (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) {\n          a.keyCode = -1;\n        }\n      } catch (b) {\n      }\n    }\n  }\n};\nkc.prototype.u = function() {\n};\nvar lc = \"closure_lm_\" + (1E6 * Math.random() | 0), mc = {}, nc = 0;\nfunction oc(a, b, c, d, e) {\n  if (m(b)) {\n    for (var g = 0;g < b.length;g++) {\n      oc(a, b[g], c, d, e);\n    }\n    return null;\n  }\n  c = pc(c);\n  if (bc(a)) {\n    a = a.Ra(b, c, d, e);\n  } else {\n    if (!b) {\n      throw Error(\"Invalid event type\");\n    }\n    var g = !!d, h = qc(a);\n    h || (a[lc] = h = new P(a));\n    c = h.add(b, c, !1, d, e);\n    c.Ua || (d = rc(), c.Ua = d, d.src = a, d.fa = c, a.addEventListener ? a.addEventListener(b, d, g) : a.attachEvent(b in mc ? mc[b] : mc[b] = \"on\" + b, d), nc++);\n    a = c;\n  }\n  return a;\n}\nfunction rc() {\n  var a = sc, b = hc ? function(c) {\n    return a.call(b.src, b.fa, c);\n  } : function(c) {\n    c = a.call(b.src, b.fa, c);\n    if (!c) {\n      return c;\n    }\n  };\n  return b;\n}\nfunction tc(a, b, c, d, e) {\n  if (m(b)) {\n    for (var g = 0;g < b.length;g++) {\n      tc(a, b[g], c, d, e);\n    }\n  } else {\n    c = pc(c), bc(a) ? a.vb(b, c, d, e) : a && (a = qc(a)) && (b = a.ya(b, c, !!d, e)) && uc(b);\n  }\n}\nfunction uc(a) {\n  if (\"number\" == typeof a || !a || a.na) {\n    return!1;\n  }\n  var b = a.src;\n  if (bc(b)) {\n    return gc(b.W, a);\n  }\n  var c = a.type, d = a.Ua;\n  b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent && b.detachEvent(c in mc ? mc[c] : mc[c] = \"on\" + c, d);\n  nc--;\n  (c = qc(b)) ? (gc(c, a), 0 == c.Ga && (c.src = null, b[lc] = null)) : ec(a);\n  return!0;\n}\nfunction vc(a, b, c, d) {\n  var e = 1;\n  if (a = qc(a)) {\n    if (b = a.s[b]) {\n      for (b = bb(b), a = 0;a < b.length;a++) {\n        var g = b[a];\n        g && g.capture == c && !g.na && (e &= !1 !== wc(g, d));\n      }\n    }\n  }\n  return Boolean(e);\n}\nfunction wc(a, b) {\n  var c = a.fa, d = a.Oa || a.src;\n  a.Ia && uc(a);\n  return c.call(d, b);\n}\nfunction sc(a, b) {\n  if (a.na) {\n    return!0;\n  }\n  if (!hc) {\n    var c = b || ba(\"window.event\"), d = new kc(c, this), e = !0;\n    if (!(0 > c.keyCode || void 0 != c.returnValue)) {\n      a: {\n        var g = !1;\n        if (0 == c.keyCode) {\n          try {\n            c.keyCode = -1;\n            break a;\n          } catch (h) {\n            g = !0;\n          }\n        }\n        if (g || void 0 == c.returnValue) {\n          c.returnValue = !0;\n        }\n      }\n      c = [];\n      for (g = d.currentTarget;g;g = g.parentNode) {\n        c.push(g);\n      }\n      for (var g = a.type, k = c.length - 1;!d.ga && 0 <= k;k--) {\n        d.currentTarget = c[k], e &= vc(c[k], g, !0, d);\n      }\n      for (k = 0;!d.ga && k < c.length;k++) {\n        d.currentTarget = c[k], e &= vc(c[k], g, !1, d);\n      }\n    }\n    return e;\n  }\n  return wc(a, new kc(b, this));\n}\nfunction qc(a) {\n  a = a[lc];\n  return a instanceof P ? a : null;\n}\nvar xc = \"__closure_events_fn_\" + (1E9 * Math.random() >>> 0);\nfunction pc(a) {\n  return fa(a) ? a : a[xc] || (a[xc] = function(b) {\n    return a.handleEvent(b);\n  });\n}\n;function R() {\n  O.call(this);\n  this.W = new P(this);\n  this.fc = this;\n}\ns(R, O);\nR.prototype[ac] = !0;\nf = R.prototype;\nf.tb = null;\nf.addEventListener = function(a, b, c, d) {\n  oc(this, a, b, c, d);\n};\nf.removeEventListener = function(a, b, c, d) {\n  tc(this, a, b, c, d);\n};\nf.dispatchEvent = function(a) {\n  var b, c = this.tb;\n  if (c) {\n    for (b = [];c;c = c.tb) {\n      b.push(c);\n    }\n  }\n  var c = this.fc, d = a.type || a;\n  if (n(a)) {\n    a = new Q(a, c);\n  } else {\n    if (a instanceof Q) {\n      a.target = a.target || c;\n    } else {\n      var e = a;\n      a = new Q(d, c);\n      Wa(a, e);\n    }\n  }\n  var e = !0, g;\n  if (b) {\n    for (var h = b.length - 1;!a.ga && 0 <= h;h--) {\n      g = a.currentTarget = b[h], e = yc(g, d, !0, a) && e;\n    }\n  }\n  a.ga || (g = a.currentTarget = c, e = yc(g, d, !0, a) && e, a.ga || (e = yc(g, d, !1, a) && e));\n  if (b) {\n    for (h = 0;!a.ga && h < b.length;h++) {\n      g = a.currentTarget = b[h], e = yc(g, d, !1, a) && e;\n    }\n  }\n  return e;\n};\nf.u = function() {\n  R.pa.u.call(this);\n  this.W && this.W.Xa(void 0);\n  this.tb = null;\n};\nf.Ra = function(a, b, c, d) {\n  return this.W.add(String(a), b, !1, c, d);\n};\nf.vb = function(a, b, c, d) {\n  return this.W.remove(String(a), b, c, d);\n};\nfunction yc(a, b, c, d) {\n  b = a.W.s[String(b)];\n  if (!b) {\n    return!0;\n  }\n  b = bb(b);\n  for (var e = !0, g = 0;g < b.length;++g) {\n    var h = b[g];\n    if (h && !h.na && h.capture == c) {\n      var k = h.fa, u = h.Oa || h.src;\n      h.Ia && gc(a.W, h);\n      e = !1 !== k.call(u, d) && e;\n    }\n  }\n  return e && !1 != d.Yb;\n}\nf.ya = function(a, b, c, d) {\n  return this.W.ya(String(a), b, c, d);\n};\nfunction zc(a, b) {\n  R.call(this);\n  this.ea = a || 1;\n  this.ra = b || l;\n  this.ib = p(this.Gc, this);\n  this.sb = q();\n}\ns(zc, R);\nf = zc.prototype;\nf.enabled = !1;\nf.l = null;\nf.setInterval = function(a) {\n  this.ea = a;\n  this.l && this.enabled ? (this.stop(), this.start()) : this.l && this.stop();\n};\nf.Gc = function() {\n  if (this.enabled) {\n    var a = q() - this.sb;\n    0 < a && a < 0.8 * this.ea ? this.l = this.ra.setTimeout(this.ib, this.ea - a) : (this.l && (this.ra.clearTimeout(this.l), this.l = null), this.dispatchEvent(Ac), this.enabled && (this.l = this.ra.setTimeout(this.ib, this.ea), this.sb = q()));\n  }\n};\nf.start = function() {\n  this.enabled = !0;\n  this.l || (this.l = this.ra.setTimeout(this.ib, this.ea), this.sb = q());\n};\nf.stop = function() {\n  this.enabled = !1;\n  this.l && (this.ra.clearTimeout(this.l), this.l = null);\n};\nf.u = function() {\n  zc.pa.u.call(this);\n  this.stop();\n  delete this.ra;\n};\nvar Ac = \"tick\";\nfunction Bc(a, b, c) {\n  if (fa(a)) {\n    c && (a = p(a, c));\n  } else {\n    if (a && \"function\" == typeof a.handleEvent) {\n      a = p(a.handleEvent, a);\n    } else {\n      throw Error(\"Invalid listener argument\");\n    }\n  }\n  return 2147483647 < b ? -1 : l.setTimeout(a, b || 0);\n}\n;function Cc() {\n}\nCc.prototype.Ab = null;\nfunction Dc(a) {\n  var b;\n  (b = a.Ab) || (b = {}, Ec(a) && (b[0] = !0, b[1] = !0), b = a.Ab = b);\n  return b;\n}\n;var Fc;\nfunction Gc() {\n}\ns(Gc, Cc);\nfunction Hc(a) {\n  return(a = Ec(a)) ? new ActiveXObject(a) : new XMLHttpRequest;\n}\nfunction Ec(a) {\n  if (!a.Kb && \"undefined\" == typeof XMLHttpRequest && \"undefined\" != typeof ActiveXObject) {\n    for (var b = [\"MSXML2.XMLHTTP.6.0\", \"MSXML2.XMLHTTP.3.0\", \"MSXML2.XMLHTTP\", \"Microsoft.XMLHTTP\"], c = 0;c < b.length;c++) {\n      var d = b[c];\n      try {\n        return new ActiveXObject(d), a.Kb = d;\n      } catch (e) {\n      }\n    }\n    throw Error(\"Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed\");\n  }\n  return a.Kb;\n}\nFc = new Gc;\nfunction Ic(a) {\n  R.call(this);\n  this.headers = new cb;\n  this.gb = a || null;\n  this.T = !1;\n  this.fb = this.f = null;\n  this.Mb = this.Qa = \"\";\n  this.ka = 0;\n  this.q = \"\";\n  this.da = this.qb = this.Pa = this.nb = !1;\n  this.Fa = 0;\n  this.bb = null;\n  this.Xb = Jc;\n  this.cb = this.dc = !1;\n}\ns(Ic, R);\nvar Jc = \"\";\nIc.prototype.r = Tb(\"goog.net.XhrIo\");\nvar Kc = /^https?$/i, Lc = [\"POST\", \"PUT\"];\nf = Ic.prototype;\nf.send = function(a, b, c, d) {\n  if (this.f) {\n    throw Error(\"[goog.net.XhrIo] Object is active with another request=\" + this.Qa + \"; newUri=\" + a);\n  }\n  b = b ? b.toUpperCase() : \"GET\";\n  this.Qa = a;\n  this.q = \"\";\n  this.ka = 0;\n  this.Mb = b;\n  this.nb = !1;\n  this.T = !0;\n  this.f = this.gb ? Hc(this.gb) : Hc(Fc);\n  this.fb = this.gb ? Dc(this.gb) : Dc(Fc);\n  this.f.onreadystatechange = p(this.Qb, this);\n  try {\n    M(this.r, S(this, \"Opening Xhr\")), this.qb = !0, this.f.open(b, a, !0), this.qb = !1;\n  } catch (e) {\n    M(this.r, S(this, \"Error opening Xhr: \" + e.message));\n    Mc(this, e);\n    return;\n  }\n  a = c || \"\";\n  var g = this.headers.n();\n  d && D(d, function(a, b) {\n    g.set(b, a);\n  });\n  d = Za(g.ca());\n  c = l.FormData && a instanceof l.FormData;\n  !(0 <= Xa(Lc, b)) || d || c || g.set(\"Content-Type\", \"application/x-www-form-urlencoded;charset=utf-8\");\n  D(g, function(a, b) {\n    this.f.setRequestHeader(b, a);\n  }, this);\n  this.Xb && (this.f.responseType = this.Xb);\n  \"withCredentials\" in this.f && (this.f.withCredentials = this.dc);\n  try {\n    Nc(this), 0 < this.Fa && (this.cb = Oc(this.f), M(this.r, S(this, \"Will abort after \" + this.Fa + \"ms if incomplete, xhr2 \" + this.cb)), this.cb ? (this.f.timeout = this.Fa, this.f.ontimeout = p(this.qa, this)) : this.bb = Bc(this.qa, this.Fa, this)), M(this.r, S(this, \"Sending request\")), this.Pa = !0, this.f.send(a), this.Pa = !1;\n  } catch (h) {\n    M(this.r, S(this, \"Send error: \" + h.message)), Mc(this, h);\n  }\n};\nfunction Oc(a) {\n  return y && A(9) && \"number\" == typeof a.timeout && void 0 !== a.ontimeout;\n}\nfunction $a(a) {\n  return \"content-type\" == a.toLowerCase();\n}\nf.qa = function() {\n  \"undefined\" != typeof aa && this.f && (this.q = \"Timed out after \" + this.Fa + \"ms, aborting\", this.ka = 8, M(this.r, S(this, this.q)), this.dispatchEvent(\"timeout\"), this.abort(8));\n};\nfunction Mc(a, b) {\n  a.T = !1;\n  a.f && (a.da = !0, a.f.abort(), a.da = !1);\n  a.q = b;\n  a.ka = 5;\n  Pc(a);\n  Qc(a);\n}\nfunction Pc(a) {\n  a.nb || (a.nb = !0, a.dispatchEvent(\"complete\"), a.dispatchEvent(\"error\"));\n}\nf.abort = function(a) {\n  this.f && this.T && (M(this.r, S(this, \"Aborting\")), this.T = !1, this.da = !0, this.f.abort(), this.da = !1, this.ka = a || 7, this.dispatchEvent(\"complete\"), this.dispatchEvent(\"abort\"), Qc(this));\n};\nf.u = function() {\n  this.f && (this.T && (this.T = !1, this.da = !0, this.f.abort(), this.da = !1), Qc(this, !0));\n  Ic.pa.u.call(this);\n};\nf.Qb = function() {\n  this.mb || (this.qb || this.Pa || this.da ? Rc(this) : this.uc());\n};\nf.uc = function() {\n  Rc(this);\n};\nfunction Rc(a) {\n  if (a.T && \"undefined\" != typeof aa) {\n    if (a.fb[1] && 4 == T(a) && 2 == Sc(a)) {\n      M(a.r, S(a, \"Local request error detected and ignored\"));\n    } else {\n      if (a.Pa && 4 == T(a)) {\n        Bc(a.Qb, 0, a);\n      } else {\n        if (a.dispatchEvent(\"readystatechange\"), 4 == T(a)) {\n          M(a.r, S(a, \"Request complete\"));\n          a.T = !1;\n          try {\n            var b = Sc(a), c, d;\n            a: {\n              switch(b) {\n                case 200:\n                ;\n                case 201:\n                ;\n                case 202:\n                ;\n                case 204:\n                ;\n                case 206:\n                ;\n                case 304:\n                ;\n                case 1223:\n                  d = !0;\n                  break a;\n                default:\n                  d = !1;\n              }\n            }\n            if (!(c = d)) {\n              var e;\n              if (e = 0 === b) {\n                var g = Ra(String(a.Qa))[1] || null;\n                if (!g && self.location) {\n                  var h = self.location.protocol, g = h.substr(0, h.length - 1)\n                }\n                e = !Kc.test(g ? g.toLowerCase() : \"\");\n              }\n              c = e;\n            }\n            if (c) {\n              a.dispatchEvent(\"complete\"), a.dispatchEvent(\"success\");\n            } else {\n              a.ka = 6;\n              var k;\n              try {\n                k = 2 < T(a) ? a.f.statusText : \"\";\n              } catch (u) {\n                M(a.r, \"Can not get status: \" + u.message), k = \"\";\n              }\n              a.q = k + \" [\" + Sc(a) + \"]\";\n              Pc(a);\n            }\n          } finally {\n            Qc(a);\n          }\n        }\n      }\n    }\n  }\n}\nfunction Qc(a, b) {\n  if (a.f) {\n    Nc(a);\n    var c = a.f, d = a.fb[0] ? ca : null;\n    a.f = null;\n    a.fb = null;\n    b || a.dispatchEvent(\"ready\");\n    try {\n      c.onreadystatechange = d;\n    } catch (e) {\n      (c = a.r) && c.J(\"Problem encountered resetting onreadystatechange: \" + e.message, void 0);\n    }\n  }\n}\nfunction Nc(a) {\n  a.f && a.cb && (a.f.ontimeout = null);\n  \"number\" == typeof a.bb && (l.clearTimeout(a.bb), a.bb = null);\n}\nf.isActive = function() {\n  return!!this.f;\n};\nfunction T(a) {\n  return a.f ? a.f.readyState : 0;\n}\nfunction Sc(a) {\n  try {\n    return 2 < T(a) ? a.f.status : -1;\n  } catch (b) {\n    return(a = a.r) && a.Z(\"Can not get status: \" + b.message, void 0), -1;\n  }\n}\nfunction Tc(a) {\n  try {\n    return a.f ? a.f.responseText : \"\";\n  } catch (b) {\n    return M(a.r, \"Can not get responseText: \" + b.message), \"\";\n  }\n}\nf.Ib = function() {\n  return n(this.q) ? this.q : String(this.q);\n};\nfunction S(a, b) {\n  return b + \" [\" + a.Mb + \" \" + a.Qa + \" \" + Sc(a) + \"]\";\n}\n;function Uc() {\n  this.Wb = q();\n}\nnew Uc;\nUc.prototype.set = function(a) {\n  this.Wb = a;\n};\nUc.prototype.reset = function() {\n  this.set(q());\n};\nUc.prototype.get = function() {\n  return this.Wb;\n};\nfunction Vc(a) {\n  O.call(this);\n  this.e = a;\n  this.j = {};\n}\ns(Vc, O);\nvar Wc = [];\nf = Vc.prototype;\nf.Ra = function(a, b, c, d) {\n  m(b) || (Wc[0] = b, b = Wc);\n  for (var e = 0;e < b.length;e++) {\n    var g = oc(a, b[e], c || this.handleEvent, d || !1, this.e || this);\n    if (!g) {\n      break;\n    }\n    this.j[g.key] = g;\n  }\n  return this;\n};\nf.vb = function(a, b, c, d, e) {\n  if (m(b)) {\n    for (var g = 0;g < b.length;g++) {\n      this.vb(a, b[g], c, d, e);\n    }\n  } else {\n    c = c || this.handleEvent, e = e || this.e || this, c = pc(c), d = !!d, b = bc(a) ? a.ya(b, c, d, e) : a ? (a = qc(a)) ? a.ya(b, c, d, e) : null : null, b && (uc(b), delete this.j[b.key]);\n  }\n  return this;\n};\nf.Xa = function() {\n  var a = this.j, b = uc, c;\n  for (c in a) {\n    b.call(void 0, a[c], c, a);\n  }\n  this.j = {};\n};\nf.u = function() {\n  Vc.pa.u.call(this);\n  this.Xa();\n};\nf.handleEvent = function() {\n  throw Error(\"EventHandler.handleEvent not implemented\");\n};\nfunction Xc(a, b, c) {\n  O.call(this);\n  this.pc = a;\n  this.ea = b;\n  this.e = c;\n  this.jc = p(this.vc, this);\n}\ns(Xc, O);\nf = Xc.prototype;\nf.Za = !1;\nf.Vb = 0;\nf.l = null;\nf.stop = function() {\n  this.l && (l.clearTimeout(this.l), this.l = null, this.Za = !1);\n};\nf.u = function() {\n  Xc.pa.u.call(this);\n  this.stop();\n};\nf.vc = function() {\n  this.l = null;\n  this.Za && !this.Vb && (this.Za = !1, Yc(this));\n};\nfunction Yc(a) {\n  a.l = Bc(a.jc, a.ea);\n  a.pc.call(a.e);\n}\n;function U(a, b, c, d, e) {\n  this.b = a;\n  this.a = b;\n  this.Y = c;\n  this.B = d;\n  this.Ea = e || 1;\n  this.qa = Zc;\n  this.ob = new Vc(this);\n  this.Ta = new zc;\n  this.Ta.setInterval($c);\n}\nf = U.prototype;\nf.v = null;\nf.F = !1;\nf.ua = null;\nf.xb = null;\nf.Da = null;\nf.sa = null;\nf.U = null;\nf.w = null;\nf.X = null;\nf.k = null;\nf.Ha = 0;\nf.K = null;\nf.ta = null;\nf.q = null;\nf.g = -1;\nf.Zb = !0;\nf.$ = !1;\nf.ma = 0;\nf.Va = null;\nvar Zc = 45E3, $c = 250;\nfunction ad(a, b) {\n  switch(a) {\n    case 0:\n      return \"Non-200 return code (\" + b + \")\";\n    case 1:\n      return \"XMLHTTP failure (no data)\";\n    case 2:\n      return \"HttpConnection timeout\";\n    default:\n      return \"Unknown error\";\n  }\n}\nvar bd = {}, dd = {};\nfunction ed() {\n  return!y || y && 10 <= Ma;\n}\nf = U.prototype;\nf.S = function(a) {\n  this.v = a;\n};\nf.setTimeout = function(a) {\n  this.qa = a;\n};\nf.bc = function(a) {\n  this.ma = a;\n};\nfunction fd(a, b, c) {\n  a.sa = 1;\n  a.U = H(b.n());\n  a.X = c;\n  a.Cb = !0;\n  gd(a, null);\n}\nfunction hd(a, b, c, d, e) {\n  a.sa = 1;\n  a.U = H(b.n());\n  a.X = null;\n  a.Cb = c;\n  e && (a.Zb = !1);\n  gd(a, d);\n}\nfunction gd(a, b) {\n  a.Da = q();\n  id(a);\n  a.w = a.U.n();\n  rb(a.w, \"t\", a.Ea);\n  a.Ha = 0;\n  a.k = a.b.lb(a.b.$a() ? b : null);\n  0 < a.ma && (a.Va = new Xc(p(a.ec, a, a.k), a.ma));\n  a.ob.Ra(a.k, \"readystatechange\", a.Bc);\n  var c;\n  if (a.v) {\n    c = a.v;\n    var d = {}, e;\n    for (e in c) {\n      d[e] = c[e];\n    }\n    c = d;\n  } else {\n    c = {};\n  }\n  a.X ? (a.ta = \"POST\", c[\"Content-Type\"] = \"application/x-www-form-urlencoded\", a.k.send(a.w, a.ta, a.X, c)) : (a.ta = \"GET\", a.Zb && !z && (c.Connection = \"close\"), a.k.send(a.w, a.ta, null, c));\n  a.b.H(jd);\n  if (d = a.X) {\n    for (c = \"\", d = d.split(\"&\"), e = 0;e < d.length;e++) {\n      var g = d[e].split(\"=\");\n      if (1 < g.length) {\n        var h = g[0], g = g[1], k = h.split(\"_\");\n        c = 2 <= k.length && \"type\" == k[1] ? c + (h + \"=\" + g + \"&\") : c + (h + \"=redacted&\");\n      }\n    }\n  } else {\n    c = null;\n  }\n  a.a.info(\"XMLHTTP REQ (\" + a.B + \") [attempt \" + a.Ea + \"]: \" + a.ta + \"\\n\" + a.w + \"\\n\" + c);\n}\nf.Bc = function(a) {\n  a = a.target;\n  var b = this.Va;\n  b && 3 == T(a) ? (this.a.debug(\"Throttling readystatechange.\"), b.l || b.Vb ? b.Za = !0 : Yc(b)) : this.ec(a);\n};\nf.ec = function(a) {\n  try {\n    if (a == this.k) {\n      a: {\n        var b = T(this.k), c = this.k.ka, d = Sc(this.k);\n        if (!ed() || z && !A(\"420+\")) {\n          if (4 > b) {\n            break a;\n          }\n        } else {\n          if (3 > b || 3 == b && !Aa && !Tc(this.k)) {\n            break a;\n          }\n        }\n        this.$ || 4 != b || 7 == c || (8 == c || 0 >= d ? this.b.H(kd) : this.b.H(ld));\n        md(this);\n        var e = Sc(this.k);\n        this.g = e;\n        var g = Tc(this.k);\n        g || this.a.debug(\"No response text for uri \" + this.w + \" status \" + e);\n        this.F = 200 == e;\n        this.a.info(\"XMLHTTP RESP (\" + this.B + \") [ attempt \" + this.Ea + \"]: \" + this.ta + \"\\n\" + this.w + \"\\n\" + b + \" \" + e);\n        this.F ? (4 == b && V(this), this.Cb ? (nd(this, b, g), Aa && this.F && 3 == b && (this.ob.Ra(this.Ta, Ac, this.Ac), this.Ta.start())) : (Ub(this.a, this.B, g, null), od(this, g)), this.F && !this.$ && (4 == b ? this.b.la(this) : (this.F = !1, id(this)))) : (400 == e && 0 < g.indexOf(\"Unknown SID\") ? (this.q = 3, W(), this.a.Z(\"XMLHTTP Unknown SID (\" + this.B + \")\")) : (this.q = 0, W(), this.a.Z(\"XMLHTTP Bad status \" + e + \" (\" + this.B + \")\")), V(this), pd(this));\n      }\n    } else {\n      this.a.Z(\"Called back with an unexpected xmlhttp\");\n    }\n  } catch (h) {\n    this.a.debug(\"Failed call to OnXmlHttpReadyStateChanged_\"), this.k && Tc(this.k) ? Wb(this.a, h, \"ResponseText: \" + Tc(this.k)) : Wb(this.a, h, \"No response text\");\n  } finally {\n  }\n};\nfunction nd(a, b, c) {\n  for (var d = !0;!a.$ && a.Ha < c.length;) {\n    var e = qd(a, c);\n    if (e == dd) {\n      4 == b && (a.q = 4, W(), d = !1);\n      Ub(a.a, a.B, null, \"[Incomplete Response]\");\n      break;\n    } else {\n      if (e == bd) {\n        a.q = 4;\n        W();\n        Ub(a.a, a.B, c, \"[Invalid Chunk]\");\n        d = !1;\n        break;\n      } else {\n        Ub(a.a, a.B, e, null), od(a, e);\n      }\n    }\n  }\n  4 == b && 0 == c.length && (a.q = 1, W(), d = !1);\n  a.F = a.F && d;\n  d || (Ub(a.a, a.B, c, \"[Invalid Chunked Response]\"), V(a), pd(a));\n}\nf.Ac = function() {\n  var a = T(this.k), b = Tc(this.k);\n  this.Ha < b.length && (md(this), nd(this, a, b), this.F && 4 != a && id(this));\n};\nfunction qd(a, b) {\n  var c = a.Ha, d = b.indexOf(\"\\n\", c);\n  if (-1 == d) {\n    return dd;\n  }\n  c = Number(b.substring(c, d));\n  if (isNaN(c)) {\n    return bd;\n  }\n  d += 1;\n  if (d + c > b.length) {\n    return dd;\n  }\n  var e = b.substr(d, c);\n  a.Ha = d + c;\n  return e;\n}\nfunction rd(a, b) {\n  a.Da = q();\n  id(a);\n  var c = b ? window.location.hostname : \"\";\n  a.w = a.U.n();\n  G(a.w, \"DOMAIN\", c);\n  G(a.w, \"t\", a.Ea);\n  try {\n    a.K = new ActiveXObject(\"htmlfile\");\n  } catch (d) {\n    a.a.J(\"ActiveX blocked\");\n    V(a);\n    a.q = 7;\n    W();\n    pd(a);\n    return;\n  }\n  var e = \"<html><body>\";\n  b && (e += '<script>document.domain=\"' + c + '\"\\x3c/script>');\n  e += \"</body></html>\";\n  a.K.open();\n  a.K.write(e);\n  a.K.close();\n  a.K.parentWindow.m = p(a.yc, a);\n  a.K.parentWindow.d = p(a.Ub, a, !0);\n  a.K.parentWindow.rpcClose = p(a.Ub, a, !1);\n  c = a.K.createElement(\"div\");\n  a.K.parentWindow.document.body.appendChild(c);\n  c.innerHTML = '<iframe src=\"' + a.w + '\"></iframe>';\n  a.a.info(\"TRIDENT REQ (\" + a.B + \") [ attempt \" + a.Ea + \"]: GET\\n\" + a.w);\n  a.b.H(jd);\n}\nf.yc = function(a) {\n  Y(p(this.xc, this, a), 0);\n};\nf.xc = function(a) {\n  if (!this.$) {\n    var b = this.a;\n    b.info(\"TRIDENT TEXT (\" + this.B + \"): \" + Vb(b, a));\n    md(this);\n    od(this, a);\n    id(this);\n  }\n};\nf.Ub = function(a) {\n  Y(p(this.wc, this, a), 0);\n};\nf.wc = function(a) {\n  this.$ || (this.a.info(\"TRIDENT TEXT (\" + this.B + \"): \" + a ? \"success\" : \"failure\"), V(this), this.F = a, this.b.la(this), this.b.H(sd));\n};\nf.nc = function() {\n  md(this);\n  this.b.la(this);\n};\nf.cancel = function() {\n  this.$ = !0;\n  V(this);\n};\nfunction id(a) {\n  a.xb = q() + a.qa;\n  td(a, a.qa);\n}\nfunction td(a, b) {\n  if (null != a.ua) {\n    throw Error(\"WatchDog timer not null\");\n  }\n  a.ua = Y(p(a.zc, a), b);\n}\nfunction md(a) {\n  a.ua && (l.clearTimeout(a.ua), a.ua = null);\n}\nf.zc = function() {\n  this.ua = null;\n  var a = q();\n  0 <= a - this.xb ? (this.F && this.a.J(\"Received watchdog timeout even though request loaded successfully\"), this.a.info(\"TIMEOUT: \" + this.w), 2 != this.sa && this.b.H(kd), V(this), this.q = 2, W(), pd(this)) : (this.a.Z(\"WatchDog timer called too early\"), td(this, this.xb - a));\n};\nfunction pd(a) {\n  a.b.Lb() || a.$ || a.b.la(a);\n}\nfunction V(a) {\n  md(a);\n  var b = a.Va;\n  b && \"function\" == typeof b.Ja && b.Ja();\n  a.Va = null;\n  a.Ta.stop();\n  a.ob.Xa();\n  a.k && (b = a.k, a.k = null, b.abort(), b.Ja());\n  a.K && (a.K = null);\n}\nf.Ib = function() {\n  return this.q;\n};\nfunction od(a, b) {\n  try {\n    a.b.Rb(a, b), a.b.H(sd);\n  } catch (c) {\n    Wb(a.a, c, \"Error in httprequest callback\");\n  }\n}\n;function ud(a, b, c, d, e) {\n  (new N).debug(\"TestLoadImageWithRetries: \" + e);\n  if (0 == d) {\n    c(!1);\n  } else {\n    var g = e || 0;\n    d--;\n    vd(a, b, function(e) {\n      e ? c(!0) : l.setTimeout(function() {\n        ud(a, b, c, d, g);\n      }, g);\n    });\n  }\n}\nfunction vd(a, b, c) {\n  function d(a, b) {\n    return function() {\n      try {\n        e.debug(\"TestLoadImage: \" + b), g.onload = null, g.onerror = null, g.onabort = null, g.ontimeout = null, l.clearTimeout(h), c(a);\n      } catch (d) {\n        Wb(e, d);\n      }\n    };\n  }\n  var e = new N;\n  e.debug(\"TestLoadImage: loading \" + a);\n  var g = new Image, h = null;\n  g.onload = d(!0, \"loaded\");\n  g.onerror = d(!1, \"error\");\n  g.onabort = d(!1, \"abort\");\n  g.ontimeout = d(!1, \"timeout\");\n  h = l.setTimeout(function() {\n    if (g.ontimeout) {\n      g.ontimeout();\n    }\n  }, b);\n  g.src = a;\n}\n;function wd(a, b) {\n  this.b = a;\n  this.a = b;\n  this.P = new Yb(0, !0);\n}\nf = wd.prototype;\nf.v = null;\nf.A = null;\nf.Wa = !1;\nf.cc = null;\nf.La = null;\nf.rb = null;\nf.I = null;\nf.c = null;\nf.g = -1;\nf.L = null;\nf.va = null;\nf.S = function(a) {\n  this.v = a;\n};\nf.ac = function(a) {\n  this.P = a;\n};\nf.kb = function(a) {\n  this.I = a;\n  a = xd(this.b, this.I);\n  W();\n  this.cc = q();\n  var b = this.b.Gb;\n  null != b ? (this.L = this.b.correctHostPrefix(b[0]), (this.va = b[1]) ? (this.c = 1, yd(this)) : (this.c = 2, zd(this))) : (rb(a, \"MODE\", \"init\"), this.A = new U(this, this.a, void 0, void 0, void 0), this.A.S(this.v), hd(this.A, a, !1, null, !0), this.c = 0);\n};\nfunction yd(a) {\n  var b = Ad(a.b, a.va, \"/mail/images/cleardot.gif\");\n  H(b);\n  ud(b.toString(), 5E3, p(a.kc, a), 3, 2E3);\n  a.H(jd);\n}\nf.kc = function(a) {\n  if (a) {\n    this.c = 2, zd(this);\n  } else {\n    W();\n    var b = this.b;\n    b.a.debug(\"Test Connection Blocked\");\n    b.g = b.V.g;\n    Z(b, 9);\n  }\n  a && this.H(ld);\n};\nfunction zd(a) {\n  a.a.debug(\"TestConnection: starting stage 2\");\n  var b = a.b.Dc;\n  if (null != b) {\n    a.a.debug(\"TestConnection: skipping stage 2, precomputed result is \" + b ? \"Buffered\" : \"Unbuffered\"), W(), b ? (W(), Bd(a.b, a, !1)) : (W(), Bd(a.b, a, !0));\n  } else {\n    if (a.A = new U(a, a.a, void 0, void 0, void 0), a.A.S(a.v), b = Cd(a.b, a.L, a.I), W(), ed()) {\n      rb(b, \"TYPE\", \"xmlhttp\"), hd(a.A, b, !1, a.L, !1);\n    } else {\n      rb(b, \"TYPE\", \"html\");\n      var c = a.A;\n      a = Boolean(a.L);\n      c.sa = 3;\n      c.U = H(b.n());\n      rd(c, a);\n    }\n  }\n}\nf.lb = function(a) {\n  return this.b.lb(a);\n};\nf.abort = function() {\n  this.A && (this.A.cancel(), this.A = null);\n  this.g = -1;\n};\nf.Lb = function() {\n  return!1;\n};\nf.Rb = function(a, b) {\n  this.g = a.g;\n  if (0 == this.c) {\n    if (this.a.debug(\"TestConnection: Got data for stage 1\"), b) {\n      try {\n        var c = this.P.parse(b);\n      } catch (d) {\n        Wb(this.a, d);\n        Dd(this.b, this);\n        return;\n      }\n      this.L = this.b.correctHostPrefix(c[0]);\n      this.va = c[1];\n    } else {\n      this.a.debug(\"TestConnection: Null responseText\"), Dd(this.b, this);\n    }\n  } else {\n    if (2 == this.c) {\n      if (this.Wa) {\n        W(), this.rb = q();\n      } else {\n        if (\"11111\" == b) {\n          if (W(), this.Wa = !0, this.La = q(), c = this.La - this.cc, ed() || 500 > c) {\n            this.g = 200, this.A.cancel(), this.a.debug(\"Test connection succeeded; using streaming connection\"), W(), Bd(this.b, this, !0);\n          }\n        } else {\n          W(), this.La = this.rb = q(), this.Wa = !1;\n        }\n      }\n    }\n  }\n};\nf.la = function() {\n  this.g = this.A.g;\n  if (!this.A.F) {\n    this.a.debug(\"TestConnection: request failed, in state \" + this.c), 0 == this.c ? W() : 2 == this.c && W(), Dd(this.b, this);\n  } else {\n    if (0 == this.c) {\n      this.a.debug(\"TestConnection: request complete for initial check\"), this.va ? (this.c = 1, yd(this)) : (this.c = 2, zd(this));\n    } else {\n      if (2 == this.c) {\n        this.a.debug(\"TestConnection: request complete for stage 2\");\n        var a = !1;\n        (a = ed() ? this.Wa : 200 > this.rb - this.La ? !1 : !0) ? (this.a.debug(\"Test connection succeeded; using streaming connection\"), W(), Bd(this.b, this, !0)) : (this.a.debug(\"Test connection failed; not using streaming\"), W(), Bd(this.b, this, !1));\n      }\n    }\n  }\n};\nf.$a = function() {\n  return this.b.$a();\n};\nf.isActive = function() {\n  return this.b.isActive();\n};\nf.H = function(a) {\n  this.b.H(a);\n};\nfunction Ed(a, b, c) {\n  this.Bb = a || null;\n  this.c = Fd;\n  this.t = [];\n  this.Q = [];\n  this.a = new N;\n  this.P = new Yb(0, !0);\n  this.Gb = b || null;\n  this.Dc = null != c ? c : null;\n}\nfunction Gd(a, b) {\n  this.Ob = a;\n  this.map = b;\n}\nf = Ed.prototype;\nf.v = null;\nf.xa = null;\nf.p = null;\nf.i = null;\nf.I = null;\nf.Ma = null;\nf.zb = null;\nf.L = null;\nf.hc = !0;\nf.Ba = 0;\nf.sc = 0;\nf.Ka = !1;\nf.e = null;\nf.G = null;\nf.M = null;\nf.aa = null;\nf.V = null;\nf.wb = null;\nf.gc = !0;\nf.za = -1;\nf.Nb = -1;\nf.g = -1;\nf.ba = 0;\nf.ha = 0;\nf.ic = 5E3;\nf.Cc = 1E4;\nf.pb = 2;\nf.Hb = 2E4;\nf.ma = 0;\nf.ab = !1;\nf.ia = 8;\nvar Fd = 1, Hd = new R;\nfunction Id(a) {\n  Q.call(this, \"statevent\", a);\n}\ns(Id, Q);\nfunction Jd(a, b) {\n  Q.call(this, \"timingevent\", a);\n  this.size = b;\n}\ns(Jd, Q);\nvar jd = 1, ld = 2, kd = 3, sd = 4;\nfunction Kd(a) {\n  Q.call(this, \"serverreachability\", a);\n}\ns(Kd, Q);\nvar Xb = \"y2f%\";\nf = Ed.prototype;\nf.kb = function(a, b, c, d, e) {\n  this.a.debug(\"connect()\");\n  W();\n  this.I = b;\n  this.xa = c || {};\n  d && void 0 !== e && (this.xa.OSID = d, this.xa.OAID = e);\n  this.a.debug(\"connectTest_()\");\n  Ld(this) && (this.V = new wd(this, this.a), this.V.S(this.v), this.V.ac(this.P), this.V.kb(a));\n};\nf.disconnect = function() {\n  this.a.debug(\"disconnect()\");\n  Md(this);\n  if (3 == this.c) {\n    var a = this.Ba++, b = this.Ma.n();\n    G(b, \"SID\", this.Y);\n    G(b, \"RID\", a);\n    G(b, \"TYPE\", \"terminate\");\n    Nd(this, b);\n    a = new U(this, this.a, this.Y, a, void 0);\n    a.sa = 2;\n    a.U = H(b.n());\n    b = new Image;\n    b.src = a.U;\n    b.onload = b.onerror = p(a.nc, a);\n    a.Da = q();\n    id(a);\n  }\n  Od(this);\n};\nfunction Md(a) {\n  a.V && (a.V.abort(), a.V = null);\n  a.i && (a.i.cancel(), a.i = null);\n  a.M && (l.clearTimeout(a.M), a.M = null);\n  Pd(a);\n  a.p && (a.p.cancel(), a.p = null);\n  a.G && (l.clearTimeout(a.G), a.G = null);\n}\nf.S = function(a) {\n  this.v = a;\n};\nf.bc = function(a) {\n  this.ma = a;\n};\nf.Lb = function() {\n  return 0 == this.c;\n};\nf.ac = function(a) {\n  this.P = a;\n};\nfunction Qd(a) {\n  a.p || a.G || (a.G = Y(p(a.Tb, a), 0), a.ba = 0);\n}\nf.Tb = function(a) {\n  this.G = null;\n  this.a.debug(\"startForwardChannel_\");\n  if (Ld(this)) {\n    if (this.c == Fd) {\n      if (a) {\n        this.a.J(\"Not supposed to retry the open\");\n      } else {\n        this.a.debug(\"open_()\");\n        this.Ba = Math.floor(1E5 * Math.random());\n        a = this.Ba++;\n        var b = new U(this, this.a, \"\", a, void 0);\n        b.S(this.v);\n        var c = Rd(this), d = this.Ma.n();\n        G(d, \"RID\", a);\n        this.Bb && G(d, \"CVER\", this.Bb);\n        Nd(this, d);\n        fd(b, d, c);\n        this.p = b;\n        this.c = 2;\n      }\n    } else {\n      3 == this.c && (a ? Sd(this, a) : 0 == this.t.length ? this.a.debug(\"startForwardChannel_ returned: nothing to send\") : this.p ? this.a.J(\"startForwardChannel_ returned: connection already in progress\") : (Sd(this), this.a.debug(\"startForwardChannel_ finished, sent request\")));\n    }\n  }\n};\nfunction Sd(a, b) {\n  var c, d;\n  b ? 6 < a.ia ? (a.t = a.Q.concat(a.t), a.Q.length = 0, c = a.Ba - 1, d = Rd(a)) : (c = b.B, d = b.X) : (c = a.Ba++, d = Rd(a));\n  var e = a.Ma.n();\n  G(e, \"SID\", a.Y);\n  G(e, \"RID\", c);\n  G(e, \"AID\", a.za);\n  Nd(a, e);\n  c = new U(a, a.a, a.Y, c, a.ba + 1);\n  c.S(a.v);\n  c.setTimeout(Math.round(0.5 * a.Hb) + Math.round(0.5 * a.Hb * Math.random()));\n  a.p = c;\n  fd(c, e, d);\n}\nfunction Nd(a, b) {\n  if (a.e) {\n    var c = a.e.getAdditionalParams(a);\n    c && D(c, function(a, c) {\n      G(b, c, a);\n    });\n  }\n}\nfunction Rd(a) {\n  var b = Math.min(a.t.length, 1E3), c = [\"count=\" + b], d;\n  6 < a.ia && 0 < b ? (d = a.t[0].Ob, c.push(\"ofs=\" + d)) : d = 0;\n  for (var e = 0;e < b;e++) {\n    var g = a.t[e].Ob, h = a.t[e].map, g = 6 >= a.ia ? e : g - d;\n    try {\n      D(h, function(a, b) {\n        c.push(\"req\" + g + \"_\" + b + \"=\" + encodeURIComponent(a));\n      });\n    } catch (k) {\n      c.push(\"req\" + g + \"_type=\" + encodeURIComponent(\"_badmap\")), a.e && a.e.badMapError(a, h);\n    }\n  }\n  a.Q = a.Q.concat(a.t.splice(0, b));\n  return c.join(\"&\");\n}\nfunction Td(a) {\n  a.i || a.M || (a.yb = 1, a.M = Y(p(a.Sb, a), 0), a.ha = 0);\n}\nfunction Ud(a) {\n  if (a.i || a.M) {\n    return a.a.J(\"Request already in progress\"), !1;\n  }\n  if (3 <= a.ha) {\n    return!1;\n  }\n  a.a.debug(\"Going to retry GET\");\n  a.yb++;\n  a.M = Y(p(a.Sb, a), Vd(a, a.ha));\n  a.ha++;\n  return!0;\n}\nf.Sb = function() {\n  this.M = null;\n  if (Ld(this)) {\n    this.a.debug(\"Creating new HttpRequest\");\n    this.i = new U(this, this.a, this.Y, \"rpc\", this.yb);\n    this.i.S(this.v);\n    this.i.bc(this.ma);\n    var a = this.zb.n();\n    G(a, \"RID\", \"rpc\");\n    G(a, \"SID\", this.Y);\n    G(a, \"CI\", this.wb ? \"0\" : \"1\");\n    G(a, \"AID\", this.za);\n    Nd(this, a);\n    if (ed()) {\n      G(a, \"TYPE\", \"xmlhttp\"), hd(this.i, a, !0, this.L, !1);\n    } else {\n      G(a, \"TYPE\", \"html\");\n      var b = this.i, c = Boolean(this.L);\n      b.sa = 3;\n      b.U = H(a.n());\n      rd(b, c);\n    }\n    this.a.debug(\"New Request created\");\n  }\n};\nfunction Ld(a) {\n  if (a.e) {\n    var b = a.e.okToMakeRequest(a);\n    if (0 != b) {\n      return a.a.debug(\"Handler returned error code from okToMakeRequest\"), Z(a, b), !1;\n    }\n  }\n  return!0;\n}\nfunction Bd(a, b, c) {\n  a.a.debug(\"Test Connection Finished\");\n  a.wb = a.gc && c;\n  a.g = b.g;\n  a.a.debug(\"connectChannel_()\");\n  a.lc(Fd, 0);\n  a.Ma = xd(a, a.I);\n  Qd(a);\n}\nfunction Dd(a, b) {\n  a.a.debug(\"Test Connection Failed\");\n  a.g = b.g;\n  Z(a, 2);\n}\nf.Rb = function(a, b) {\n  if (0 != this.c && (this.i == a || this.p == a)) {\n    if (this.g = a.g, this.p == a && 3 == this.c) {\n      if (7 < this.ia) {\n        var c;\n        try {\n          c = this.P.parse(b);\n        } catch (d) {\n          c = null;\n        }\n        if (m(c) && 3 == c.length) {\n          var e = c;\n          if (0 == e[0]) {\n            a: {\n              if (this.a.debug(\"Server claims our backchannel is missing.\"), this.M) {\n                this.a.debug(\"But we are currently starting the request.\");\n              } else {\n                if (this.i) {\n                  if (this.i.Da + 3E3 < this.p.Da) {\n                    Pd(this), this.i.cancel(), this.i = null;\n                  } else {\n                    break a;\n                  }\n                } else {\n                  this.a.Z(\"We do not have a BackChannel established\");\n                }\n                Ud(this);\n                W();\n              }\n            }\n          } else {\n            this.Nb = e[1], c = this.Nb - this.za, 0 < c && (e = e[2], this.a.debug(e + \" bytes (in \" + c + \" arrays) are outstanding on the BackChannel\"), 37500 > e && this.wb && 0 == this.ha && !this.aa && (this.aa = Y(p(this.tc, this), 6E3)));\n          }\n        } else {\n          this.a.debug(\"Bad POST response data returned\"), Z(this, 11);\n        }\n      } else {\n        b != Xb && (this.a.debug(\"Bad data returned - missing/invald magic cookie\"), Z(this, 11));\n      }\n    } else {\n      if (this.i == a && Pd(this), !/^[\\s\\xa0]*$/.test(b)) {\n        c = this.P.parse(b);\n        for (var e = this.e && this.e.channelHandleMultipleArrays ? [] : null, g = 0;g < c.length;g++) {\n          var h = c[g];\n          this.za = h[0];\n          h = h[1];\n          2 == this.c ? \"c\" == h[0] ? (this.Y = h[1], this.L = this.correctHostPrefix(h[2]), h = h[3], this.ia = null != h ? h : 6, this.c = 3, this.e && this.e.channelOpened(this), this.zb = Cd(this, this.L, this.I), Td(this)) : \"stop\" == h[0] && Z(this, 7) : 3 == this.c && (\"stop\" == h[0] ? (e && 0 != e.length && (this.e.channelHandleMultipleArrays(this, e), e.length = 0), Z(this, 7)) : \"noop\" != h[0] && (e ? e.push(h) : this.e && this.e.channelHandleArray(this, h)), this.ha = 0);\n        }\n        e && 0 != e.length && this.e.channelHandleMultipleArrays(this, e);\n      }\n    }\n  }\n};\nf.correctHostPrefix = function(a) {\n  return this.hc ? this.e ? this.e.correctHostPrefix(a) : a : null;\n};\nf.tc = function() {\n  null != this.aa && (this.aa = null, this.i.cancel(), this.i = null, Ud(this), W());\n};\nfunction Pd(a) {\n  null != a.aa && (l.clearTimeout(a.aa), a.aa = null);\n}\nf.la = function(a) {\n  this.a.debug(\"Request complete\");\n  var b;\n  if (this.i == a) {\n    Pd(this), this.i = null, b = 2;\n  } else {\n    if (this.p == a) {\n      this.p = null, b = 1;\n    } else {\n      return;\n    }\n  }\n  this.g = a.g;\n  if (0 != this.c) {\n    if (a.F) {\n      1 == b ? (q(), Hd.dispatchEvent(new Jd(Hd, a.X ? a.X.length : 0)), Qd(this), this.Q.length = 0) : Td(this);\n    } else {\n      var c = a.Ib();\n      if (3 == c || 7 == c || 0 == c && 0 < this.g) {\n        this.a.debug(\"Not retrying due to error type\");\n      } else {\n        this.a.debug(\"Maybe retrying, last error: \" + ad(c, this.g));\n        var d;\n        if (d = 1 == b) {\n          this.p || this.G ? (this.a.J(\"Request already in progress\"), d = !1) : this.c == Fd || this.ba >= (this.Ka ? 0 : this.pb) ? d = !1 : (this.a.debug(\"Going to retry POST\"), this.G = Y(p(this.Tb, this, a), Vd(this, this.ba)), this.ba++, d = !0);\n        }\n        if (d || 2 == b && Ud(this)) {\n          return;\n        }\n        this.a.debug(\"Exceeded max number of retries\");\n      }\n      this.a.debug(\"Error: HTTP request failed\");\n      switch(c) {\n        case 1:\n          Z(this, 5);\n          break;\n        case 4:\n          Z(this, 10);\n          break;\n        case 3:\n          Z(this, 6);\n          break;\n        case 7:\n          Z(this, 12);\n          break;\n        default:\n          Z(this, 2);\n      }\n    }\n  }\n};\nfunction Vd(a, b) {\n  var c = a.ic + Math.floor(Math.random() * a.Cc);\n  a.isActive() || (a.a.debug(\"Inactive channel\"), c *= 2);\n  return c * b;\n}\nf.lc = function(a) {\n  if (!(0 <= Xa(arguments, this.c))) {\n    throw Error(\"Unexpected channel state: \" + this.c);\n  }\n};\nfunction Z(a, b) {\n  a.a.info(\"Error code \" + b);\n  if (2 == b || 9 == b) {\n    var c = null;\n    a.e && (c = a.e.getNetworkTestImageUri(a));\n    var d = p(a.Fc, a);\n    c || (c = new E(\"//www.google.com/images/cleardot.gif\"), H(c));\n    vd(c.toString(), 1E4, d);\n  } else {\n    W();\n  }\n  Wd(a, b);\n}\nf.Fc = function(a) {\n  a ? (this.a.info(\"Successfully pinged google.com\"), W()) : (this.a.info(\"Failed to ping google.com\"), W(), Wd(this, 8));\n};\nfunction Wd(a, b) {\n  a.a.debug(\"HttpChannel: error - \" + b);\n  a.c = 0;\n  a.e && a.e.channelError(a, b);\n  Od(a);\n  Md(a);\n}\nfunction Od(a) {\n  a.c = 0;\n  a.g = -1;\n  if (a.e) {\n    if (0 == a.Q.length && 0 == a.t.length) {\n      a.e.channelClosed(a);\n    } else {\n      a.a.debug(\"Number of undelivered maps, pending: \" + a.Q.length + \", outgoing: \" + a.t.length);\n      var b = bb(a.Q), c = bb(a.t);\n      a.Q.length = 0;\n      a.t.length = 0;\n      a.e.channelClosed(a, b, c);\n    }\n  }\n}\nfunction xd(a, b) {\n  var c = Ad(a, null, b);\n  a.a.debug(\"GetForwardChannelUri: \" + c);\n  return c;\n}\nfunction Cd(a, b, c) {\n  b = Ad(a, a.$a() ? b : null, c);\n  a.a.debug(\"GetBackChannelUri: \" + b);\n  return b;\n}\nfunction Ad(a, b, c) {\n  var d = tb(c);\n  if (\"\" != d.ja) {\n    b && gb(d, b + \".\" + d.ja), hb(d, d.Ca);\n  } else {\n    var e = window.location, d = ub(e.protocol, b ? b + \".\" + e.hostname : e.hostname, e.port, c)\n  }\n  a.xa && D(a.xa, function(a, b) {\n    G(d, b, a);\n  });\n  G(d, \"VER\", a.ia);\n  Nd(a, d);\n  return d;\n}\nf.lb = function(a) {\n  if (a && !this.ab) {\n    throw Error(\"Can't create secondary domain capable XhrIo object.\");\n  }\n  a = new Ic;\n  a.dc = this.ab;\n  return a;\n};\nf.isActive = function() {\n  return!!this.e && this.e.isActive(this);\n};\nfunction Y(a, b) {\n  if (!fa(a)) {\n    throw Error(\"Fn must not be null and must be a function\");\n  }\n  return l.setTimeout(function() {\n    a();\n  }, b);\n}\nf.H = function() {\n  Hd.dispatchEvent(new Kd(Hd));\n};\nfunction W() {\n  Hd.dispatchEvent(new Id(Hd));\n}\nf.$a = function() {\n  return this.ab || !ed();\n};\nfunction Xd() {\n}\nf = Xd.prototype;\nf.channelHandleMultipleArrays = null;\nf.okToMakeRequest = function() {\n  return 0;\n};\nf.channelOpened = function() {\n};\nf.channelHandleArray = function() {\n};\nf.channelError = function() {\n};\nf.channelClosed = function() {\n};\nf.getAdditionalParams = function() {\n  return{};\n};\nf.getNetworkTestImageUri = function() {\n  return null;\n};\nf.isActive = function() {\n  return!0;\n};\nf.badMapError = function() {\n};\nf.correctHostPrefix = function(a) {\n  return a;\n};\nvar $, Yd;\nYd = {0:\"Ok\", 4:\"User is logging out\", 6:\"Unknown session ID\", 7:\"Stopped by server\", 8:\"General network error\", 2:\"Request failed\", 9:\"Blocked by a network administrator\", 5:\"No data from server\", 10:\"Got bad data from the server\", 11:\"Got a bad response from the server\"};\n$ = function(a, b) {\n  var c, d, e, g, h, k, u, K, v, r, Ka, w, X, cd;\n  if (!(this instanceof $)) {\n    return new $(a, b);\n  }\n  r = this;\n  a || (a = \"channel\");\n  a.match(/:\\/\\//) && a.replace(/^ws/, \"http\");\n  b || (b = {});\n  m(b || \"string\" === typeof b) && (b = {});\n  K = b.reconnectTime || 3E3;\n  c = b.extraHeaders || null;\n  d = b.extraParams || null;\n  null !== b.affinity && (d || (d = {}), b.affinityParam || (b.affinityParam = \"a\"), this.affinity = b.affinity || sa(), d[b.affinityParam] = this.affinity);\n  X = function(a) {\n    r.readyState = r.readyState = a;\n  };\n  X(this.CLOSED);\n  w = null;\n  k = null != (cd = b.prev) ? cd.Ec : void 0;\n  e = function(a, b, c, d, e) {\n    try {\n      return \"function\" === typeof r[a] ? r[a](c, d, e) : void 0;\n    } catch (g) {\n      throw \"undefined\" !== typeof console && null !== console && console.error(g.stack), g;\n    }\n  };\n  g = new Xd;\n  g.channelOpened = function() {\n    k = w;\n    X($.OPEN);\n    return e(\"onopen\");\n  };\n  h = null;\n  g.channelError = function(a, b) {\n    var c;\n    c = Yd[b];\n    h = b;\n    r.readyState !== $.CLOSED && X($.hb);\n    return e(\"onerror\", 0, c, b);\n  };\n  v = null;\n  g.channelClosed = function(a, c, d) {\n    var g;\n    if (r.readyState !== $.CLOSED) {\n      return w = null, a = h ? Yd[h] : \"Closed\", X($.CLOSED), b.reconnect && 7 !== h && 0 !== h && (g = 6 === h ? 0 : K, clearTimeout(v), v = setTimeout(u, g)), e(\"onclose\", 0, a, c, d), h = null;\n    }\n  };\n  g.channelHandleArray = function(a, b) {\n    return e(\"onmessage\", 0, {type:\"message\", data:b});\n  };\n  u = function() {\n    if (w) {\n      throw Error(\"Reconnect() called from invalid state\");\n    }\n    X($.CONNECTING);\n    e(\"onconnecting\");\n    clearTimeout(v);\n    r.Ec = w = new Ed(b.appVersion, null != k ? k.Gb : void 0);\n    b.crossDomainXhr && (w.ab = !0);\n    w.e = g;\n    c && w.S(c);\n    h = null;\n    if (b.failFast) {\n      var t = w;\n      t.Ka = !0;\n      t.a.info(\"setFailFast: true\");\n      (t.p || t.G) && t.ba > (t.Ka ? 0 : t.pb) && (t.a.info(\"Retry count \" + t.ba + \" > new maxRetries \" + (t.Ka ? 0 : t.pb) + \". Fail immediately!\"), t.p ? (t.p.cancel(), t.la(t.p)) : (l.clearTimeout(t.G), t.G = null, Z(t, 2)));\n    }\n    return w.kb(\"\" + a + \"/test\", \"\" + a + \"/bind\", d, null != k ? k.Y : void 0, null != k ? k.za : void 0);\n  };\n  this.open = function() {\n    if (r.readyState !== r.CLOSED) {\n      throw Error(\"Already open\");\n    }\n    return u();\n  };\n  this.close = function() {\n    clearTimeout(v);\n    h = 0;\n    if (r.readyState !== $.CLOSED) {\n      return X($.hb), w.disconnect();\n    }\n  };\n  this.sendMap = Ka = function(a) {\n    var b;\n    if ((b = r.readyState) !== $.hb && b !== $.CLOSED) {\n      b = w;\n      if (0 == b.c) {\n        throw Error(\"Invalid operation: sending map when state is closed\");\n      }\n      1E3 == b.t.length && b.a.J(\"Already have 1000 queued maps upon queueing \" + yb(a));\n      b.t.push(new Gd(b.sc++, a));\n      2 != b.c && 3 != b.c || Qd(b);\n    }\n  };\n  this.send = function(a) {\n    return \"string\" === typeof a ? Ka({_S:a}) : Ka({JSON:yb(a)});\n  };\n  u();\n};\n$.prototype.canSendWhileConnecting = $.canSendWhileConnecting = !0;\n$.prototype.canSendJSON = $.canSendJSON = !0;\n$.prototype.CONNECTING = $.CONNECTING = $.CONNECTING = 0;\n$.prototype.OPEN = $.OPEN = $.OPEN = 1;\n$.prototype.CLOSING = $.CLOSING = $.hb = 2;\n$.prototype.CLOSED = $.CLOSED = $.CLOSED = 3;\n(\"undefined\" !== typeof exports && null !== exports ? exports : window).BCSocket = $;\n\n})();\n",
    "/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n",
    "exports.contexts = require('./lib/contexts');\nexports.expressions = require('./lib/expressions');\nexports.operatorFns = require('./lib/operatorFns');\nexports.options = require('./lib/options');\nexports.templates = require('./lib/templates');\n",
    "exports.ContextMeta = ContextMeta;\nexports.Context = Context;\n\nfunction noop() {}\n\n// TODO:\n// Implement removeItemContext\n\nfunction ContextMeta() {\n  this.addBinding = noop;\n  this.removeBinding = noop;\n  this.removeNode = noop;\n  this.addItemContext = noop;\n  this.removeItemContext = noop;\n  this.views = null;\n  this.idNamespace = '';\n  this.idCount = 0;\n  this.pending = [];\n  this.pauseCount = 0;\n}\n\nfunction Context(meta, controller, parent, unbound, expression) {\n  // Required properties //\n\n  // Properties which are globally inherited for the entire page\n  this.meta = meta;\n  // The page or component. Must have a `model` property with a `data` property\n  this.controller = controller;\n\n  // Optional properties //\n\n  // Containing context\n  this.parent = parent;\n  // Boolean set to true when bindings should be ignored\n  this.unbound = unbound;\n  // The expression for a block\n  this.expression = expression;\n  // Alias name for the given expression\n  this.alias = expression && expression.meta && expression.meta.as;\n  // Alias name for the index or iterated key\n  this.keyAlias = expression && expression.meta && expression.meta.keyAs;\n\n  // For Context::eachChild\n  // The context of the each at render time\n  this.item = null;\n\n  // For Context::viewChild\n  // Reference to the current view\n  this.view = null;\n  // Attribute values passed to the view instance\n  this.attributes = null;\n  // MarkupHooks to be called after insert into DOM of component\n  this.hooks = null;\n  // MarkupHooks to be called immediately before init of component\n  this.initHooks = null;\n\n  // For Context::closureChild\n  // Reference to another context established at render time by ContextClosure\n  this.closure = null;\n\n  // Used in EventModel\n  this._id = null;\n}\n\nContext.prototype.id = function() {\n  var count = ++this.meta.idCount;\n  return this.meta.idNamespace + '_' + count.toString(36);\n};\n\nContext.prototype.addBinding = function(binding) {\n  // Don't add bindings that wrap list items. Only their outer range is needed\n  if (binding.itemFor) return;\n  var expression = binding.template.expression;\n  // Don't rerender in unbound sections\n  if (expression ? expression.isUnbound(this) : this.unbound) return;\n  // Don't rerender to changes in a with expression\n  if (expression && expression.meta && expression.meta.blockType === 'with') return;\n  this.meta.addBinding(binding);\n};\nContext.prototype.removeBinding = function(binding) {\n  this.meta.removeBinding(binding);\n};\nContext.prototype.removeNode = function(node) {\n  this.meta.removeNode(node);\n};\n\nContext.prototype.child = function(expression) {\n  // Set or inherit the binding mode\n  var blockType = expression.meta && expression.meta.blockType;\n  var unbound = (blockType === 'unbound') ? true :\n    (blockType === 'bound') ? false :\n    this.unbound;\n  return new Context(this.meta, this.controller, this, unbound, expression);\n};\n\nContext.prototype.componentChild = function(component) {\n  return new Context(this.meta, component, this, this.unbound);\n};\n\n// Make a context for an item in an each block\nContext.prototype.eachChild = function(expression, item) {\n  var context = new Context(this.meta, this.controller, this, this.unbound, expression);\n  context.item = item;\n  this.meta.addItemContext(context);\n  return context;\n};\n\nContext.prototype.viewChild = function(view, attributes, hooks, initHooks) {\n  var context = new Context(this.meta, this.controller, this, this.unbound);\n  context.view = view;\n  context.attributes = attributes;\n  context.hooks = hooks;\n  context.initHooks = initHooks;\n  return context;\n};\n\nContext.prototype.closureChild = function(closure) {\n  var context = new Context(this.meta, this.controller, this, this.unbound);\n  context.closure = closure;\n  return context;\n};\n\nContext.prototype.forRelative = function(expression) {\n  var context = this;\n  while (context && context.expression === expression || context.view) {\n    context = context.parent;\n  }\n  return context;\n};\n\n// Returns the closest context which defined the named alias\nContext.prototype.forAlias = function(alias) {\n  var context = this;\n  while (context) {\n    if (context.alias === alias || context.keyAlias === alias) return context;\n    context = context.parent;\n  }\n};\n\n// Returns the closest containing context for a view attribute name or nothing\nContext.prototype.forAttribute = function(attribute) {\n  var context = this;\n  while (context) {\n    // Find the closest context associated with a view\n    if (context.view) {\n      var attributes = context.attributes;\n      if (!attributes) return;\n      if (attributes.hasOwnProperty(attribute)) return context;\n      // If the attribute isn't found, but the attributes inherit, continue\n      // looking in the next closest view context\n      if (!attributes.inherit && !attributes.extend) return;\n    }\n    context = context.parent;\n  }\n};\n\nContext.prototype.forViewParent = function() {\n  var context = this;\n  while (context) {\n    // When a context with a `closure` property is encountered, skip to its\n    // parent context rather than returning the nearest view's. This reference\n    // is created by wrapping a template in a ContextClosure template\n    if (context.closure) return context.closure.parent;\n    // Find the closest view and return the containing context\n    if (context.view) return context.parent;\n    context = context.parent;\n  }\n};\n\nContext.prototype.getView = function() {\n  var context = this;\n  while (context) {\n    // Find the closest view\n    if (context.view) return context.view;\n    context = context.parent;\n  }\n};\n\n// Returns the `this` value for a context\nContext.prototype.get = function() {\n  var value = (this.expression) ?\n    this.expression.get(this) :\n    this.controller.model.data;\n  if (this.item != null) {\n    return value && value[this.item];\n  }\n  return value;\n};\n\nContext.prototype.pause = function() {\n  this.meta.pauseCount++;\n};\n\nContext.prototype.unpause = function() {\n  if (--this.meta.pauseCount) return;\n  this.flush();\n};\n\nContext.prototype.flush = function() {\n  var pending = this.meta.pending;\n  var len = pending.length;\n  if (!len) return;\n  this.meta.pending = [];\n  for (var i = 0; i < len; i++) {\n    pending[i]();\n  }\n};\n\nContext.prototype.queue = function(cb) {\n  this.meta.pending.push(cb);\n};\n",
    "var serializeObject = require('serialize-object');\nvar operatorFns = require('./operatorFns');\nvar templates = require('./templates');\nvar Template = templates.Template;\nvar util = require('./util');\nvar concat = util.concat;\n\nexports.lookup = lookup;\nexports.templateTruthy = templateTruthy;\nexports.pathSegments = pathSegments;\nexports.renderValue = renderValue;\nexports.renderTemplate = renderTemplate;\nexports.ExpressionMeta = ExpressionMeta;\n\nexports.Expression = Expression;\nexports.LiteralExpression = LiteralExpression;\nexports.PathExpression = PathExpression;\nexports.RelativePathExpression = RelativePathExpression;\nexports.AliasPathExpression = AliasPathExpression;\nexports.AttributePathExpression = AttributePathExpression;\nexports.BracketsExpression = BracketsExpression;\nexports.DeferRenderExpression = DeferRenderExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.FnExpression = FnExpression;\nexports.OperatorExpression = OperatorExpression;\nexports.NewExpression = NewExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ViewParentExpression = ViewParentExpression;\nexports.ScopedModelExpression = ScopedModelExpression;\n\nfunction lookup(segments, value) {\n  if (!segments) return value;\n\n  for (var i = 0, len = segments.length; i < len; i++) {\n    if (value == null) return value;\n    value = value[segments[i]];\n  }\n  return value;\n}\n\n// Unlike JS, `[]` is falsey. Otherwise, truthiness is the same as JS\nfunction templateTruthy(value) {\n  return (Array.isArray(value)) ? value.length > 0 : !!value;\n}\n\nfunction pathSegments(segments) {\n  var result = [];\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    result[i] = (typeof segment === 'object') ? segment.item : segment;\n  }\n  return result;\n}\n\nfunction renderValue(value, context) {\n  return (typeof value !== 'object') ? value :\n    (value instanceof Template) ? renderTemplate(value, context) :\n    (Array.isArray(value)) ? renderArray(value, context) :\n    renderObject(value, context);\n}\nfunction renderTemplate(value, context) {\n  var i = 1000;\n  while (value instanceof Template) {\n    if (--i < 0) throw new Error('Maximum template render passes exceeded');\n    value = value.get(context, true);\n  }\n  return value;\n}\nfunction renderArray(array, context) {\n  for (var i = 0; i < array.length; i++) {\n    if (hasTemplateProperty(array[i])) {\n      return renderArrayProperties(array, context);\n    }\n  }\n  return array;\n}\nfunction renderObject(object, context) {\n  return (hasTemplateProperty(object)) ?\n    renderObjectProperties(object, context) : object;\n}\nfunction hasTemplateProperty(object) {\n  if (!object) return false;\n  if (object.constructor !== Object) return false;\n  for (var key in object) {\n    if (object[key] instanceof Template) return true;\n  }\n  return false;\n}\nfunction renderArrayProperties(array, context) {\n  var out = new Array(array.length);\n  for (var i = 0; i < array.length; i++) {\n    out[i] = renderValue(array[i], context);\n  }\n  return out;\n}\nfunction renderObjectProperties(object, context) {\n  var out = {};\n  for (var key in object) {\n    out[key] = renderValue(object[key], context);\n  }\n  return out;\n}\n\nfunction ExpressionMeta(source, blockType, isEnd, as, keyAs, unescaped, bindType, valueType) {\n  this.source = source;\n  this.blockType = blockType;\n  this.isEnd = isEnd;\n  this.as = as;\n  this.keyAs = keyAs;\n  this.unescaped = unescaped;\n  this.bindType = bindType;\n  this.valueType = valueType;\n}\nExpressionMeta.prototype.module = 'expressions';\nExpressionMeta.prototype.type = 'ExpressionMeta';\nExpressionMeta.prototype.serialize = function() {\n  return serializeObject.instance(\n    this\n  , this.source\n  , this.blockType\n  , this.isEnd\n  , this.as\n  , this.keyAs\n  , this.unescaped\n  , this.bindType\n  , this.valueType\n  );\n};\n\nfunction Expression(meta) {\n  this.meta = meta;\n}\nExpression.prototype.module = 'expressions';\nExpression.prototype.type = 'Expression';\nExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.meta);\n};\nExpression.prototype.toString = function() {\n  return this.meta && this.meta.source;\n};\nExpression.prototype.truthy = function(context) {\n  var blockType = this.meta.blockType;\n  if (blockType === 'else') return true;\n  var value = this.get(context, true);\n  var truthy = templateTruthy(value);\n  return (blockType === 'unless') ? !truthy : truthy;\n};\nExpression.prototype.get = function() {};\n// Return the expression's segment list with context objects\nExpression.prototype.resolve = function() {};\n// Return a list of segment lists or null\nExpression.prototype.dependencies = function() {};\n// Return the pathSegments that the expression currently resolves to or null\nExpression.prototype.pathSegments = function(context) {\n  var segments = this.resolve(context);\n  return segments && pathSegments(segments);\n};\nExpression.prototype.set = function(context, value) {\n  var segments = this.pathSegments(context);\n  if (!segments) throw new Error('Expression does not support setting');\n  context.controller.model._set(segments, value);\n};\nExpression.prototype._resolvePatch = function(context, segments) {\n  return (context && context.expression === this && context.item != null) ?\n    segments.concat(context) : segments;\n};\nExpression.prototype.isUnbound = function(context) {\n  // If the template being rendered has an explicit bindType keyword, such as:\n  // {{unbound #item.text}}\n  var bindType = this.meta && this.meta.bindType;\n  if (bindType === 'unbound') return true;\n  if (bindType === 'bound') return false;\n  // Otherwise, inherit from the context\n  return context.unbound;\n};\nExpression.prototype._lookupAndContextifyValue = function(value, context) {\n  if (this.segments && this.segments.length) {\n    // If expression has segments, e.g. `bar.baz` in `#foo.bar.baz`, then\n    // render the base value (e.g. `#foo`) if it's a template and look up the\n    // value at the indicated path.\n    value = renderTemplate(value, context);\n    value = lookup(this.segments, value);\n  }\n  if (value instanceof Template && !(value instanceof templates.ContextClosure)) {\n    // If we're not immediately rendering the template, then create a ContextClosure\n    // so that the value renders with the correct context later.\n    value = new templates.ContextClosure(value, context);\n  }\n  return value;\n};\n\n\nfunction LiteralExpression(value, meta) {\n  this.value = value;\n  this.meta = meta;\n}\nLiteralExpression.prototype = Object.create(Expression.prototype);\nLiteralExpression.prototype.constructor = LiteralExpression;\nLiteralExpression.prototype.type = 'LiteralExpression';\nLiteralExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.value, this.meta);\n};\nLiteralExpression.prototype.get = function() {\n  return this.value;\n};\n\nfunction PathExpression(segments, meta) {\n  this.segments = segments;\n  this.meta = meta;\n}\nPathExpression.prototype = Object.create(Expression.prototype);\nPathExpression.prototype.constructor = PathExpression;\nPathExpression.prototype.type = 'PathExpression';\nPathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.segments, this.meta);\n};\nPathExpression.prototype.get = function(context) {\n  // See View::dependencies. This is needed in order to handle the case of\n  // getting dependencies within a component template, in which case we cannot\n  // access model data separate from rendering.\n  if (!context.controller) return;\n  return lookup(this.segments, context.controller.model.data);\n};\nPathExpression.prototype.resolve = function(context) {\n  // See View::dependencies. This is needed in order to handle the case of\n  // getting dependencies within a component template, in which case we cannot\n  // access model data separate from rendering.\n  if (!context.controller) return;\n  var segments = concat(context.controller._scope, this.segments);\n  return this._resolvePatch(context, segments);\n};\nPathExpression.prototype.dependencies = function(context, options) {\n  // See View::dependencies. This is needed in order to handle the case of\n  // getting dependencies within a component template, in which case we cannot\n  // access model data separate from rendering.\n  if (!context.controller) return;\n  var value = lookup(this.segments, context.controller.model.data);\n  var dependencies = getDependencies(value, context, options);\n  return appendDependency(dependencies, this, context);\n};\n\nfunction RelativePathExpression(segments, meta) {\n  this.segments = segments;\n  this.meta = meta;\n}\nRelativePathExpression.prototype = Object.create(Expression.prototype);\nRelativePathExpression.prototype.constructor = RelativePathExpression;\nRelativePathExpression.prototype.type = 'RelativePathExpression';\nRelativePathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.segments, this.meta);\n};\nRelativePathExpression.prototype.get = function(context) {\n  var relativeContext = context.forRelative(this);\n  var value = relativeContext.get();\n  return this._lookupAndContextifyValue(value, relativeContext);\n};\nRelativePathExpression.prototype.resolve = function(context) {\n  var relativeContext = context.forRelative(this);\n  var base = (relativeContext.expression) ?\n    relativeContext.expression.resolve(relativeContext) :\n    [];\n  if (!base) return;\n  var segments = base.concat(this.segments);\n  return this._resolvePatch(context, segments);\n};\nRelativePathExpression.prototype.dependencies = function(context, options) {\n  // Return inner dependencies from our ancestor\n  // (e.g., {{ with foo[bar] }} ... {{ this.x }} has 'bar' as a dependency.)\n  var relativeContext = context.forRelative(this);\n  var dependencies = relativeContext.expression &&\n    relativeContext.expression.dependencies(relativeContext, options);\n  return swapLastDependency(dependencies, this, context);\n};\n\nfunction AliasPathExpression(alias, segments, meta) {\n  this.alias = alias;\n  this.segments = segments;\n  this.meta = meta;\n}\nAliasPathExpression.prototype = Object.create(Expression.prototype);\nAliasPathExpression.prototype.constructor = AliasPathExpression;\nAliasPathExpression.prototype.type = 'AliasPathExpression';\nAliasPathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.alias, this.segments, this.meta);\n};\nAliasPathExpression.prototype.get = function(context) {\n  var aliasContext = context.forAlias(this.alias);\n  if (!aliasContext) return;\n  if (aliasContext.keyAlias === this.alias) {\n    return aliasContext.item;\n  }\n  var value = aliasContext.get();\n  return this._lookupAndContextifyValue(value, aliasContext);\n};\nAliasPathExpression.prototype.resolve = function(context) {\n  var aliasContext = context.forAlias(this.alias);\n  if (!aliasContext) return;\n  if (aliasContext.keyAlias === this.alias) return;\n  var base = aliasContext.expression.resolve(aliasContext);\n  if (!base) return;\n  var segments = base.concat(this.segments);\n  return this._resolvePatch(context, segments);\n};\nAliasPathExpression.prototype.dependencies = function(context, options) {\n  var aliasContext = context.forAlias(this.alias);\n  if (!aliasContext) return;\n  if (aliasContext.keyAlias === this.alias) {\n    // For keyAliases, use a dependency of the entire list, so that it will\n    // always update when the list itself changes. This is over-binding, but\n    // would otherwise be much more complex\n    var base = aliasContext.expression.resolve(aliasContext.parent);\n    if (!base) return;\n    return [base];\n  }\n\n  var dependencies = aliasContext.expression.dependencies(aliasContext, options);\n  return swapLastDependency(dependencies, this, context);\n};\n\nfunction AttributePathExpression(attribute, segments, meta) {\n  this.attribute = attribute;\n  this.segments = segments;\n  this.meta = meta;\n}\nAttributePathExpression.prototype = Object.create(Expression.prototype);\nAttributePathExpression.prototype.constructor = AttributePathExpression;\nAttributePathExpression.prototype.type = 'AttributePathExpression';\nAttributePathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.attribute, this.segments, this.meta);\n};\nAttributePathExpression.prototype.get = function(context) {\n  var attributeContext = context.forAttribute(this.attribute);\n  if (!attributeContext) return;\n  var value = attributeContext.attributes[this.attribute];\n  if (value instanceof Expression) {\n    value = value.get(attributeContext);\n  }\n  return this._lookupAndContextifyValue(value, attributeContext);\n};\nAttributePathExpression.prototype.resolve = function(context) {\n  var attributeContext = context.forAttribute(this.attribute);\n  if (!attributeContext) return;\n  // Attributes may be a template, an expression, or a literal value\n  var base;\n  var value = attributeContext.attributes[this.attribute];\n  if (value instanceof Expression || value instanceof Template) {\n    base = value.resolve(attributeContext);\n  }\n  if (!base) return;\n  var segments = base.concat(this.segments);\n  return this._resolvePatch(context, segments);\n};\nAttributePathExpression.prototype.dependencies = function(context, options) {\n  var attributeContext = context.forAttribute(this.attribute);\n  if (!attributeContext) return;\n\n  // Attributes may be a template, an expression, or a literal value\n  var value = attributeContext.attributes[this.attribute];\n  var dependencies = getDependencies(value, attributeContext, options);\n  return swapLastDependency(dependencies, this, context);\n};\n\nfunction BracketsExpression(before, inside, afterSegments, meta) {\n  this.before = before;\n  this.inside = inside;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n}\nBracketsExpression.prototype = Object.create(Expression.prototype);\nBracketsExpression.prototype.constructor = BracketsExpression;\nBracketsExpression.prototype.type = 'BracketsExpression';\nBracketsExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.before, this.inside, this.afterSegments, this.meta);\n};\nBracketsExpression.prototype.get = function(context) {\n  var inside = this.inside.get(context);\n  if (inside == null) return;\n  var before = this.before.get(context);\n  if (!before) return;\n  var base = before[inside];\n  return (this.afterSegments) ? lookup(this.afterSegments, base) : base;\n};\nBracketsExpression.prototype.resolve = function(context) {\n  // Get and split the current value of the expression inside the brackets\n  var inside = this.inside.get(context);\n  if (inside == null) return;\n\n  // Concat the before, inside, and optional after segments\n  var base = this.before.resolve(context);\n  if (!base) return;\n  var segments = (this.afterSegments) ?\n    base.concat(inside, this.afterSegments) :\n    base.concat(inside);\n  return this._resolvePatch(context, segments);\n};\nBracketsExpression.prototype.dependencies = function(context, options) {\n  var before = this.before.dependencies(context, options);\n  if (before) before.pop();\n  var inner = this.inside.dependencies(context, options);\n  var dependencies = concat(before, inner);\n  return appendDependency(dependencies, this, context);\n};\n\n// This Expression is used to wrap a template so that when its containing\n// Expression--such as an ObjectExpression or ArrayExpression--is evaluated,\n// it returns the template unrendered and wrapped in the current context.\n// Separating evaluation of the containing expression from template rendering\n// is used to support array attributes of views. This way, we can evaluate an\n// array and iterate through it separately from rendering template content\nfunction DeferRenderExpression(template, meta) {\n  if (!(template instanceof Template)) {\n    throw new Error('DeferRenderExpression requires a Template argument');\n  }\n  this.template = template;\n  this.meta = meta;\n}\nDeferRenderExpression.prototype = Object.create(Expression.prototype);\nDeferRenderExpression.prototype.constructor = DeferRenderExpression;\nDeferRenderExpression.prototype.type = 'DeferRenderExpression';\nDeferRenderExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.template, this.meta);\n};\nDeferRenderExpression.prototype.get = function(context) {\n  return new templates.ContextClosure(this.template, context);\n};\n\nfunction ArrayExpression(items, afterSegments, meta) {\n  this.items = items;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n}\nArrayExpression.prototype = Object.create(Expression.prototype);\nArrayExpression.prototype.constructor = ArrayExpression;\nArrayExpression.prototype.type = 'ArrayExpression';\nArrayExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.items, this.afterSegments, this.meta);\n};\nArrayExpression.prototype.get = function(context) {\n  var items = new Array(this.items.length);\n  for (var i = 0; i < this.items.length; i++) {\n    var value = this.items[i].get(context);\n    items[i] = value;\n  }\n  return (this.afterSegments) ? lookup(this.afterSegments, items) : items;\n};\nArrayExpression.prototype.dependencies = function(context, options) {\n  if (!this.items) return;\n  var dependencies;\n  for (var i = 0; i < this.items.length; i++) {\n    var itemDependencies = this.items[i].dependencies(context, options);\n    dependencies = concat(dependencies, itemDependencies);\n  }\n  return dependencies;\n};\n\nfunction ObjectExpression(properties, afterSegments, meta) {\n  this.properties = properties;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n}\nObjectExpression.prototype = Object.create(Expression.prototype);\nObjectExpression.prototype.constructor = ObjectExpression;\nObjectExpression.prototype.type = 'ObjectExpression';\nObjectExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.properties, this.afterSegments, this.meta);\n};\nObjectExpression.prototype.get = function(context) {\n  var object = {};\n  for (var key in this.properties) {\n    var value = this.properties[key].get(context);\n    object[key] = value;\n  }\n  return (this.afterSegments) ? lookup(this.afterSegments, object) : object;\n};\nObjectExpression.prototype.dependencies = function(context, options) {\n  if (!this.properties) return;\n  var dependencies;\n  for (var key in this.properties) {\n    var propertyDependencies = this.properties[key].dependencies(context, options);\n    dependencies = concat(dependencies, propertyDependencies);\n  }\n  return dependencies;\n};\n\nfunction FnExpression(segments, args, afterSegments, meta) {\n  this.segments = segments;\n  this.args = args;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n  var parentSegments = segments && segments.slice();\n  this.lastSegment = parentSegments && parentSegments.pop();\n  this.parentSegments = (parentSegments && parentSegments.length) ? parentSegments : null;\n}\nFnExpression.prototype = Object.create(Expression.prototype);\nFnExpression.prototype.constructor = FnExpression;\nFnExpression.prototype.type = 'FnExpression';\nFnExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.segments, this.args, this.afterSegments, this.meta);\n};\nFnExpression.prototype.get = function(context) {\n  var value = this.apply(context);\n  // Lookup property underneath computed value if needed\n  return (this.afterSegments) ? lookup(this.afterSegments, value) : value;\n};\nFnExpression.prototype.apply = function(context, extraInputs) {\n  // See View::dependencies. This is needed in order to handle the case of\n  // getting dependencies within a component template, in which case we cannot\n  // access model data separate from rendering.\n  if (!context.controller) return;\n  var parent = this._lookupParent(context);\n  var fn = parent[this.lastSegment];\n  var getFn = fn.get || fn;\n  var out = this._applyFn(getFn, context, extraInputs, parent);\n  return out;\n};\nFnExpression.prototype._lookupParent = function(context) {\n  // Lookup function on current controller\n  var controller = context.controller;\n  var segments = this.parentSegments;\n  var parent = (segments) ? lookup(segments, controller) : controller;\n  if (parent && parent[this.lastSegment]) return parent;\n  // Otherwise lookup function on page\n  var page = controller.page;\n  if (controller !== page) {\n    parent = (segments) ? lookup(segments, page) : page;\n    if (parent && parent[this.lastSegment]) return parent;\n  }\n  // Otherwise lookup function on global\n  parent = (segments) ? lookup(segments, global) : global;\n  if (parent && parent[this.lastSegment]) return parent;\n  // Throw if not found\n  throw new Error('Function not found for: ' + this.segments.join('.'));\n};\nFnExpression.prototype._getInputs = function(context) {\n  var inputs = [];\n  for (var i = 0, len = this.args.length; i < len; i++) {\n    var value = this.args[i].get(context);\n    inputs.push(renderValue(value, context));\n  }\n  return inputs;\n};\nFnExpression.prototype._applyFn = function(fn, context, extraInputs, thisArg) {\n  // Apply if there are no path inputs\n  if (!this.args) {\n    return (extraInputs) ?\n      fn.apply(thisArg, extraInputs) :\n      fn.call(thisArg);\n  }\n  // Otherwise, get the current value for path inputs and apply\n  var inputs = this._getInputs(context);\n  if (extraInputs) {\n    for (var i = 0, len = extraInputs.length; i < len; i++) {\n      inputs.push(extraInputs[i]);\n    }\n  }\n  return fn.apply(thisArg, inputs);\n};\nFnExpression.prototype.dependencies = function(context, options) {\n  var dependencies = [];\n  if (!this.args) return dependencies;\n  for (var i = 0, len = this.args.length; i < len; i++) {\n    var argDependencies = this.args[i].dependencies(context, options);\n    if (!argDependencies || argDependencies.length < 1) continue;\n    var end = argDependencies.length - 1;\n    for (var j = 0; j < end; j++) {\n      dependencies.push(argDependencies[j]);\n    }\n    var last = argDependencies[end];\n    if (last[last.length - 1] !== '*') {\n      last = last.concat('*');\n    }\n    dependencies.push(last);\n  }\n  return dependencies;\n};\nFnExpression.prototype.set = function(context, value) {\n  var controller = context.controller;\n  var fn, parent;\n  while (controller) {\n    parent = (this.parentSegments) ?\n      lookup(this.parentSegments, controller) :\n      controller;\n    fn = parent && parent[this.lastSegment];\n    if (fn) break;\n    controller = controller.parent;\n  }\n  var setFn = fn && fn.set;\n  if (!setFn) throw new Error('No setter function for: ' + this.segments.join('.'));\n  var inputs = this._getInputs(context);\n  inputs.unshift(value);\n  var out = setFn.apply(parent, inputs);\n  for (var i in out) {\n    this.args[i].set(context, out[i]);\n  }\n};\n\nfunction NewExpression(segments, args, afterSegments, meta) {\n  FnExpression.call(this, segments, args, afterSegments, meta);\n}\nNewExpression.prototype = Object.create(FnExpression.prototype);\nNewExpression.prototype.constructor = NewExpression;\nNewExpression.prototype.type = 'NewExpression';\nNewExpression.prototype._applyFn = function(Fn, context) {\n  // Apply if there are no path inputs\n  if (!this.args) return new Fn();\n  // Otherwise, get the current value for path inputs and apply\n  var inputs = this._getInputs(context);\n  inputs.unshift(null);\n  return new (Fn.bind.apply(Fn, inputs))();\n};\n\nfunction OperatorExpression(name, args, afterSegments, meta) {\n  this.name = name;\n  this.args = args;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n  this.getFn = operatorFns.get[name];\n  this.setFn = operatorFns.set[name];\n}\nOperatorExpression.prototype = Object.create(FnExpression.prototype);\nOperatorExpression.prototype.constructor = OperatorExpression;\nOperatorExpression.prototype.type = 'OperatorExpression';\nOperatorExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.args, this.afterSegments, this.meta);\n};\nOperatorExpression.prototype.apply = function(context) {\n  var inputs = this._getInputs(context);\n  return this.getFn.apply(null, inputs);\n};\nOperatorExpression.prototype.set = function(context, value) {\n  var inputs = this._getInputs(context);\n  inputs.unshift(value);\n  var out = this.setFn.apply(null, inputs);\n  for (var i in out) {\n    this.args[i].set(context, out[i]);\n  }\n};\n\nfunction SequenceExpression(args, afterSegments, meta) {\n  this.args = args;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n}\nSequenceExpression.prototype = Object.create(OperatorExpression.prototype);\nSequenceExpression.prototype.constructor = SequenceExpression;\nSequenceExpression.prototype.type = 'SequenceExpression';\nSequenceExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.args, this.afterSegments, this.meta);\n};\nSequenceExpression.prototype.name = ',';\nSequenceExpression.prototype.getFn = operatorFns.get[','];\nSequenceExpression.prototype.resolve = function(context) {\n  var last = this.args[this.args.length - 1];\n  return last.resolve(context);\n};\nSequenceExpression.prototype.dependencies = function(context, options) {\n  var dependencies = [];\n  for (var i = 0, len = this.args.length; i < len; i++) {\n    var argDependencies = this.args[i].dependencies(context, options);\n    for (var j = 0, jLen = argDependencies.length; j < jLen; j++) {\n      dependencies.push(argDependencies[j]);\n    }\n  }\n  return dependencies;\n};\n\n// For each method that takes a context argument, get the nearest parent view\n// context, then delegate methods to the inner expression\nfunction ViewParentExpression(expression, meta) {\n  this.expression = expression;\n  this.meta = meta;\n}\nViewParentExpression.prototype = Object.create(Expression.prototype);\nViewParentExpression.prototype.constructor = ViewParentExpression;\nViewParentExpression.prototype.type = 'ViewParentExpression';\nViewParentExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.meta);\n};\nViewParentExpression.prototype.get = function(context) {\n  var parentContext = context.forViewParent();\n  return this.expression.get(parentContext);\n};\nViewParentExpression.prototype.resolve = function(context) {\n  var parentContext = context.forViewParent();\n  return this.expression.resolve(parentContext);\n};\nViewParentExpression.prototype.dependencies = function(context, options) {\n  var parentContext = context.forViewParent();\n  return this.expression.dependencies(parentContext, options);\n};\nViewParentExpression.prototype.pathSegments = function(context) {\n  var parentContext = context.forViewParent();\n  return this.expression.pathSegments(parentContext);\n};\nViewParentExpression.prototype.set = function(context, value) {\n  var parentContext = context.forViewParent();\n  return this.expression.set(parentContext, value);\n};\n\nfunction ScopedModelExpression(expression, meta) {\n  this.expression = expression;\n  this.meta = meta;\n}\nScopedModelExpression.prototype = Object.create(Expression.prototype);\nScopedModelExpression.prototype.constructor = ScopedModelExpression;\nScopedModelExpression.prototype.type = 'ScopedModelExpression';\nScopedModelExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.meta);\n};\n// Return a scoped model instead of the value\nScopedModelExpression.prototype.get = function(context) {\n  var segments = this.pathSegments(context);\n  if (!segments) return;\n  return context.controller.model.scope(segments.join('.'));\n};\n// Delegate other methods to the inner expression\nScopedModelExpression.prototype.resolve = function(context) {\n  return this.expression.resolve(context);\n};\nScopedModelExpression.prototype.dependencies = function(context, options) {\n  return this.expression.dependencies(context, options);\n};\nScopedModelExpression.prototype.pathSegments = function(context) {\n  return this.expression.pathSegments(context);\n};\nScopedModelExpression.prototype.set = function(context, value) {\n  return this.expression.set(context, value);\n};\n\nfunction getDependencies(value, context, options) {\n  if (value instanceof Expression || value instanceof Template) {\n    return value.dependencies(context, options);\n  }\n}\n\nfunction appendDependency(dependencies, expression, context) {\n  var segments = expression.resolve(context);\n  if (!segments) return dependencies;\n  if (dependencies) {\n    dependencies.push(segments);\n    return dependencies;\n  }\n  return [segments];\n}\n\nfunction swapLastDependency(dependencies, expression, context) {\n  if (!expression.segments.length) {\n    return dependencies;\n  }\n  var segments = expression.resolve(context);\n  if (!segments) return dependencies;\n  if (dependencies) {\n    dependencies.pop();\n    dependencies.push(segments);\n    return dependencies;\n  }\n  return [segments];\n}\n",
    "// `-` and `+` can be either unary or binary, so all unary operators are\n// postfixed with `U` to differentiate\n\nexports.get = {\n  // Unary operators\n  '!U': function(value) {\n    return !value;\n  }\n, '-U': function(value) {\n    return -value;\n  }\n, '+U': function(value) {\n    return +value;\n  }\n, '~U': function(value) {\n    return ~value;\n  }\n, 'typeofU': function(value) {\n    return typeof value;\n  }\n  // Binary operators\n, '||': function(left, right) {\n    return left || right;\n  }\n, '&&': function(left, right) {\n    return left && right;\n  }\n, '|': function(left, right) {\n    return left | right;\n  }\n, '^': function(left, right) {\n    return left ^ right;\n  }\n, '&': function(left, right) {\n    return left & right;\n  }\n, '==': function(left, right) {\n    return left == right; // jshint ignore:line\n  }\n, '!=': function(left, right) {\n    return left != right; // jshint ignore:line\n  }\n, '===': function(left, right) {\n    return left === right;\n  }\n, '!==': function(left, right) {\n    return left !== right;\n  }\n, '<': function(left, right) {\n    return left < right;\n  }\n, '>': function(left, right) {\n    return left > right;\n  }\n, '<=': function(left, right) {\n    return left <= right;\n  }\n, '>=': function(left, right) {\n    return left >= right;\n  }\n, 'instanceof': function(left, right) {\n    return left instanceof right;\n  }\n, 'in': function(left, right) {\n    return left in right;\n  }\n, '<<': function(left, right) {\n    return left << right;\n  }\n, '>>': function(left, right) {\n    return left >> right;\n  }\n, '>>>': function(left, right) {\n    return left >>> right;\n  }\n, '+': function(left, right) {\n    return left + right;\n  }\n, '-': function(left, right) {\n    return left - right;\n  }\n, '*': function(left, right) {\n    return left * right;\n  }\n, '/': function(left, right) {\n    return left / right;\n  }\n, '%': function(left, right) {\n    return left % right;\n  }\n  // Conditional operator\n, '?': function(test, consequent, alternate) {\n    return (test) ? consequent : alternate;\n  }\n, // Sequence\n  ',': function() {\n    return arguments[arguments.length - 1];\n  }\n};\n\nexports.set = {\n  // Unary operators\n  '!U': function(value) {\n    return [!value];\n  }\n, '-U': function(value) {\n    return [-value];\n  }\n  // Binary operators\n, '==': function(value, left, right) {\n    if (value) return [right];\n  }\n, '===': function(value, left, right) {\n    if (value) return [right];\n  }\n, 'in': function(value, left, right) {\n    right[left] = true;\n    return {1: right};\n  }\n, '+': function(value, left, right) {\n    return [value - right];\n  }\n, '-': function(value, left, right) {\n    return [value + right];\n  }\n, '*': function(value, left, right) {\n    return [value / right];\n  }\n, '/': function(value, left, right) {\n    return [value * right];\n  }\n};\n",
    "var templates = require('./templates');\n\nexports.DependencyOptions = DependencyOptions;\n\nfunction DependencyOptions(options) {\n  this.setIgnoreTemplate(options && options.ignoreTemplate);\n}\nDependencyOptions.shouldIgnoreTemplate = function(template, options) {\n  return (options) ? options.ignoreTemplate === template : false;\n};\nDependencyOptions.prototype.setIgnoreTemplate = function(template) {\n  while (template instanceof templates.ContextClosure) {\n    template = template.template;\n  }\n  this.ignoreTemplate = template;\n};\n",
    "var saddle = require('saddle');\nvar serializeObject = require('serialize-object');\nvar DependencyOptions = require('./options').DependencyOptions;\nvar util = require('./util');\nvar concat = util.concat;\nvar hasKeys = util.hasKeys;\nvar traverseAndCreate = util.traverseAndCreate;\n\n(function() {\n  for (var key in saddle) {\n    exports[key] = saddle[key];\n  }\n})();\n\nexports.Marker = Marker;\nexports.View = View;\nexports.ViewInstance = ViewInstance;\nexports.DynamicViewInstance = DynamicViewInstance;\nexports.ViewParent = ViewParent;\nexports.ContextClosure = ContextClosure;\n\nexports.Views = Views;\n\nexports.MarkupHook = MarkupHook;\nexports.ElementOn = ElementOn;\nexports.ComponentOn = ComponentOn;\nexports.AsProperty = AsProperty;\nexports.AsObject = AsObject;\nexports.AsObjectComponent = AsObjectComponent;\nexports.AsArray = AsArray;\nexports.AsArrayComponent = AsArrayComponent;\n\nexports.emptyTemplate = new saddle.Template([]);\n\n// Add ::isUnbound to Template && Binding\nsaddle.Template.prototype.isUnbound = function(context) {\n  return context.unbound;\n};\nsaddle.Binding.prototype.isUnbound = function() {\n  return this.template.expression.isUnbound(this.context);\n};\n\n// Add Template::resolve\nsaddle.Template.prototype.resolve = function() {};\n\n// The Template::dependencies method is specific to how Derby bindings work,\n// so extend all of the Saddle Template types here\nsaddle.Template.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  return concatArrayDependencies(null, this.content, context, options);\n};\nsaddle.Doctype.prototype.dependencies = function() {};\nsaddle.Text.prototype.dependencies = function() {};\nsaddle.DynamicText.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  return getDependencies(this.expression, context, options);\n};\nsaddle.Comment.prototype.dependencies = function() {};\nsaddle.DynamicComment.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  return getDependencies(this.expression, context, options);\n};\nsaddle.Html.prototype.dependencies = function() {};\nsaddle.DynamicHtml.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  return getDependencies(this.expression, context, options);\n};\nsaddle.Element.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var dependencies = concatMapDependencies(null, this.attributes, context, options);\n  if (!this.content) return dependencies;\n  return concatArrayDependencies(dependencies, this.content, context, options);\n};\nsaddle.DynamicElement.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var dependencies = saddle.Element.prototype.dependencies(context, options);\n  return concatDependencies(dependencies, this.tagName, context, options);\n};\nsaddle.Block.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var dependencies = (this.expression.meta && this.expression.meta.blockType === 'on') ?\n    getDependencies(this.expression, context, options) : null;\n  var blockContext = context.child(this.expression);\n  return concatArrayDependencies(dependencies, this.content, blockContext, options);\n};\nsaddle.ConditionalBlock.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var condition = this.getCondition(context);\n  if (condition == null) {\n    return getDependencies(this.expressions[0], context, options);\n  }\n  var dependencies = concatSubArrayDependencies(null, this.expressions, context, options, condition);\n  var expression = this.expressions[condition];\n  var content = this.contents[condition];\n  var blockContext = context.child(expression);\n  return concatArrayDependencies(dependencies, content, blockContext, options);\n};\nsaddle.EachBlock.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var dependencies = getDependencies(this.expression, context, options);\n  var items = this.expression.get(context);\n  if (items && items.length) {\n    for (var i = 0; i < items.length; i++) {\n      var itemContext = context.eachChild(this.expression, i);\n      dependencies = concatArrayDependencies(dependencies, this.content, itemContext, options);\n    }\n  } else if (this.elseContent) {\n    dependencies = concatArrayDependencies(dependencies, this.elseContent, context, options);\n  }\n  return dependencies;\n};\nsaddle.Attribute.prototype.dependencies = function() {};\nsaddle.DynamicAttribute.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  return getDependencies(this.expression, context, options);\n};\n\nfunction concatSubArrayDependencies(dependencies, expressions, context, options, end) {\n  for (var i = 0; i <= end; i++) {\n    dependencies = concatDependencies(dependencies, expressions[i], context, options);\n  }\n  return dependencies;\n}\nfunction concatArrayDependencies(dependencies, expressions, context, options) {\n  for (var i = 0; i < expressions.length; i++) {\n    dependencies = concatDependencies(dependencies, expressions[i], context, options);\n  }\n  return dependencies;\n}\nfunction concatMapDependencies(dependencies, expressions, context, options) {\n  for (var key in expressions) {\n    dependencies = concatDependencies(dependencies, expressions[key], context, options);\n  }\n  return dependencies;\n}\nfunction concatDependencies(dependencies, expression, context, options) {\n  var expressionDependencies = getDependencies(expression, context, options);\n  return concat(dependencies, expressionDependencies);\n}\nfunction getDependencies(expression, context, options) {\n  return expression.dependencies(context, options);\n}\n\nvar markerHooks = [{\n  emit: function(context, node) {\n    node.$component = context.controller;\n    context.controller.markerNode = node;\n  }\n}];\nfunction Marker(data) {\n  saddle.Comment.call(this, data, markerHooks);\n}\nMarker.prototype = Object.create(saddle.Comment.prototype);\nMarker.prototype.constructor = Marker;\nMarker.prototype.type = 'Marker';\nMarker.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data);\n};\nMarker.prototype.get = function() {\n  return '';\n};\n\nfunction ViewAttributesMap(source) {\n  var items = source.split(/\\s+/);\n  for (var i = 0, len = items.length; i < len; i++) {\n    this[items[i]] = true;\n  }\n}\nfunction ViewArraysMap(source) {\n  var items = source.split(/\\s+/);\n  for (var i = 0, len = items.length; i < len; i++) {\n    var item = items[i].split('/');\n    this[item[0]] = item[1] || item[0];\n  }\n}\nfunction View(views, name, source, options) {\n  this.views = views;\n  this.name = name;\n  this.source = source;\n  this.options = options;\n\n  var nameSegments = (this.name || '').split(':');\n  var lastSegment = nameSegments.pop();\n  this.namespace = nameSegments.join(':');\n  this.registeredName = (lastSegment === 'index') ? this.namespace : this.name;\n\n  this.attributesMap = options && options.attributes &&\n    new ViewAttributesMap(options.attributes);\n  this.arraysMap = options && options.arrays &&\n    new ViewArraysMap(options.arrays);\n  // The empty string is considered true for easier HTML attribute parsing\n  this.unminified = options && (options.unminified || options.unminified === '');\n  this.string = options && (options.string || options.string === '');\n  this.literal = options && (options.literal || options.literal === '');\n  this.template = null;\n  this.componentFactory = null;\n  this.fromSerialized = false;\n}\nView.prototype = Object.create(saddle.Template.prototype);\nView.prototype.constructor = View;\nView.prototype.type = 'View';\nView.prototype.serialize = function() {\n  return null;\n};\nView.prototype._isComponent = function(context) {\n  if (!this.componentFactory) return false;\n  if (context.attributes && context.attributes.extend) return false;\n  return true;\n};\nView.prototype._initComponent = function(context) {\n  return (this._isComponent(context)) ?\n    this.componentFactory.init(context) : context;\n};\nView.prototype._queueCreate = function(context, viewContext) {\n  if (this._isComponent(context)) {\n    var componentFactory = this.componentFactory;\n    context.queue(function queuedCreate() {\n      componentFactory.create(viewContext);\n    });\n\n    if (!context.hooks) return;\n    context.queue(function queuedComponentHooks() {\n      // Kick off hooks if view instance specified `on` or `as` attributes\n      for (var i = 0, len = context.hooks.length; i < len; i++) {\n        context.hooks[i].emit(context, viewContext.controller);\n      }\n    });\n  }\n};\nView.prototype.get = function(context, unescaped) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  return template.get(viewContext, unescaped);\n};\nView.prototype.getFragment = function(context, binding) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  var fragment = template.getFragment(viewContext, binding);\n  this._queueCreate(context, viewContext);\n  return fragment;\n};\nView.prototype.appendTo = function(parent, context) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  template.appendTo(parent, viewContext);\n  this._queueCreate(context, viewContext);\n};\nView.prototype.attachTo = function(parent, node, context) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  var node = template.attachTo(parent, node, viewContext);\n  this._queueCreate(context, viewContext);\n  return node;\n};\nView.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var template = this.template || this.parse();\n  // We can't figure out relative path dependencies within a component without\n  // rendering it, because each component instance's scope is dynamically set\n  // based on its unique `id` property. To represent this, set the context\n  // controller to `null`.\n  //\n  // Under normal rendering conditions, contexts should always have reference\n  // to a controller. Expression::get() methods use the reference to\n  // `context.controller.model.data` to lookup values, and paths are resolved\n  // based on `context.controller.model._scope`.\n  //\n  // To handle this, Expression methods guard against a null controller by not\n  // returning any dependencies for model paths. In addition, they return\n  // `undefined` from get, which affect dependencies computed for\n  // ConditionalBlock and EachBlock, as their dependencies will differ based\n  // on the value of model data.\n  //\n  // TODO: This likely under-estimates the true dependencies within a\n  // template. However, to provide a more complete view of dependencies, we'd\n  // need information we only have at render time, namely, the scope and data\n  // within the component model. This may indicate that Derby should use a\n  // more Functional Reactive Programming (FRP)-like approach of having\n  // dependencies be returned from getFragment and attach methods along with\n  // DOM nodes rather than computing dependencies separately from rendering.\n  var viewContext = (this._isComponent(context)) ?\n    context.componentChild(null) : context;\n  return template.dependencies(viewContext, options);\n};\nView.prototype.parse = function() {\n  this._parse();\n  if (this.componentFactory) {\n    var marker = new Marker(this.name);\n    this.template.content.unshift(marker);\n  }\n  return this.template;\n};\n// View.prototype._parse is defined in parsing.js, so that it doesn't have to\n// be included in the client if templates are all parsed server-side\nView.prototype._parse = function() {\n  throw new Error('View parsing not available');\n};\n\nfunction ViewInstance(name, attributes, hooks, initHooks) {\n  this.name = name;\n  this.attributes = attributes;\n  this.hooks = hooks;\n  this.initHooks = initHooks;\n  this.view = null;\n}\nViewInstance.prototype = Object.create(saddle.Template.prototype);\nViewInstance.prototype.constructor = ViewInstance;\nViewInstance.prototype.type = 'ViewInstance';\nViewInstance.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.attributes, this.hooks, this.initHooks);\n};\nViewInstance.prototype.get = function(context, unescaped) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.get(viewContext, unescaped);\n};\nViewInstance.prototype.getFragment = function(context, binding) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.getFragment(viewContext, binding);\n};\nViewInstance.prototype.appendTo = function(parent, context) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  view.appendTo(parent, viewContext);\n};\nViewInstance.prototype.attachTo = function(parent, node, context) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.attachTo(parent, node, viewContext);\n};\nViewInstance.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.dependencies(viewContext, options);\n};\nViewInstance.prototype._find = function(context) {\n  if (this.view) return this.view;\n  var contextView = context.getView();\n  var namespace = contextView && contextView.namespace;\n  this.view = context.meta.views.find(this.name, namespace);\n  if (!this.view) {\n    var message = context.meta.views.findErrorMessage(this.name, contextView);\n    throw new Error(message);\n  }\n  return this.view;\n};\n\nfunction DynamicViewInstance(nameExpression, attributes, hooks, initHooks) {\n  this.nameExpression = nameExpression;\n  this.attributes = attributes;\n  this.hooks = hooks;\n  this.initHooks = initHooks;\n}\nDynamicViewInstance.prototype = Object.create(ViewInstance.prototype);\nDynamicViewInstance.prototype.constructor = DynamicViewInstance;\nDynamicViewInstance.prototype.type = 'DynamicViewInstance';\nDynamicViewInstance.prototype.serialize = function() {\n  return serializeObject.instance(this, this.nameExpression, this.attributes, this.hooks, this.initHooks);\n};\nDynamicViewInstance.prototype._find = function(context) {\n  var name = this.nameExpression.get(context);\n  var contextView = context.getView();\n  var namespace = contextView && contextView.namespace;\n  var view = name && context.meta.views.find(name, namespace);\n  return view || exports.emptyTemplate;\n};\nDynamicViewInstance.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var nameDependencies = this.nameExpression.dependencies(context);\n  var viewDependencies = ViewInstance.prototype.dependencies.call(this, context, options);\n  return concat(nameDependencies, viewDependencies);\n};\n\n// Without a ContextClosure, ViewParent will return the nearest context that\n// is the parent of a view instance. When a context with a `closure` property\n// is encountered first, ViewParent will find the specific referenced context,\n// even if it is further up the context hierarchy.\nfunction ViewParent(template) {\n  this.template = template;\n}\nViewParent.prototype = Object.create(saddle.Template.prototype);\nViewParent.prototype.constructor = ViewParent;\nViewParent.prototype.type = 'ViewParent';\nViewParent.prototype.serialize = function() {\n  return serializeObject.instance(this, this.template);\n};\nViewParent.prototype.get = function(context, unescaped) {\n  var parentContext = context.forViewParent();\n  return this.template.get(parentContext, unescaped);\n};\nViewParent.prototype.getFragment = function(context, binding) {\n  var parentContext = context.forViewParent();\n  return this.template.getFragment(parentContext, binding);\n};\nViewParent.prototype.appendTo = function(parent, context) {\n  var parentContext = context.forViewParent();\n  this.template.appendTo(parent, parentContext);\n};\nViewParent.prototype.attachTo = function(parent, node, context) {\n  var parentContext = context.forViewParent();\n  return this.template.attachTo(parent, node, parentContext);\n};\nViewParent.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var parentContext = context.forViewParent();\n  return this.template.dependencies(parentContext, options);\n};\n\n// At render time, this template creates a context child and sets its\n// `closure` property to a fixed reference. It is used in combination with\n// ViewParent in order to control which context is returned.\n//\n// Instances of this template cannot be serialized. It is intended for use\n// dynamically during rendering only.\nfunction ContextClosure(template, context) {\n  this.template = template;\n  this.context = context;\n}\nContextClosure.prototype = Object.create(saddle.Template.prototype);\nContextClosure.prototype.constructor = ContextClosure;\nContextClosure.prototype.serialize = function() {\n  throw new Error('ContextClosure cannot be serialized');\n};\nContextClosure.prototype.get = function(context, unescaped) {\n  var closureContext = context.closureChild(this.context);\n  return this.template.get(closureContext, unescaped);\n};\nContextClosure.prototype.getFragment = function(context, binding) {\n  var closureContext = context.closureChild(this.context);\n  return this.template.getFragment(closureContext, binding);\n};\nContextClosure.prototype.appendTo = function(parent, context) {\n  var closureContext = context.closureChild(this.context);\n  this.template.appendTo(parent, closureContext);\n};\nContextClosure.prototype.attachTo = function(parent, node, context) {\n  var closureContext = context.closureChild(this.context);\n  return this.template.attachTo(parent, node, closureContext);\n};\nContextClosure.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this.template, options)) return;\n  var closureContext = context.closureChild(this.context);\n  return this.template.dependencies(closureContext, options);\n};\nContextClosure.prototype.equals = function(other) {\n  return (other instanceof ContextClosure) &&\n    (this.context === other.context) &&\n    (this.template.equals(other.template));\n};\n\nfunction ViewsMap() {}\nfunction Views() {\n  this.nameMap = new ViewsMap();\n  this.tagMap = new ViewsMap();\n  // TODO: elementMap is deprecated and should be removed with Derby 0.6.0\n  this.elementMap = this.tagMap;\n}\nViews.prototype.find = function(name, namespace) {\n  var map = this.nameMap;\n\n  // Exact match lookup\n  var exactName = (namespace) ? namespace + ':' + name : name;\n  var match = map[exactName];\n  if (match) return match;\n\n  // Relative lookup\n  var segments = name.split(':');\n  var segmentsDepth = segments.length;\n  if (namespace) segments = namespace.split(':').concat(segments);\n  // Iterate through segments, leaving the `segmentsDepth` segments and\n  // removing the second to `segmentsDepth` segment to traverse up the\n  // namespaces. Decrease `segmentsDepth` if not found and repeat again.\n  while (segmentsDepth > 0) {\n    var testSegments = segments.slice();\n    while (testSegments.length > segmentsDepth) {\n      testSegments.splice(-1 - segmentsDepth, 1);\n      var testName = testSegments.join(':');\n      var match = map[testName];\n      if (match) return match;\n    }\n    segmentsDepth--;\n  }\n};\nViews.prototype.register = function(name, source, options) {\n  var mapName = name.replace(/:index$/, '');\n  var view = this.nameMap[mapName];\n  if (view) {\n    // Recreate the view if it already exists. We re-apply the constructor\n    // instead of creating a new view object so that references to object\n    // can be cached after finding the first time\n    var componentFactory = view.componentFactory;\n    View.call(view, this, name, source, options);\n    view.componentFactory = componentFactory;\n  } else {\n    view = new View(this, name, source, options);\n  }\n  this.nameMap[mapName] = view;\n  // TODO: element is deprecated and should be removed with Derby 0.6.0\n  var tagName = options && (options.tag || options.element);\n  if (tagName) this.tagMap[tagName] = view;\n  return view;\n};\nViews.prototype.deserialize = function(items) {\n  for (var i = 0; i < items.length; i++) {\n    var item = items[i];\n    var setTemplate = item[0];\n    var name = item[1];\n    var source = item[2];\n    var options = item[3];\n    var view = this.register(name, source, options);\n    view.parse = setTemplate;\n    view.fromSerialized = true;\n  }\n};\nViews.prototype.serialize = function(options) {\n  var forServer = options && options.server;\n  var minify = options && options.minify;\n  var items = [];\n  for (var name in this.nameMap) {\n    var view = this.nameMap[name];\n    var template = view.template || view.parse();\n    if (!forServer && view.options) {\n      // Do not serialize views with the `serverOnly` option, except when\n      // serializing for a server script\n      if (view.options.serverOnly) continue;\n      // For views with the `server` option, serialize them with a blank\n      // template body. This allows them to be used from other views on the\n      // browser, but they will output nothing on the browser\n      if (view.options.server) template = exports.emptyTemplate;\n    }\n    // Serializing views as a function allows them to be constructed lazily upon\n    // first use. This can improve initial load times of the application when\n    // there are many views\n    items.push(\n      '[function(){return this.template=' +\n        template.serialize() + '},' +\n        serializeObject.args([\n          view.name,\n          (minify) ? null : view.source,\n          (hasKeys(view.options)) ? view.options : null\n        ]) +\n      ']'\n    );\n  }\n  return 'function(derbyTemplates, views){' +\n    'var expressions = derbyTemplates.expressions,' +\n    'templates = derbyTemplates.templates;' +\n    'views.deserialize([' + items.join(',') + '])}';\n};\nViews.prototype.findErrorMessage = function(name, contextView) {\n  var names = Object.keys(this.nameMap);\n  var message = 'Cannot find view \"' + name + '\" in' +\n    [''].concat(names).join('\\n  ') + '\\n';\n  if (contextView) {\n    message += '\\nWithin template \"' + contextView.name + '\":\\n' + contextView.source;\n  }\n  return message;\n};\n\n\nfunction MarkupHook() {}\nMarkupHook.prototype.module = saddle.Template.prototype.module;\n\nfunction ElementOn(name, expression) {\n  this.name = name;\n  this.expression = expression;\n}\nElementOn.prototype = Object.create(MarkupHook.prototype);\nElementOn.prototype.constructor = ElementOn;\nElementOn.prototype.type = 'ElementOn';\nElementOn.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.expression);\n};\nElementOn.prototype.emit = function(context, element) {\n  var elementOn = this;\n  if (this.name === 'create') {\n    this.apply(context, element);\n\n  } else if (this.name === 'destroy') {\n    var destroyListeners = element.$destroyListeners || (element.$destroyListeners = []);\n    destroyListeners.push(function elementOnDestroy() {\n      elementOn.apply(context, element);\n    });\n\n  } else {\n    element.addEventListener(this.name, function elementOnListener(event) {\n      return elementOn.apply(context, element, event);\n    }, false);\n  }\n};\nElementOn.prototype.apply = function(context, element, event) {\n  var modelData = context.controller.model.data;\n  modelData.$event = event;\n  modelData.$element = element;\n  var out = this.expression.apply(context);\n  delete modelData.$event;\n  delete modelData.$element;\n  return out;\n};\n\nfunction ComponentOn(name, expression) {\n  this.name = name;\n  this.expression = expression;\n}\nComponentOn.prototype = Object.create(MarkupHook.prototype);\nComponentOn.prototype.constructor = ComponentOn;\nComponentOn.prototype.type = 'ComponentOn';\nComponentOn.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.expression);\n};\nComponentOn.prototype.emit = function(context, component) {\n  var expression = this.expression;\n  component.on(this.name, function componentOnListener() {\n    var args = arguments.length && Array.prototype.slice.call(arguments);\n    return expression.apply(context, args);\n  });\n};\n\nfunction AsProperty(segments) {\n  this.segments = segments;\n  this.lastSegment = segments.pop();\n}\nAsProperty.prototype = Object.create(MarkupHook.prototype);\nAsProperty.prototype.constructor = AsProperty;\nAsProperty.prototype.type = 'AsProperty';\nAsProperty.prototype.serialize = function() {\n  var segments = this.segments.concat(this.lastSegment);\n  return serializeObject.instance(this, segments);\n};\nAsProperty.prototype.emit = function(context, target) {\n  var node = traverseAndCreate(context.controller, this.segments);\n  node[this.lastSegment] = target;\n};\n\nfunction AsObject(segments, keyExpression) {\n  AsProperty.call(this, segments);\n  this.keyExpression = keyExpression;\n}\nAsObject.prototype = Object.create(AsProperty.prototype);\nAsObject.prototype.constructor = AsObject;\nAsObject.prototype.type = 'AsObject';\nAsObject.prototype.serialize = function() {\n  var segments = this.segments.concat(this.lastSegment);\n  return serializeObject.instance(this, segments, this.keyExpression);\n};\nAsObject.prototype.emit = function(context, target) {\n  var node = traverseAndCreate(context.controller, this.segments);\n  var object = node[this.lastSegment] || (node[this.lastSegment] = {});\n  var key = this.keyExpression.get(context);\n  object[key] = target;\n  this.addListeners(target, object, key);\n};\nAsObject.prototype.addListeners = function(target, object, key) {\n  this.addDestroyListener(target, function asObjectDestroy() {\n    delete object[key];\n  });\n};\nAsObject.prototype.addDestroyListener = function(target, listener) {\n  var listeners = target.$destroyListeners || (target.$destroyListeners = []);\n  listeners.push(listener);\n};\n\nfunction AsObjectComponent(segments, keyExpression) {\n  AsObject.call(this, segments, keyExpression);\n}\nAsObjectComponent.prototype = Object.create(AsObject.prototype);\nAsObjectComponent.prototype.constructor = AsObjectComponent;\nAsObjectComponent.prototype.type = 'AsObjectComponent';\nAsObjectComponent.prototype.addDestroyListener = function(target, listener) {\n  target.on('destroy', listener);\n};\n\nfunction AsArray(segments) {\n  AsProperty.call(this, segments);\n}\nAsArray.prototype = Object.create(AsProperty.prototype);\nAsArray.prototype.constructor = AsArray;\nAsArray.prototype.type = 'AsArray';\nAsArray.prototype.emit = function(context, target) {\n  var node = traverseAndCreate(context.controller, this.segments);\n  var array = node[this.lastSegment] || (node[this.lastSegment] = []);\n\n  // Iterate backwards, since rendering will usually append\n  for (var i = array.length; i--;) {\n    var item = array[i];\n    // Don't add an item if already in the array\n    if (item === target) return;\n    var mask = this.comparePosition(target, item);\n    // If the emitted target is after the current item in the document,\n    // insert it next in the array\n    // Node.DOCUMENT_POSITION_FOLLOWING = 4\n    if (mask & 4) {\n      array.splice(i + 1, 0, target);\n      this.addListeners(target, array);\n      return;\n    }\n  }\n  // Add to the beginning if before all items\n  array.unshift(target);\n  this.addListeners(target, array);\n};\nAsArray.prototype.addListeners = function(target, array) {\n  this.addDestroyListener(target, function asArrayDestroy() {\n    var index = array.indexOf(target);\n    if (index !== -1) array.splice(index, 1);\n  });\n};\nAsArray.prototype.comparePosition = function(target, item) {\n  return item.compareDocumentPosition(target);\n};\nAsArray.prototype.addDestroyListener = AsObject.prototype.addDestroyListener;\n\nfunction AsArrayComponent(segments) {\n  AsArray.call(this, segments);\n}\nAsArrayComponent.prototype = Object.create(AsArray.prototype);\nAsArrayComponent.prototype.constructor = AsArrayComponent;\nAsArrayComponent.prototype.type = 'AsArrayComponent';\nAsArrayComponent.prototype.comparePosition = function(target, item) {\n  return item.markerNode.compareDocumentPosition(target.markerNode);\n};\nAsArrayComponent.prototype.addDestroyListener = AsObjectComponent.prototype.addDestroyListener;\n",
    "\nexports.concat = function(a, b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a.concat(b);\n};\n\nexports.hasKeys = function(value) {\n  if (!value) return false;\n  for (var key in value) {\n    return true;\n  }\n  return false;\n};\n\nexports.traverseAndCreate = function(node, segments) {\n  var len = segments.length;\n  if (!len) return node;\n  for (var i = 0; i < len; i++) {\n    var segment = segments[i];\n    node = node[segment] || (node[segment] = {});\n  }\n  return node;\n};\n",
    "/*\n * App.js\n *\n * Provides the glue between views, controllers, and routes for an\n * application's functionality. Apps are responsible for creating pages.\n *\n */\n\nvar path = require('path');\nvar EventEmitter = require('events').EventEmitter;\nvar tracks = require('tracks');\nvar util = require('racer/lib/util');\nvar derbyTemplates = require('derby-templates');\nvar templates = derbyTemplates.templates;\nvar components = require('./components');\nvar PageBase = require('./Page');\nvar serializedViews = require('./_views');\n\nmodule.exports = App;\n\nfunction App(derby, name, filename, options) {\n  EventEmitter.call(this);\n  this.derby = derby;\n  this.name = name;\n  this.filename = filename;\n  this.scriptHash = '{{DERBY_SCRIPT_HASH}}';\n  this.bundledAt = '{{DERBY_BUNDLED_AT}}';\n  this.Page = createAppPage(derby);\n  this.proto = this.Page.prototype;\n  this.views = new templates.Views();\n  this.tracksRoutes = tracks.setup(this);\n  this.model = null;\n  this.page = null;\n  this._pendingComponentMap = {};\n  this._init(options);\n}\n\nfunction createAppPage(derby) {\n  var Page = (derby && derby.Page) || PageBase;\n  // Inherit from Page/PageForServer so that we can add controller functions as prototype\n  // methods on this app's pages\n  function AppPage() {\n    Page.apply(this, arguments);\n  }\n  AppPage.prototype = Object.create(Page.prototype);\n  return AppPage;\n}\n\nutil.mergeInto(App.prototype, EventEmitter.prototype);\n\n// Overriden on server\nApp.prototype._init = function() {\n  this._waitForAttach = true;\n  this._cancelAttach = false;\n  this.model = new this.derby.Model();\n  serializedViews(derbyTemplates, this.views);\n  // Must init async so that app.on('model') listeners can be added.\n  // Must also wait for content ready so that bundle is fully downloaded.\n  this._contentReady();\n};\nApp.prototype._finishInit = function() {\n  var script = this._getScript();\n  var data = JSON.parse(script.nextSibling.innerHTML);\n  this.model.createConnection(data);\n  this.emit('model', this.model);\n  util.isProduction = data.nodeEnv === 'production';\n  if (!util.isProduction) this._autoRefresh();\n  this.model.unbundle(data);\n  var page = this.createPage();\n  page.params = this.model.get('$render.params');\n  this.emit('ready', page);\n  this._waitForAttach = false;\n  // Instead of attaching, do a route and render if a link was clicked before\n  // the page finished attaching\n  if (this._cancelAttach) {\n    this.history.refresh();\n    return;\n  }\n  // Since an attachment failure is *fatal* and could happen as a result of a\n  // browser extension like AdBlock, an invalid template, or a small bug in\n  // Derby or Saddle, re-render from scratch on production failures\n  if (util.isProduction) {\n    try {\n      page.attach();\n    } catch (err) {\n      this.history.refresh();\n      console.warn('attachment error', err.stack);\n    }\n  } else {\n    page.attach();\n  }\n  this.emit('load', page);\n};\n// Modified from: https://github.com/addyosmani/jquery.parts/blob/master/jquery.documentReady.js\nApp.prototype._contentReady = function() {\n  // Is the DOM ready to be used? Set to true once it occurs.\n  var isReady = false;\n  var app = this;\n\n  // The ready event handler\n  function onDOMContentLoaded() {\n    if (document.addEventListener) {\n      document.removeEventListener('DOMContentLoaded', onDOMContentLoaded, false);\n    } else {\n      // we're here because readyState !== 'loading' in oldIE\n      // which is good enough for us to call the dom ready!\n      document.detachEvent('onreadystatechange', onDOMContentLoaded);\n    }\n    onDOMReady();\n  }\n\n  // Handle when the DOM is ready\n  function onDOMReady() {\n    // Make sure that the DOM is not already loaded\n    if (isReady) return;\n    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n    if (!document.body) return setTimeout(onDOMReady, 0);\n    // Remember that the DOM is ready\n    isReady = true;\n    // Make sure this is always async and then finishin init\n    setTimeout(function() {\n      app._finishInit();\n    }, 0);\n  }\n\n  // The DOM ready check for Internet Explorer\n  function doScrollCheck() {\n    if (isReady) return;\n    try {\n      // If IE is used, use the trick by Diego Perini\n      // http://javascript.nwbox.com/IEContentLoaded/\n      document.documentElement.doScroll('left');\n    } catch (err) {\n      setTimeout(doScrollCheck, 0);\n      return;\n    }\n    // and execute any waiting functions\n    onDOMReady();\n  }\n\n  // Catch cases where called after the browser event has already occurred.\n  if (document.readyState !== 'loading') return onDOMReady();\n\n  // Mozilla, Opera and webkit nightlies currently support this event\n  if (document.addEventListener) {\n    // Use the handy event callback\n    document.addEventListener('DOMContentLoaded', onDOMContentLoaded, false);\n    // A fallback to window.onload, that will always work\n    window.addEventListener('load', onDOMContentLoaded, false);\n    // If IE event model is used\n  } else if (document.attachEvent) {\n    // ensure firing before onload,\n    // maybe late but safe also for iframes\n    document.attachEvent('onreadystatechange', onDOMContentLoaded);\n    // A fallback to window.onload, that will always work\n    window.attachEvent('onload', onDOMContentLoaded);\n    // If IE and not a frame\n    // continually check to see if the document is ready\n    var toplevel;\n    try {\n      toplevel = window.frameElement == null;\n    } catch (err) {}\n    if (document.documentElement.doScroll && toplevel) {\n      doScrollCheck();\n    }\n  }\n};\n\nApp.prototype._getScript = function() {\n  return document.querySelector('script[data-derby-app]');\n};\n\nApp.prototype.use = util.use;\nApp.prototype.serverUse = util.serverUse;\n\nApp.prototype.loadViews = function() {};\n\nApp.prototype.loadStyles = function() {};\n\n// This function is overriden by requiring 'derby/parsing'\nApp.prototype.addViews = function() {\n  throw new Error(\n    'Parsing not available. Registering a view from source should not be used ' +\n    'in application code. Instead, specify a filename with view.file.'\n  );\n};\n\nApp.prototype.component = function(name, constructor, isDependency) {\n  if (typeof name === 'function') {\n    constructor = name;\n    name = null;\n  }\n  if (typeof constructor !== 'function') {\n    throw new Error('Missing component constructor argument');\n  }\n\n  var viewProp = constructor.view;\n  var viewIs, viewFilename, viewSource, viewDependencies;\n  // Always using an object for the static `view` property is preferred\n  if (viewProp && typeof viewProp === 'object') {\n    viewIs = viewProp.is;\n    viewFilename = viewProp.file;\n    viewSource = viewProp.source;\n    viewDependencies = viewProp.dependencies;\n  } else {\n    // Ignore other properties when `view` is an object. It is possible that\n    // properties could be inherited from a parent component when extending it.\n    //\n    // DEPRECATED: constructor.prototype.name and constructor.prototype.view\n    // use the equivalent static properties instead\n    viewIs = constructor.is || constructor.prototype.name;\n    viewFilename = constructor.view || constructor.prototype.view;\n  }\n  var viewName = name || viewIs ||\n    (viewFilename && path.basename(viewFilename, '.html'));\n\n  if (!viewName) {\n    throw new Error('No view specified for component');\n  }\n  if (viewFilename && viewSource) {\n    throw new Error('Component may not specify both a view file and source');\n  }\n\n  // TODO: DRY. This is copy-pasted from derby-templates\n  var mapName = viewName.replace(/:index$/, '');\n  var currentView = this.views.nameMap[mapName];\n  var currentConstructor = (currentView && currentView.componentFactory) ?\n    currentView.componentFactory.constructor :\n    this._pendingComponentMap[mapName];\n\n  // Avoid registering the same component twice; we want to avoid the overhead\n  // of loading view files from disk again. This is also what prevents\n  // circular dependencies from infinite looping\n  if (currentConstructor === constructor) return;\n\n  // Calling app.component() overrides existing views or components. Prevent\n  // dependencies from doing this without warning\n  if (isDependency && currentView && !currentView.fromSerialized) {\n    throw new Error('Dependencies cannot override existing views. Already registered \"' + viewName + '\"');\n  }\n\n  // This map is used to prevent infinite loops from circular dependencies\n  this._pendingComponentMap[mapName] = constructor;\n\n  // Recursively register component dependencies\n  if (viewDependencies) {\n    for (var i = 0; i < viewDependencies.length; i++) {\n      var dependency = viewDependencies[i];\n      if (Array.isArray(dependency)) {\n        this.component(dependency[0], dependency[1], true);\n      } else {\n        this.component(null, dependency, true);\n      }\n    }\n  }\n\n  // Register or find views specified by the component\n  var view;\n  if (viewFilename) {\n    this.loadViews(viewFilename, viewName);\n    view = this.views.find(viewName);\n\n  } else if (viewSource) {\n    this.addViews(viewSource, viewName);\n    view = this.views.find(viewName);\n\n  } else if (name) {\n    view = this.views.find(viewName);\n\n  } else {\n    view = this.views.register(viewName, '');\n  }\n  if (!view) {\n    var message = this.views.findErrorMessage(viewName);\n    throw new Error(message);\n  }\n\n  // Inherit from Component\n  components.extendComponent(constructor);\n  // Associate the appropriate view with the component constructor\n  view.componentFactory = components.createFactory(constructor);\n\n  delete this._pendingComponentMap[mapName];\n\n  // Make chainable\n  return this;\n};\n\nApp.prototype.createPage = function() {\n  if (this.page) {\n    this.emit('destroyPage', this.page);\n    this.page.destroy();\n  }\n  var page = new this.Page(this, this.model);\n  this.page = page;\n  return page;\n};\n\nApp.prototype.onRoute = function(callback, page, next, done) {\n  if (this._waitForAttach) {\n    // Cancel any routing before the initial page attachment. Instead, do a\n    // render once derby is ready\n    this._cancelAttach = true;\n    return;\n  }\n  this.emit('route', page);\n  // HACK: To update render in transitional routes\n  page.model.set('$render.params', page.params);\n  page.model.set('$render.url', page.params.url);\n  page.model.set('$render.query', page.params.query);\n  // If transitional\n  if (done) {\n    var app = this;\n    var _done = function() {\n      app.emit('routeDone', page, 'transition');\n      done();\n    };\n    callback.call(page, page, page.model, page.params, next, _done);\n    return;\n  }\n  callback.call(page, page, page.model, page.params, next);\n};\n\nApp.prototype._autoRefresh = function() {\n  var app = this;\n  var connection = this.model.connection;\n  connection.on('connected', function() {\n    connection.send({\n      derby: 'app',\n      name: app.name,\n      hash: app.scriptHash\n    });\n  });\n  connection.on('receive', function(request) {\n    if (request.data.derby) {\n      var message = request.data;\n      request.data = null;\n      app._handleMessage(message.derby, message);\n    }\n  });\n};\n\nApp.prototype._handleMessage = function(action, message) {\n  if (action === 'refreshViews') {\n    var fn = new Function('return ' + message.views)(); // jshint ignore:line\n    fn(derbyTemplates, this.views);\n    var ns = this.model.get('$render.ns');\n    this.page.render(ns);\n\n  } else if (action === 'refreshStyles') {\n    var styleElement = document.querySelector('style[data-filename=\"' +\n      message.filename + '\"]');\n    if (styleElement) styleElement.innerHTML = message.css;\n\n  } else if (action === 'reload') {\n    this.model.whenNothingPending(function() {\n      window.location = window.location;\n    });\n  }\n};\n",
    "var EventEmitter = require('events').EventEmitter;\nvar util = require('racer/lib/util');\nvar Dom = require('./Dom');\n\nmodule.exports = Controller;\n\nfunction Controller(app, page, model) {\n  EventEmitter.call(this);\n  this.dom = new Dom(this);\n  this.app = app;\n  this.page = page;\n  this.model = model;\n  model.data.$controller = this;\n}\n\nutil.mergeInto(Controller.prototype, EventEmitter.prototype);\n\nController.prototype.emitCancellable = function() {\n  var cancelled = false;\n  function cancel() {\n    cancelled = true;\n  }\n\n  var args = Array.prototype.slice.call(arguments);\n  args.push(cancel);\n  this.emit.apply(this, args);\n\n  return cancelled;\n};\n\nController.prototype.emitDelayable = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var callback = args.pop();\n\n  var delayed = false;\n  function delay() {\n    delayed = true;\n    return callback;\n  }\n\n  args.push(delay);\n  this.emit.apply(this, args);\n  if (!delayed) callback();\n\n  return delayed;\n};\n",
    "/*\n * Derby.js\n * Meant to be the entry point for the framework.\n *\n */\nvar racer = require('racer');\n\nmodule.exports = Derby;\n\nfunction Derby() {}\nDerby.prototype = Object.create(racer);\nDerby.prototype.constructor = Derby;\n\nDerby.prototype.App = require('./App');\nDerby.prototype.Page = require('./Page');\nDerby.prototype.Component = require('./components').Component;\n\nDerby.prototype.createApp = function(name, filename, options) {\n  return new this.App(this, name, filename, options);\n};\n\nif (!racer.util.isServer) {\n  require('./documentListeners').add(document);\n}\n",
    "module.exports = Dom;\n\nfunction Dom(controller) {\n  this.controller = controller;\n  this._listeners = null;\n}\n\nDom.prototype._initListeners = function() {\n  var dom = this;\n  this.controller.on('destroy', function domOnDestroy() {\n    var listeners = dom._listeners;\n    if (!listeners) return;\n    for (var i = listeners.length; i--;) {\n      listeners[i].remove();\n    }\n    dom._listeners = null;\n  });\n  return this._listeners = [];\n};\n\nDom.prototype._listenerIndex = function(domListener) {\n  var listeners = this._listeners;\n  if (!listeners) return -1;\n  for (var i = listeners.length; i--;) {\n    if (listeners[i].equals(domListener)) return i;\n  }\n  return -1;\n};\n\nDom.prototype.addListener = function(type, target, listener, useCapture) {\n  if (typeof target === 'function') {\n    useCapture = listener;\n    listener = target;\n    target = document;\n  }\n  var domListener =\n    (type === 'destroy') ? new DestroyListener(target, listener) :\n    new DomListener(type, target, listener, useCapture);\n  if (-1 === this._listenerIndex(domListener)) {\n    var listeners = this._listeners || this._initListeners();\n    listeners.push(domListener);\n  }\n  domListener.add();\n};\nDom.prototype.on = Dom.prototype.addListener;\n\nDom.prototype.once = function(type, target, listener, useCapture) {\n  if (typeof target === 'function') {\n    useCapture = listener;\n    listener = target;\n    target = document;\n  }\n  this.addListener(type, target, wrappedListener, useCapture);\n  var dom = this;\n  function wrappedListener() {\n    dom.removeListener(type, target, wrappedListener, useCapture);\n    return listener.apply(this, arguments);\n  }\n};\n\nDom.prototype.removeListener = function(type, target, listener, useCapture) {\n  if (typeof target === 'function') {\n    useCapture = listener;\n    listener = target;\n    target = document;\n  }\n  var domListener = new DomListener(type, target, listener, useCapture);\n  domListener.remove();\n  var i = this._listenerIndex(domListener);\n  if (i > -1) this._listeners.splice(i, 1);\n};\n\nfunction DomListener(type, target, listener, useCapture) {\n  this.type = type;\n  this.target = target;\n  this.listener = listener;\n  this.useCapture = !!useCapture;\n}\nDomListener.prototype.equals = function(domListener) {\n  return this.listener === domListener.listener &&\n    this.target === domListener.target &&\n    this.type === domListener.type &&\n    this.useCapture === domListener.useCapture;\n};\nDomListener.prototype.add = function() {\n  this.target.addEventListener(this.type, this.listener, this.useCapture);\n};\nDomListener.prototype.remove = function() {\n  this.target.removeEventListener(this.type, this.listener, this.useCapture);\n};\n\nfunction DestroyListener(target, listener) {\n  DomListener.call(this, 'destroy', target, listener);\n}\nDestroyListener.prototype = new DomListener();\nDestroyListener.prototype.add = function() {\n  var listeners = this.target.$destroyListeners || (this.target.$destroyListeners = []);\n  if (listeners.indexOf(this.listener) === -1) {\n    listeners.push(this.listener);\n  }\n};\nDestroyListener.prototype.remove = function() {\n  var listeners = this.target.$destroyListeners;\n  if (!listeners) return;\n  var index = listeners.indexOf(this.listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n};\n",
    "var derbyTemplates = require('derby-templates');\nvar contexts = derbyTemplates.contexts;\nvar expressions = derbyTemplates.expressions;\nvar templates = derbyTemplates.templates;\nvar DependencyOptions = derbyTemplates.options.DependencyOptions;\nvar util = require('racer/lib/util');\nvar components = require('./components');\nvar EventModel = require('./eventmodel');\nvar textDiff = require('./textDiff');\nvar Controller = require('./Controller');\nvar documentListeners = require('./documentListeners');\n\nmodule.exports = Page;\n\nfunction Page(app, model) {\n  Controller.call(this, app, this, model);\n  this.params = null;\n  if (this.init) this.init(model);\n  this.context = this._createContext();\n  this._eventModel = null;\n  this._removeModelListeners = null;\n  this._components = {};\n  this._addListeners();\n}\n\nutil.mergeInto(Page.prototype, Controller.prototype);\n\nPage.prototype.$bodyClass = function(ns) {\n  if (!ns) return;\n  var classNames = [];\n  var segments = ns.split(':');\n  for (var i = 0, len = segments.length; i < len; i++) {\n    var className = segments.slice(0, i + 1).join('-');\n    classNames.push(className);\n  }\n  return classNames.join(' ');\n};\n\nPage.prototype.$preventDefault = function(e) {\n  e.preventDefault();\n};\n\nPage.prototype.$stopPropagation = function(e) {\n  e.stopPropagation();\n};\n\nPage.prototype._setRenderParams = function(ns) {\n  this.model.set('$render.ns', ns);\n  this.model.set('$render.params', this.params);\n  this.model.set('$render.url', this.params && this.params.url);\n  this.model.set('$render.query', this.params && this.params.query);\n};\n\nPage.prototype._setRenderPrefix = function(ns) {\n  var prefix = (ns) ? ns + ':' : '';\n  this.model.set('$render.prefix', prefix);\n};\n\nPage.prototype.get = function(viewName, ns, unescaped) {\n  this._setRenderPrefix(ns);\n  var view = this.getView(viewName, ns);\n  return view.get(this.context, unescaped);\n};\n\nPage.prototype.getFragment = function(viewName, ns) {\n  this._setRenderPrefix(ns);\n  var view = this.getView(viewName, ns);\n  return view.getFragment(this.context);\n};\n\nPage.prototype.getView = function(viewName, ns) {\n  return this.app.views.find(viewName, ns);\n};\n\nPage.prototype.render = function(ns) {\n  this.app.emit('render', this);\n  this.context.pause();\n  this._setRenderParams(ns);\n  var titleFragment = this.getFragment('TitleElement', ns);\n  var bodyFragment = this.getFragment('BodyElement', ns);\n  var titleElement = document.getElementsByTagName('title')[0];\n  titleElement.parentNode.replaceChild(titleFragment, titleElement);\n  document.body.parentNode.replaceChild(bodyFragment, document.body);\n  this.context.unpause();\n  if (this.create) this.create(this.model, this.dom);\n  this.app.emit('routeDone', this, 'render');\n};\n\nPage.prototype.attach = function() {\n  this.context.pause();\n  var ns = this.model.get('$render.ns');\n  var titleView = this.getView('TitleElement', ns);\n  var bodyView = this.getView('BodyElement', ns);\n  var titleElement = document.getElementsByTagName('title')[0];\n  titleView.attachTo(titleElement.parentNode, titleElement, this.context);\n  bodyView.attachTo(document.body.parentNode, document.body, this.context);\n  this.context.unpause();\n  if (this.create) this.create(this.model, this.dom);\n};\n\nPage.prototype._createContext = function() {\n  var contextMeta = new contexts.ContextMeta();\n  contextMeta.views = this.app && this.app.views;\n  var context = new contexts.Context(contextMeta, this);\n  context.expression = new expressions.PathExpression([]);\n  context.alias = '#root';\n  return context;\n};\n\nPage.prototype._addListeners = function() {\n  var eventModel = this._eventModel = new EventModel();\n  this._addModelListeners(eventModel);\n  this._addContextListeners(eventModel);\n};\n\nPage.prototype.destroy = function() {\n  this.emit('destroy');\n  this._removeModelListeners();\n  for (var id in this._components) {\n    var component = this._components[id];\n    component.destroy();\n  }\n  // Remove all data, refs, listeners, and reactive functions\n  // for the previous page\n  var silentModel = this.model.silent();\n  silentModel.destroy('_page');\n  silentModel.destroy('$components');\n  // Unfetch and unsubscribe from all queries and documents\n  silentModel.unloadAll && silentModel.unloadAll();\n};\n\nPage.prototype._addModelListeners = function(eventModel) {\n  var model = this.model;\n  if (!model) return;\n  // Registering model listeners with the *Immediate events helps to prevent\n  // a bug with binding updates where a model listener causes a change to the\n  // path being listened on, directly or indirectly.\n\n  // TODO: Remove this when upgrading Racer to the next major version. Feature\n  // detect which type of event listener to register by emitting a test event\n  if (useLegacyListeners(model)) {\n    return this._addModelListenersLegacy(eventModel);\n  }\n\n  // `util.castSegments(segments)` is needed to cast string segments into\n  // numbers, since EventModel#child does typeof checks against segments. This\n  // could be done once in Racer's Model#emit, instead of in every listener.\n  var changeListener = model.on('changeImmediate', function onChange(segments, event) {\n    // The pass parameter is passed in for special handling of updates\n    // resulting from stringInsert or stringRemove\n    segments = util.castSegments(segments.slice());\n    eventModel.set(segments, event.previous, event.pass);\n  });\n  var loadListener = model.on('loadImmediate', function onLoad(segments) {\n    segments = util.castSegments(segments.slice());\n    eventModel.set(segments);\n  });\n  var unloadListener = model.on('unloadImmediate', function onUnload(segments, event) {\n    segments = util.castSegments(segments.slice());\n    eventModel.set(segments, event.previous);\n  });\n  var insertListener = model.on('insertImmediate', function onInsert(segments, event) {\n    segments = util.castSegments(segments.slice());\n    eventModel.insert(segments, event.index, event.values.length);\n  });\n  var removeListener = model.on('removeImmediate', function onRemove(segments, event) {\n    segments = util.castSegments(segments.slice());\n    eventModel.remove(segments, event.index, event.values.length);\n  });\n  var moveListener = model.on('moveImmediate', function onMove(segments, event) {\n    segments = util.castSegments(segments.slice());\n    eventModel.move(segments, event.from, event.to, event.howMany);\n  });\n\n  this._removeModelListeners = function() {\n    model.removeListener('changeImmediate', changeListener);\n    model.removeListener('loadImmediate', loadListener);\n    model.removeListener('unloadImmediate', unloadListener);\n    model.removeListener('insertImmediate', insertListener);\n    model.removeListener('removeImmediate', removeListener);\n    model.removeListener('moveImmediate', moveListener);\n  };\n};\nfunction useLegacyListeners(model) {\n  var useLegacy = true;\n  // model.once is broken in older racer, so manually remove event\n  var listener = model.on('changeImmediate', function(segments, event) {\n    model.removeListener('changeImmediate', listener);\n    // Older Racer emits an array of eventArgs, whereas newer racer emits an event object\n    useLegacy = Array.isArray(event);\n  });\n  model.set('$derby.testEvent', true);\n  return useLegacy;\n}\nPage.prototype._addModelListenersLegacy = function(eventModel) {\n  var model = this.model;\n  if (!model) return;\n\n  // `util.castSegments(segments)` is needed to cast string segments into\n  // numbers, since EventModel#child does typeof checks against segments. This\n  // could be done once in Racer's Model#emit, instead of in every listener.\n  var changeListener = model.on('changeImmediate', function onChange(segments, eventArgs) {\n    // eventArgs[0] is the new value, which Derby bindings don't use directly.\n    var previous = eventArgs[1];\n    // The pass parameter is passed in for special handling of updates\n    // resulting from stringInsert or stringRemove\n    var pass = eventArgs[2];\n    segments = util.castSegments(segments.slice());\n    eventModel.set(segments, previous, pass);\n  });\n  var loadListener = model.on('loadImmediate', function onLoad(segments) {\n    segments = util.castSegments(segments.slice());\n    eventModel.set(segments);\n  });\n  var unloadListener = model.on('unloadImmediate', function onUnload(segments) {\n    segments = util.castSegments(segments.slice());\n    eventModel.set(segments);\n  });\n  var insertListener = model.on('insertImmediate', function onInsert(segments, eventArgs) {\n    var index = eventArgs[0];\n    var values = eventArgs[1];\n    segments = util.castSegments(segments.slice());\n    eventModel.insert(segments, index, values.length);\n  });\n  var removeListener = model.on('removeImmediate', function onRemove(segments, eventArgs) {\n    var index = eventArgs[0];\n    var values = eventArgs[1];\n    segments = util.castSegments(segments.slice());\n    eventModel.remove(segments, index, values.length);\n  });\n  var moveListener = model.on('moveImmediate', function onMove(segments, eventArgs) {\n    var from = eventArgs[0];\n    var to = eventArgs[1];\n    var howMany = eventArgs[2];\n    segments = util.castSegments(segments.slice());\n    eventModel.move(segments, from, to, howMany);\n  });\n\n  this._removeModelListeners = function() {\n    model.removeListener('changeImmediate', changeListener);\n    model.removeListener('loadImmediate', loadListener);\n    model.removeListener('unloadImmediate', unloadListener);\n    model.removeListener('insertImmediate', insertListener);\n    model.removeListener('removeImmediate', removeListener);\n    model.removeListener('moveImmediate', moveListener);\n  };\n};\n\nPage.prototype._addContextListeners = function(eventModel) {\n  this.context.meta.addBinding = addBinding;\n  this.context.meta.removeBinding = removeBinding;\n  this.context.meta.removeNode = removeNode;\n  this.context.meta.addItemContext = addItemContext;\n  this.context.meta.removeItemContext = removeItemContext;\n\n  function addItemContext(context) {\n    var segments = context.expression.resolve(context);\n    eventModel.addItemContext(segments, context);\n  }\n  function removeItemContext(context) {\n    // TODO\n  }\n  function addBinding(binding) {\n    patchTextBinding(binding);\n    var expressions = binding.template.expressions;\n    if (expressions) {\n      for (var i = 0, len = expressions.length; i < len; i++) {\n        addDependencies(eventModel, expressions[i], binding);\n      }\n    } else {\n      var expression = binding.template.expression;\n      addDependencies(eventModel, expression, binding);\n    }\n  }\n  function removeBinding(binding) {\n    var bindingWrappers = binding.meta;\n    if (!bindingWrappers) return;\n    for (var i = bindingWrappers.length; i--;) {\n      eventModel.removeBinding(bindingWrappers[i]);\n    }\n  }\n  function removeNode(node) {\n    var component = node.$component;\n    if (component) component.destroy();\n    var destroyListeners = node.$destroyListeners;\n    if (destroyListeners) {\n      for (var i = 0; i < destroyListeners.length; i++) {\n        destroyListeners[i]();\n      }\n    }\n  }\n};\n\nfunction addDependencies(eventModel, expression, binding) {\n  var bindingWrapper = new BindingWrapper(eventModel, expression, binding);\n  bindingWrapper.updateDependencies();\n}\n\n// The code here uses object-based set pattern where objects are keyed using\n// sequentially generated IDs.\nvar nextId = 1;\nfunction BindingWrapper(eventModel, expression, binding) {\n  this.eventModel = eventModel;\n  this.expression = expression;\n  this.binding = binding;\n  this.id = nextId++;\n  this.eventModels = null;\n  this.dependencies = null;\n  this.ignoreTemplateDependency = (\n    binding instanceof components.ComponentAttributeBinding\n  ) || (\n    (binding.template instanceof templates.DynamicText) &&\n    (binding instanceof templates.RangeBinding)\n  );\n  if (binding.meta) {\n    binding.meta.push(this);\n  } else {\n    binding.meta = [this];\n  }\n}\nBindingWrapper.prototype.updateDependencies = function() {\n  var dependencyOptions;\n  if (this.ignoreTemplateDependency && this.binding.condition instanceof templates.Template) {\n    dependencyOptions = new DependencyOptions();\n    dependencyOptions.setIgnoreTemplate(this.binding.condition);\n  }\n  var dependencies = this.expression.dependencies(this.binding.context, dependencyOptions);\n  if (this.dependencies) {\n    // Do nothing if dependencies haven't changed\n    if (equalDependencies(this.dependencies, dependencies)) return;\n    // Otherwise, remove current dependencies\n    this.eventModel.removeBinding(this);\n  }\n  // Add new dependencies\n  if (!dependencies) return;\n  this.dependencies = dependencies;\n  for (var i = 0, len = dependencies.length; i < len; i++) {\n    var dependency = dependencies[i];\n    if (dependency) this.eventModel.addBinding(dependency, this);\n  }\n};\nBindingWrapper.prototype.update = function(previous, pass) {\n  this.binding.update(previous, pass);\n  this.updateDependencies();\n};\nBindingWrapper.prototype.insert = function(index, howMany) {\n  this.binding.insert(index, howMany);\n  this.updateDependencies();\n};\nBindingWrapper.prototype.remove = function(index, howMany) {\n  this.binding.remove(index, howMany);\n  this.updateDependencies();\n};\nBindingWrapper.prototype.move = function(from, to, howMany) {\n  this.binding.move(from, to, howMany);\n  this.updateDependencies();\n};\n\nfunction equalDependencies(a, b) {\n  var lenA = a ? a.length : -1;\n  var lenB = b ? b.length : -1;\n  if (lenA !== lenB) return false;\n  for (var i = 0; i < lenA; i++) {\n    var itemA = a[i];\n    var itemB = b[i];\n    var lenItemA = itemA ? itemA.length : -1;\n    var lenItemB = itemB ? itemB.length : -1;\n    if (lenItemA !== lenItemB) return false;\n    for (var j = 0; j < lenItemB; j++) {\n      if (itemA[j] !== itemB[j]) return false;\n    }\n  }\n  return true;\n}\n\nfunction patchTextBinding(binding) {\n  if (\n    binding instanceof templates.AttributeBinding &&\n    binding.name === 'value' &&\n    (binding.element.tagName === 'INPUT' || binding.element.tagName === 'TEXTAREA') &&\n    documentListeners.inputSupportsSelection(binding.element) &&\n    binding.template.expression.resolve(binding.context)\n  ) {\n    binding.update = textInputUpdate;\n  }\n}\n\nfunction textInputUpdate(previous, pass) {\n  textUpdate(this, this.element, previous, pass);\n}\nfunction textUpdate(binding, element, previous, pass) {\n  if (pass) {\n    if (pass.$event && pass.$event.target === element) {\n      return;\n    } else if (pass.$stringInsert) {\n      return textDiff.onStringInsert(\n        element,\n        previous,\n        pass.$stringInsert.index,\n        pass.$stringInsert.text\n      );\n    } else if (pass.$stringRemove) {\n      return textDiff.onStringRemove(\n        element,\n        previous,\n        pass.$stringRemove.index,\n        pass.$stringRemove.howMany\n      );\n    }\n  }\n  binding.template.update(binding.context, binding);\n}\n",
    "/*DERBY_SERIALIZED_VIEWS*/module.exports = function(derbyTemplates, views){var expressions = derbyTemplates.expressions,templates = derbyTemplates.templates;views.deserialize([[function(){return this.template=new templates.Template([new templates.Element('title', void 0, [new templates.Block(new templates.Template([new templates.DynamicText(new expressions.PathExpression(['$render', 'prefix'], new expressions.ExpressionMeta('$render.prefix'))), new templates.Text('Title')], '{{$render.prefix}}Title'), [new templates.DynamicViewInstance(new templates.Template([new templates.DynamicText(new expressions.PathExpression(['$render', 'prefix'], new expressions.ExpressionMeta('$render.prefix'))), new templates.Text('Title')], '{{$render.prefix}}Title'), {})])], void 0, false)])},'TitleElement', '<title><view is=\"{{$render.prefix}}Title\"></view></title>'],[function(){return this.template=new templates.Template([new templates.Element('body', {'class': new templates.DynamicAttribute(new expressions.FnExpression(['$bodyClass'], [new expressions.PathExpression(['$render', 'ns'])], void 0, new expressions.ExpressionMeta('$bodyClass($render.ns)')))}, [new templates.Block(new templates.Template([new templates.DynamicText(new expressions.PathExpression(['$render', 'prefix'], new expressions.ExpressionMeta('$render.prefix'))), new templates.Text('Body')], '{{$render.prefix}}Body'), [new templates.DynamicViewInstance(new templates.Template([new templates.DynamicText(new expressions.PathExpression(['$render', 'prefix'], new expressions.ExpressionMeta('$render.prefix'))), new templates.Text('Body')], '{{$render.prefix}}Body'), {})])], void 0, false, true)])},'BodyElement', '<body class=\"{{$bodyClass($render.ns)}}\"><view is=\"{{$render.prefix}}Body\"></view>'],[function(){return this.template=new templates.Template([new templates.Text('Derby App')])},'Title', 'Derby App'],[function(){return this.template=new templates.Template([new templates.ViewInstance('auth-register', {})])},'Body', '\\n    <view is=\"auth-register\"></view>\\n'],[function(){return this.template=new templates.Template([])},'Tail', ''],[function(){return this.template=new templates.Template([new templates.Marker('auth-register:index'), new templates.Element('button', {'id': new templates.Attribute('increase-button'), 'type': new templates.Attribute('button')}, [new templates.Text('Increase')], [new templates.ElementOn('click', new expressions.FnExpression(['increase'], []))], false), new templates.Element('h1', void 0, [new templates.Text('Value is '), new templates.DynamicText(new expressions.PathExpression(['value'], new expressions.ExpressionMeta('value')))], void 0, false)])},'auth-register:index', '\\n    <button id=\"increase-button\" type=\"button\" on-click=\"increase()\">Increase</button>\\n    <h1>Value is {{ value }}</h1>\\n\\n'],[function(){return this.template=new templates.Template([new templates.Text('App')])},'auth-register:Title', '\\n    App\\n']])};/*DERBY_SERIALIZED_VIEWS_END*/",
    "/*\n * components.js\n *\n * Components associate custom script functionality with a view. They can be\n * distributed as standalone modules containing templates, scripts, and styles.\n * They can also be used to modularize application functionality.\n *\n */\n\nvar util = require('racer/lib/util');\nvar derbyTemplates = require('derby-templates');\nvar templates = derbyTemplates.templates;\nvar expressions = derbyTemplates.expressions;\nvar Controller = require('./Controller');\nvar slice = [].slice;\n\nexports.Component = Component;\nexports.ComponentAttribute = ComponentAttribute;\nexports.ComponentAttributeBinding = ComponentAttributeBinding;\nexports.ComponentFactory = ComponentFactory;\nexports.SingletonComponentFactory = SingletonComponentFactory;\nexports.createFactory = createFactory;\nexports.extendComponent = extendComponent;\n\nfunction Component(context, data) {\n  var parent = context.controller;\n  var id = context.id();\n  var scope = ['$components', id];\n  var model = parent.model.root.eventContext(id);\n  model._at = scope.join('.');\n  data.id = id;\n  model._set(scope, data);\n  // Store a reference to the component's scope such that the expression\n  // getters are relative to the component\n  model.data = data;\n\n  Controller.call(this, parent.app, parent.page, model);\n  this.parent = parent;\n  this.context = context.componentChild(this);\n  this.id = id;\n  this._scope = scope;\n\n  // Add reference to this component on the page so that all components\n  // associated with a page can be destroyed when the page transitions\n  this.page._components[id] = this;\n  this.isDestroyed = false;\n}\n\nutil.mergeInto(Component.prototype, Controller.prototype);\n\nComponent.prototype.destroy = function() {\n  this.emit('destroy');\n  this.model.removeContextListeners();\n  this.model.destroy();\n  delete this.page._components[this.id];\n  if (this.page._eventModel.object) {\n    var components = this.page._eventModel.object.$components;\n    if (components) delete components.object[this.id];\n  }\n  this.isDestroyed = true;\n};\n\n// Apply calls to the passed in function with the component as the context.\n// Stop calling back once the component is destroyed, which avoids possible bugs\n// and memory leaks.\nComponent.prototype.bind = function(callback) {\n  var component = this;\n  this.on('destroy', function() {\n    // Reduce potential for memory leaks by removing references to the component\n    // and the passed in callback, which could have closure references\n    component = null;\n    // Cease calling back after component is removed from the DOM\n    callback = null;\n  });\n  return function componentBindWrapper() {\n    if (!callback) return;\n    return callback.apply(component, arguments);\n  };\n};\n\n// When passing in a numeric delay, calls the function at most once per that\n// many milliseconds. Like Underscore, the function will be called on the\n// leading and the trailing edge of the delay as appropriate. Unlike Underscore,\n// calls are consistently called via setTimeout and are never synchronous. This\n// should be used for reducing the frequency of ongoing updates, such as scroll\n// events or other continuous streams of events.\n//\n// Additionally, implements an interface intended to be used with\n// window.requestAnimationFrame or process.nextTick. If one of these is passed,\n// it will be used to create a single async call following any number of\n// synchronous calls. This mode is typically used to coalesce many synchronous\n// events (such as multiple model events) into a single async event.\n//\n// Like component.bind(), will no longer call back once the component is\n// destroyed, which avoids possible bugs and memory leaks.\nComponent.prototype.throttle = function(callback, delayArg) {\n  var component = this;\n  this.on('destroy', function() {\n    // Reduce potential for memory leaks by removing references to the component\n    // and the passed in callback, which could have closure references\n    component = null;\n    // Cease calling back after component is removed from the DOM\n    callback = null;\n  });\n\n  // throttle(callback)\n  // throttle(callback, 150)\n  if (delayArg == null || typeof delayArg === 'number') {\n    var delay = delayArg || 0;\n    var nextArgs;\n    var previous;\n    var boundCallback = function() {\n      var args = nextArgs;\n      nextArgs = null;\n      previous = +new Date();\n      if (callback && args) {\n        callback.apply(component, args);\n      }\n    };\n    return function componentThrottleWrapper() {\n      var queueCall = !nextArgs;\n      nextArgs = slice.call(arguments);\n      if (queueCall) {\n        var now = +new Date();\n        var remaining = Math.max(previous + delay - now, 0);\n        setTimeout(boundCallback, remaining);\n      }\n    };\n  }\n\n  // throttle(callback, window.requestAnimationFrame)\n  // throttle(callback, process.nextTick)\n  if (typeof delayArg === 'function') {\n    var nextArgs;\n    var boundCallback = function() {\n      var args = nextArgs;\n      nextArgs = null;\n      if (callback && args) {\n        callback.apply(component, args);\n      }\n    };\n    return function componentThrottleWrapper() {\n      var queueCall = !nextArgs;\n      nextArgs = slice.call(arguments);\n      if (queueCall) delayArg(boundCallback);\n    };\n  }\n\n  throw new Error('Second argument must be a delay function or number');\n};\n\n// Suppresses calls until the function is no longer called for that many\n// milliseconds. This should be used for delaying updates triggered by user\n// input, such as window resizing, or typing text that has a live preview or\n// client-side validation. This should not be used for inputs that trigger\n// server requests, such as search autocomplete; use debounceAsync for those\n// cases instead.\n//\n// Like component.bind(), will no longer call back once the component is\n// destroyed, which avoids possible bugs and memory leaks.\nComponent.prototype.debounce = function(callback, delay) {\n  delay = delay || 0;\n  if (typeof delay !== 'number') {\n    throw new Error('Second argument must be a number');\n  }\n  var component = this;\n  this.on('destroy', function() {\n    // Reduce potential for memory leaks by removing references to the component\n    // and the passed in callback, which could have closure references\n    component = null;\n    // Cease calling back after component is removed from the DOM\n    callback = null;\n  });\n  var nextArgs;\n  var timeout;\n  var boundCallback = function() {\n    var args = nextArgs;\n    nextArgs = null;\n    timeout = null;\n    if (callback && args) {\n      callback.apply(component, args);\n    }\n  };\n  return function componentDebounceWrapper() {\n    nextArgs = slice.call(arguments);\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(boundCallback, delay);\n  };\n};\n\n// Forked from: https://github.com/juliangruber/async-debounce\n//\n// Like debounce(), suppresses calls until the function is no longer called for\n// that many milliseconds. In addition, suppresses calls while the callback\n// function is running. In other words, the callback will not be called again\n// until the supplied done() argument is called. When the debounced function is\n// called while the callback is running, the callback will be called again\n// immediately after done() is called. Thus, the callback will always receive\n// the last value passed to the debounced function.\n//\n// This avoids the potential for multiple callbacks to execute in parallel and\n// complete out of order. It also acts as an adaptive rate limiter. Use this\n// method to debounce any field that triggers an async call as the user types.\n//\n// Like component.bind(), will no longer call back once the component is\n// destroyed, which avoids possible bugs and memory leaks.\nComponent.prototype.debounceAsync = function(callback, delay) {\n  var applyArguments = callback.length !== 1;\n  delay = delay || 0;\n  if (typeof delay !== 'number') {\n    throw new Error('Second argument must be a number');\n  }\n  var component = this;\n  this.on('destroy', function() {\n    // Reduce potential for memory leaks by removing references to the component\n    // and the passed in callback, which could have closure references\n    component = null;\n    // Cease calling back after component is removed from the DOM\n    callback = null;\n  });\n  var running = false;\n  var nextArgs;\n  var timeout;\n  function done() {\n    var args = nextArgs;\n    nextArgs = null;\n    timeout = null;\n    if (callback && args) {\n      running = true;\n      args.push(done);\n      callback.apply(component, args);\n    } else {\n      running = false;\n    }\n  }\n  return function componentDebounceAsyncWrapper() {\n    nextArgs = (applyArguments) ? slice.call(arguments) : [];\n    if (timeout) clearTimeout(timeout);\n    if (running) return;\n    timeout = setTimeout(done, delay);\n  };\n};\n\nComponent.prototype.get = function(viewName, unescaped) {\n  var view = this.getView(viewName);\n  return view.get(this.context, unescaped);\n};\n\nComponent.prototype.getFragment = function(viewName) {\n  var view = this.getView(viewName);\n  return view.getFragment(this.context);\n};\n\nComponent.prototype.getView = function(viewName) {\n  var contextView = this.context.getView();\n  return (viewName) ?\n    this.app.views.find(viewName, contextView.namespace) : contextView;\n};\n\nComponent.prototype.getAttribute = function(key) {\n  var attributeContext = this.context.forAttribute(key);\n  if (!attributeContext) return;\n  var value = attributeContext.attributes[key];\n  if (value instanceof expressions.Expression) {\n    value = value.get(attributeContext);\n  }\n  return expressions.renderValue(value, this.context);\n};\n\nComponent.prototype.setAttribute = function(key, value) {\n  this.context.parent.attributes[key] = value;\n};\n\nComponent.prototype.setNullAttribute = function(key, value) {\n  var attributes = this.context.parent.attributes;\n  if (attributes[key] == null) attributes[key] = value;\n};\n\nfunction ComponentAttribute(expression, model, key) {\n  this.expression = expression;\n  this.model = model;\n  this.key = key;\n}\nComponentAttribute.prototype.update = function(context, binding) {\n  var value = this.expression.get(context);\n  binding.condition = value;\n  this.model.setDiff(this.key, value);\n};\nfunction ComponentAttributeBinding(expression, model, key, context) {\n  this.template = new ComponentAttribute(expression, model, key);\n  this.context = context;\n  this.condition = expression.get(context);\n}\nComponentAttributeBinding.prototype = Object.create(templates.Binding.prototype);\nComponentAttributeBinding.prototype.constructor = ComponentAttributeBinding;\n\nfunction setModelAttributes(context, model) {\n  var attributes = context.parent.attributes;\n  if (!attributes) return;\n  // Set attribute values on component model\n  for (var key in attributes) {\n    var value = attributes[key];\n    setModelAttribute(context, model, key, value);\n  }\n}\n\nfunction setModelAttribute(context, model, key, value) {\n  // If an attribute is an Expression, set its current value in the model\n  // and keep it up to date. When it is a resolvable path, use a Racer ref,\n  // which makes it a two-way binding. Otherwise, set to the current value\n  // and create a binding that will set the value in the model as the\n  // expression's dependencies change.\n  if (value instanceof expressions.Expression) {\n    var segments = value.pathSegments(context);\n    if (segments) {\n      model.root.ref(model._at + '.' + key, segments.join('.'), {updateIndices: true});\n    } else {\n      var binding = new ComponentAttributeBinding(value, model, key, context);\n      context.addBinding(binding);\n      model.set(key, binding.condition);\n    }\n    return;\n  }\n\n  // If an attribute is a Template, set a template object in the model.\n  // Eagerly rendering a template can cause excessive rendering when the\n  // developer wants to pass in a complex chunk of HTML, and if we were to\n  // set a string in the model that represents the template value, we'd lose\n  // the ability to use the value in the component's template, since HTML\n  // would be escaped and we'd lose the ability to create proper bindings.\n  //\n  // This may be of surprise to developers, since it may not be intuitive\n  // whether a passed in value will produce an expression or a template. To\n  // get the rendered value consistently, the component's getAttribute(key)\n  // method may be used to get the value that would be rendered.\n  if (value instanceof templates.Template) {\n    var template = new templates.ContextClosure(value, context);\n    model.set(key, template);\n    return;\n  }\n\n  // For all other value types, set the passed in value directly. Passed in\n  // values will only be set initially, so model paths should be used if\n  // bindings are desired.\n  model.set(key, value);\n}\n\nfunction createFactory(constructor) {\n  // DEPRECATED: constructor.prototype.singleton is deprecated. \"singleton\"\n  // static property on the constructor is preferred\n  return (constructor.singleton || constructor.prototype.singleton) ?\n    new SingletonComponentFactory(constructor) :\n    new ComponentFactory(constructor);\n}\n\nfunction emitInitHooks(context, component) {\n  if (!context.initHooks) return;\n  // Run initHooks for `on` listeners immediately before init\n  for (var i = 0, len = context.initHooks.length; i < len; i++) {\n    context.initHooks[i].emit(context, component);\n  }\n}\n\nfunction ComponentModelData() {\n  this.id = null;\n  this.$controller = null;\n}\n\nfunction ComponentFactory(constructor) {\n  this.constructor = constructor;\n}\nComponentFactory.prototype.init = function(context) {\n  var DataConstructor = this.constructor.DataConstructor || ComponentModelData;\n  var data = new DataConstructor();\n  var component = new this.constructor(context, data);\n  // Detect whether the component constructor already called super by checking\n  // for one of the properties it sets. If not, call the Component constructor\n  if (!component.context) {\n    Component.call(component, context, data);\n  }\n\n  setModelAttributes(component.context, component.model);\n\n  // Do the user-specific initialization. The component constructor should be\n  // an empty function and the actual initialization code should be done in the\n  // component's init method. This means that we don't have to rely on users\n  // properly calling the Component constructor method and avoids having to\n  // play nice with how CoffeeScript extends class constructors\n  emitInitHooks(context, component);\n  component.emit('init', component);\n  if (component.init) component.init(component.model);\n\n  return component.context;\n};\nComponentFactory.prototype.create = function(context) {\n  var component = context.controller;\n  component.emit('create', component);\n  // Call the component's create function after its view is rendered\n  if (component.create) {\n    component.create(component.model, component.dom);\n  }\n};\n\nfunction noop() {}\n\nfunction SingletonComponentFactory(constructor) {\n  this.constructor = constructor;\n  this.component = null;\n  // Disable component from being destroyed, since it is intended to\n  // be used multiple times\n  constructor.prototype.destroy = noop;\n}\nSingletonComponentFactory.prototype.isSingleton = true;\nSingletonComponentFactory.prototype.init = function(context) {\n  if (!this.component) this.component = new this.constructor();\n  return context.componentChild(this.component);\n};\n// Don't call the init or create methods for singleton components\nSingletonComponentFactory.prototype.create = noop;\n\nfunction isBasePrototype(object) {\n  return (object === Object.prototype) ||\n    (object === Function.prototype) ||\n    (object === null);\n}\nfunction getRootPrototype(object) {\n  while (true) {\n    var prototype = Object.getPrototypeOf(object);\n    if (isBasePrototype(prototype)) return object;\n    object = prototype;\n  }\n}\nvar _extendComponent = (Object.setPrototypeOf && Object.getPrototypeOf) ?\n  // Modern version, which supports ES6 classes\n  function(constructor) {\n    // Find the end of the prototype chain\n    var rootPrototype = getRootPrototype(constructor.prototype);\n\n    // This guard is a workaroud to a bug that has occurred in Chakra when\n    // app.component() is invoked twice on the same constructor. In that case,\n    // the `instanceof Component` check in extendComponent incorrectly returns\n    // false after the prototype has already been set to `Component.prototype`.\n    // Then, this code proceeds to set the prototype of Component.prototype\n    // to itself, which throws a \"Cyclic __proto__ value\" error.\n    // https://github.com/Microsoft/ChakraCore/issues/5915\n    if (rootPrototype === Component.prototype) return;\n\n    // Establish inheritance with the pattern that Node's util.inherits() uses\n    // if Object.setPrototypeOf() is available (all modern browsers & IE11).\n    // This inhertance pattern is not equivalent to class extends, but it does\n    // work to make instances of the constructor inherit the desired prototype\n    // https://github.com/nodejs/node/issues/4179\n    Object.setPrototypeOf(rootPrototype, Component.prototype);\n  } :\n  // Fallback for older browsers\n  function(constructor) {\n    // In this version, we iterate over all of the properties on the\n    // constructor's prototype and merge them into a new prototype object.\n    // This flattens the prototype chain, meaning that instanceof will not\n    // work for classes from which the current component inherits\n    var prototype = constructor.prototype;\n    // Otherwise, modify constructor.prototype. This won't work with ES6\n    // classes, since their prototype property is non-writeable. However, it\n    // does work in older browsers that don't support Object.setPrototypeOf(),\n    // and those browsers don't support ES6 classes either\n    constructor.prototype = Object.create(Component.prototype);\n    constructor.prototype.constructor = constructor;\n    util.mergeInto(constructor.prototype, prototype);\n  };\nfunction extendComponent(constructor) {\n  // Don't do anything if the constructor already extends Component\n  if (constructor.prototype instanceof Component) return;\n  // Otherwise, append Component.prototype to constructor's prototype chain\n  _extendComponent(constructor);\n}\n",
    "var textDiff = require('./textDiff');\n\nexports.add = addDocumentListeners;\nexports.inputSupportsSelection = inputSupportsSelection;\n\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#do-not-apply\n// TODO: Date types support\nfunction inputSupportsSelection(input) {\n  var type = input.type;\n  return (\n    type === 'text' ||\n    type === 'textarea' ||\n    type === 'search' ||\n    type === 'url' ||\n    type === 'tel' ||\n    type === 'password'\n  );\n}\nfunction inputIsNumberValue(input) {\n  var type = input.type;\n  return (type === 'number' || (type === 'range' && !input.multiple));\n}\nvar inputValue = function(input) {\n  return inputIsNumberValue(input) ? input.valueAsNumber : input.value;\n};\n\nfunction addDocumentListeners(doc) {\n  doc.addEventListener('input', documentInput, true);\n  doc.addEventListener('change', documentChange, true);\n\n  // Listen to more events for versions of IE with buggy input event implementations\n  if (parseFloat(window.navigator.appVersion.split('MSIE ')[1]) <= 9) {\n    // We're listening on selectionchange because there's no other event emitted when\n    // the user clicks 'delete' from a context menu when right clicking on selected text.\n    // So although this event fires overly aggressively, it's the only real way\n    // to ensure that we can detect all changes to the input value in IE <= 9\n    doc.addEventListener('selectionchange', function(e){\n      if (document.activeElement) {\n        documentInput({target: document.activeElement}); // selectionchange evts don't have the e.target we need\n      }\n    }, true);\n  }\n\n  // For some reason valueAsNumber returns NaN for number inputs in IE\n  // until a new IE version that handles this is released, parse input.value as a fallback\n  var input = document.createElement('input');\n  input.type = 'number';\n  input.value = '7';\n  if (input.valueAsNumber !== input.valueAsNumber) {\n    var oldInputValue = inputValue;\n    inputValue = function(input) {\n      if (input.type === 'number') {\n        return inputIsNumberValue(input) ? parseFloat(input.value) : input.value;\n      } else {\n        return oldInputValue.apply(this, arguments);\n      }\n    };\n  }\n}\n\nfunction documentInput(e) {\n  var target = e.target;\n\n  if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {\n    setInputValue(e, target);\n  }\n}\n\nfunction documentChange(e) {\n  var target = e.target;\n\n  if (target.tagName === 'INPUT') {\n    setBoundProperty(target, 'checked');\n    setInputValue(e, target);\n\n  } else if (target.tagName === 'SELECT') {\n    setOptionBindings(target);\n\n  } else if (target.tagName === 'TEXTAREA') {\n    setInputValue(e, target);\n  }\n}\n\nfunction setBoundProperty(node, property) {\n  var binding = node.$bindAttributes && node.$bindAttributes[property];\n  if (!binding || binding.isUnbound()) return;\n\n  var value = node[property];\n  binding.template.expression.set(binding.context, value);\n}\n\nfunction setInputValue(e, target) {\n  var binding = target.$bindAttributes && target.$bindAttributes.value;\n  if (!binding || binding.isUnbound()) return;\n\n  if (inputSupportsSelection(target)) {\n    var pass = {$event: e};\n    textDiffBinding(binding, target.value, pass);\n  } else {\n    var value = inputValue(target);\n    binding.template.expression.set(binding.context, value);\n  }\n}\n\nfunction textDiffBinding(binding, value, pass) {\n  var expression = binding.template.expression;\n  var segments = expression.pathSegments(binding.context);\n  if (segments) {\n    var model = binding.context.controller.model.pass(pass);\n    textDiff.onTextInput(model, segments, value);\n  } else if (expression.set) {\n    expression.set(binding.context, value);\n  }\n}\n\nfunction setOptionBindings(parent) {\n  for (var node = parent.firstChild; node; node = node.nextSibling) {\n    if (node.tagName === 'OPTION') {\n      setBoundProperty(node, 'selected');\n    } else if (node.hasChildNodes()) {\n      setOptionBindings(node);\n    }\n  }\n}\n",
    "var expressions = require('derby-templates').expressions;\n\n// The many trees of bindings:\n//\n// - Model tree, containing your actual data. Eg:\n//    {users:{fred:{age:40}, wilma:{age:37}}}\n//\n// - Event model tree, whose structure mirrors the model tree. The event model\n//   tree lets us annotate the model tree with listeners which fire when events\n//   change. I think there are three types of listeners:\n//\n//   1. Reference binding binds to whatever is referred to by the path. Eg,\n//   {{each items as item}} binds item by reference as it goes through the\n//   list.\n//   2. Fixed path bindings explicitly bind to whatever is at that path\n//   regardless of how the model changes underneath the event model\n//   3. Listen on a subtree and fire when anything in the subtree changes. This\n//   is used for custom functions.\n//\n// {{foo.id}} would listen on the fixed path ['foo', 'id'].\n//\n//\n// - Context tree represents the changing (embedded) contexts of the templating\n//   engine. This maps to the tree of templates and allows templates to reference\n//   anything in any of their enclosing template scopes.\n//\n\nmodule.exports = EventModel;\n\n// The code here uses object-based set pattern where objects are keyed using\n// sequentially generated IDs.\nvar nextId = 1;\n\n// A binding object is something with update(), insert()/move()/remove() defined.\n\n\n// Given x[y] with model.get(y) == 5:\n//  item = 5\n//  segments = ['y']\n//  outside = the EventModel for x.\n//\n// Note that item could be a Context or another ModelRef - eg:\n//\n// {{ each foo as bar }} ... {{ x[bar] }}  -or-  {{ x[y[z]] }}\nfunction ModelRef(model, item, segments, outside) {\n  this.id = nextId++;\n\n  // We need a reference to the model & our segment list so we can update our\n  // value.\n  this.model = model;\n  this.segments = segments;\n\n  // Our current value.\n  this.item = item;\n\n  // outside is a reference to the EventModel of the thing on the lhs of the\n  // brackets. For example, in x[y].z, outside is the EventModel of x.\n  this.outside = outside;\n\n  // result is the EventModel of the evaluated version of the brackets. In\n  // x[y].z, its the EventModel of x[y].\n  this.result = outside.child(item).refChild(this);\n}\n\nModelRef.prototype.update = function() {\n  var segments = expressions.pathSegments(this.segments);\n  var newItem = expressions.lookup(segments, this.model.data);\n  if (this.item === newItem) return;\n\n  // First remove myself.\n  delete this.outside.child(this.item).refChildren[this.id];\n\n  this.item = newItem;\n\n  var container = this.outside.child(this.item);\n  // I want to just call refChild but that would create a new EM. Instead I\n  // want to just implant my current EM there.\n  if (!container.refChildren) container.refChildren = new RefChildrenMap();\n  container.refChildren[this.id] = this.result;\n\n  // Finally, update all the bindings in the tree.\n  this.result.update();\n};\n\n\nfunction RefOutMap() {}\nfunction RefChildrenMap() {}\nfunction BindingsMap() {}\nfunction ItemContextsMap() {}\nfunction EventModelsMap() {}\n\nfunction EventModel() {\n  this.id = nextId++;\n\n  // Most of these won't ever be filled in, so I'm just leaving them null.\n  //\n  // These contain our EventModel children.\n  this.object = null;\n  this.array = null;\n\n  // This contains any EventModel children which have floating references.\n  this.arrayByReference = null;\n\n  // If the data stored here is ever used to lookup other values, this is an\n  // object mapping remote child ID -> ref.\n  //\n  // Eg given x[y], y.refOut[x.id] = <Binding>\n  this.refOut = null;\n\n  // This is a map from ref id -> event model for events bound to this\n  // EventModel but via a ref. We could just merge them into the main tree, but\n  // this way they're easy to move.\n  //\n  // Eg, given x[y] (y=1), x.1.refChildren[ref id] is an EventModel.\n  this.refChildren = null;\n\n  this.bindings = null;\n\n  // Item contexts are contexts which need their item number changed as this\n  // EventModel object moves around its surrounding list.\n  this.itemContexts = null;\n}\n\nEventModel.prototype.refChild = function(ref) {\n  if (!this.refChildren) this.refChildren = new RefChildrenMap();\n  var id = ref.id;\n\n  if (!this.refChildren[id]) {\n    this.refChildren[id] = new EventModel();\n  }\n  return this.refChildren[id];\n};\n\nEventModel.prototype.arrayLookup = function(model, segmentsBefore, segmentsInside) {\n  var segments = expressions.pathSegments(segmentsInside);\n  var item = expressions.lookup(segments, model.data);\n\n  var source = this.at(segmentsInside);\n\n  // What the array currently resolves to. Given x[y] with y=1, container is\n  // the EM for x\n  var container = this.at(segmentsBefore);\n\n  if (!source.refOut) source.refOut = new RefOutMap();\n\n  var ref = source.refOut[container.id];\n  if (ref == null) {\n    ref = new ModelRef(model, item, segmentsInside, container);\n    source.refOut[container.id] = ref;\n  }\n\n  return ref;\n};\n\n// Returns the EventModel node of the named child.\nEventModel.prototype.child = function(segment) {\n  var container;\n  if (typeof segment === 'string') {\n    // Object\n    if (!this.object) this.object = {};\n    container = this.object;\n\n  } else if (typeof segment === 'number') {\n    // Array by value\n    if (!this.array) this.array = [];\n    container = this.array;\n\n  } else if (segment instanceof ModelRef) {\n    // Array reference. We'll need to lookup the child with the right\n    // value, then look inside its ref children for the right EventModel\n    // (so we can update it later). This is pretty janky, but should be\n    // *correct* even in the face of recursive array accessors.\n    //\n    // This will calculate it based on the current segment values, but refs\n    // cache the EM anyway.\n    //return this.child(segment.item).refChild(segment);\n    return segment.result;\n\n  } else {\n    // Array by reference\n    if (!this.arrayByReference) this.arrayByReference = [];\n    container = this.arrayByReference;\n    segment = segment.item;\n  }\n\n  return container[segment] || (container[segment] = new EventModel());\n};\n\n// Returns the EventModel node at the given segments list. Note that although\n// EventModel nodes are unique, its possible for multiple EventModel nodes to\n// refer to the same section of the model because of references.\n//\n// If you want to update the bindings that refer to a specific path, use\n// each().\n//\n// EventModel objects are created as needed.\nEventModel.prototype.at = function(segments) {\n  // For unbound dependancies.\n  if (segments == null) return this;\n\n  var eventModel = this;\n\n  for (var i = 0; i < segments.length; i++) {\n    eventModel = eventModel.child(segments[i]);\n  }\n\n  return eventModel;\n};\n\nEventModel.prototype.isEmpty = function() {\n  if (hasKeys(this.dependancies)) return false;\n  if (hasKeys(this.itemContexts)) return false;\n\n  if (this.object) {\n    if (hasKeys(this.object)) return false;\n    this.object = null;\n  }\n\n  if (this.arrayByReference) {\n    for (var i = 0; i < this.arrayByReference.length; i++) {\n      if (this.arrayByReference[i] != null) return false;\n    }\n    this.arrayByReference = null;\n  }\n\n  if (this.array) {\n    for (var i = 0; i < this.array.length; i++) {\n      if (this.array[i] != null) return false;\n    }\n    this.array = null;\n  }\n\n  return true;\n};\n\nfunction hasKeys(object) {\n  for (var key in object) {\n    return true;\n  }\n  return false;\n}\n\n\n// **** Updating the EventModel\n\nEventModel.prototype._addItemContext = function(context) {\n  if (!context._id) context._id = nextId++;\n  if (!this.itemContexts) this.itemContexts = new ItemContextsMap();\n  this.itemContexts[context._id] = context;\n};\n\nEventModel.prototype._removeItemContext = function(context) {\n  if (this.itemContexts) {\n    delete this.itemContexts[context._id];\n  }\n};\n\nEventModel.prototype._addBinding = function(binding) {\n  var bindings = this.bindings || (this.bindings = new BindingsMap());\n  binding.eventModels || (binding.eventModels = new EventModelsMap());\n  bindings[binding.id] = binding;\n  binding.eventModels[this.id] = this;\n};\n\n// This is the main hook to add bindings to the event model tree. It should\n// only be called on the root EventModel object.\nEventModel.prototype.addBinding = function(segments, binding) {\n  this.at(segments)._addBinding(binding);\n};\n\n// This is used for objects (contexts in derby's case) that have a .item\n// property which refers to an array index.\nEventModel.prototype.addItemContext = function(segments, context) {\n  this.at(segments)._addItemContext(context);\n};\n\nEventModel.prototype.removeBinding = function(binding) {\n  if (!binding.eventModels) return;\n  for (var id in binding.eventModels) {\n    var eventModel = binding.eventModels[id];\n    if (eventModel.bindings) delete eventModel.bindings[binding.id];\n  }\n  binding.eventModels = null;\n};\n\nEventModel.prototype._each = function(segments, pos, fn) {\n  // Our refChildren are effectively merged into this object.\n  if (this.refChildren) {\n    for (var id in this.refChildren) {\n      var refChild = this.refChildren[id];\n      if (refChild) refChild._each(segments, pos, fn);\n    }\n  }\n\n  if (segments.length === pos) {\n    fn(this);\n    return;\n  }\n\n  var segment = segments[pos];\n  var child;\n  if (typeof segment === 'string') {\n    // Object. Just recurse into our objects set. Its possible to rewrite this\n    // function to simply loop in the case of object lookups, but I don't think\n    // it'll buy us much.\n    child = this.object && this.object[segment];\n    if (child) child._each(segments, pos + 1, fn);\n\n  } else {\n    // Number. Recurse both into the fixed list and the reference list.\n    child = this.array && this.array[segment];\n    if (child) child._each(segments, pos + 1, fn);\n\n    child = this.arrayByReference && this.arrayByReference[segment];\n    if (child) child._each(segments, pos + 1, fn);\n  }\n};\n\n// Called when the scalar value at the path changes. This only calls update()\n// on this node. See update() below if you want to update entire\n// subtrees.\nEventModel.prototype.localUpdate = function(previous, pass) {\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.update(previous, pass);\n    }\n  }\n\n  // If our value changed, we also need to update anything that depends on it\n  // via refOut.\n  if (this.refOut) {\n    for (var id in this.refOut) {\n      var ref = this.refOut[id];\n      if (ref) ref.update();\n    }\n  }\n};\n\n// This is used when an object subtree is replaced / removed.\nEventModel.prototype.update = function(previous, pass) {\n  this.localUpdate(previous, pass);\n\n  if (this.object) {\n    for (var key in this.object) {\n      var binding = this.object[key];\n      if (binding) binding.update();\n    }\n  }\n\n  if (this.array) {\n    for (var i = 0; i < this.array.length; i++) {\n      var binding = this.array[i];\n      if (binding) binding.update();\n    }\n  }\n\n  if (this.arrayByReference) {\n    for (var i = 0; i < this.arrayByReference.length; i++) {\n      var binding = this.arrayByReference[i];\n      if (binding) binding.update();\n    }\n  }\n};\n\n// Updates the indexes in itemContexts of our children in the range of\n// [from, to). from and to both optional.\nEventModel.prototype._updateChildItemContexts = function(from, to) {\n  if (!this.arrayByReference) return;\n\n  if (from == null) from = 0;\n  if (to == null) to = this.arrayByReference.length;\n\n  for (var i = from; i < to; i++) {\n    var contexts = this.arrayByReference[i] &&\n      this.arrayByReference[i].itemContexts;\n    if (contexts) {\n      for (var key in contexts) {\n        contexts[key].item = i;\n      }\n    }\n  }\n};\n\n// Updates our array-by-value values. They have to recursively update every\n// binding in their children. Sad.\nEventModel.prototype._updateArray = function(from, to) {\n  if (!this.array) return;\n\n  if (from == null) from = 0;\n  if (to == null) to = this.array.length;\n\n  for (var i = from; i < to; i++) {\n    var binding = this.array[i];\n    if (binding) binding.update();\n  }\n};\n\nEventModel.prototype._updateObject = function() {\n  if (this.object) {\n    for (var key in this.object) {\n      var binding = this.object[key];\n      if (binding) binding.update();\n    }\n  }\n};\n\nEventModel.prototype._set = function(previous, pass) {\n  // This just updates anything thats bound to the whole subtree. An alternate\n  // implementation could be passed in the new value at this node (which we\n  // cache), then compare with the old version and only update parts of the\n  // subtree which are relevant. I don't know if thats an important\n  // optimization - it really depends on your use case.\n  this.update(previous, pass);\n};\n\n// Insert into this EventModel node.\nEventModel.prototype._insert = function(index, howMany) {\n  // Update fixed paths\n  this._updateArray(index);\n\n  // Update relative paths\n  if (this.arrayByReference && this.arrayByReference.length > index) {\n    // Shift the actual items in the array references array.\n\n    // This probably isn't the best way to implement insert. Other options are\n    // using concat() on slices or though constructing a temporary array and\n    // using splice.call. Hopefully if this method is slow it'll come up during\n    // profiling.\n    for (var i = 0; i < howMany; i++) {\n      this.arrayByReference.splice(index, 0, null);\n    }\n\n    // Update the path in the contexts\n    this._updateChildItemContexts(index + howMany);\n  }\n\n  // Finally call our bindings.\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.insert(index, howMany);\n    }\n  }\n  this._updateObject();\n};\n\n// Remove howMany child elements from this EventModel at index.\nEventModel.prototype._remove = function(index, howMany) {\n  // Update fixed paths. Both the removed items and items after it may have changed.\n  this._updateArray(index);\n\n  if (this.arrayByReference) {\n    // Update relative paths. First throw away all the children which have been removed.\n    this.arrayByReference.splice(index, howMany);\n\n    this._updateChildItemContexts(index);\n  }\n\n  // Call bindings.\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.remove(index, howMany);\n    }\n  }\n  this._updateObject();\n};\n\n// Move howMany items from `from` to `to`.\nEventModel.prototype._move = function(from, to, howMany) {\n  // first points to the first element that was moved. end points to the list\n  // element past the end of the changed region.\n  var first, end;\n  if (from < to) {\n    first = from;\n    end = to + howMany;\n  } else {\n    first = to;\n    end = from + howMany;\n  }\n\n  // Update fixed paths.\n  this._updateArray(first, end);\n\n  // Update relative paths\n  var arr = this.arrayByReference;\n  if (arr && arr.length > first) {\n    // Remove from the old location\n    var values = arr.splice(from, howMany);\n\n    // Insert at the new location\n    arr.splice.apply(arr, [to, 0].concat(values));\n\n    // Update the path in the contexts\n    this._updateChildItemContexts(first, end);\n  }\n\n  // Finally call our bindings.\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.move(from, to, howMany);\n    }\n  }\n  this._updateObject();\n};\n\n\n// Helpers.\n\nEventModel.prototype.mutate = function(segments, fn) {\n  // This finds & returns a list of all event models which exist and could match\n  // the specified path. The path cannot contain contexts like derby expression\n  // segment lists (just because I don't think thats a useful feature and its not\n  // implemented)\n  this._each(segments, 0, fn);\n\n  // Also emit all mutations as sets on star paths, which are how dependencies\n  // for view helper functions are represented. They should react to a path\n  // or any child path being modified\n  for (var i = 0, len = segments.length; i++ < len;) {\n    var wildcardSegments = segments.slice(0, i);\n    wildcardSegments.push('*');\n    this._each(wildcardSegments, 0, childSetWildcard);\n  }\n};\n\nfunction childSetWildcard(child) {\n  child._set();\n}\n\nEventModel.prototype.set = function(segments, previous, pass) {\n  this.mutate(segments, function childSet(child) {\n    child._set(previous, pass);\n  });\n};\n\nEventModel.prototype.insert = function(segments, index, howMany) {\n  this.mutate(segments, function childInsert(child) {\n    child._insert(index, howMany);\n  });\n};\n\nEventModel.prototype.remove = function(segments, index, howMany) {\n  this.mutate(segments, function childRemove(child) {\n    child._remove(index, howMany);\n  });\n};\n\nEventModel.prototype.move = function(segments, from, to, howMany) {\n  this.mutate(segments, function childMove(child) {\n    child._move(from, to, howMany);\n  });\n};\n",
    "exports.onStringInsert = onStringInsert;\nexports.onStringRemove = onStringRemove;\nexports.onTextInput = onTextInput;\n\nfunction onStringInsert(el, previous, index, text) {\n  function transformCursor(cursor) {\n    return (index < cursor) ? cursor + text.length : cursor;\n  }\n  previous || (previous = '');\n  var newText = previous.slice(0, index) + text + previous.slice(index);\n  replaceText(el, newText, transformCursor);\n}\n\nfunction onStringRemove(el, previous, index, howMany) {\n  function transformCursor(cursor) {\n    return (index < cursor) ? cursor - Math.min(howMany, cursor - index) : cursor;\n  }\n  previous || (previous = '');\n  var newText = previous.slice(0, index) + previous.slice(index + howMany);\n  replaceText(el, newText, transformCursor);\n}\n\nfunction replaceText(el, newText, transformCursor) {\n  var selectionStart = transformCursor(el.selectionStart);\n  var selectionEnd = transformCursor(el.selectionEnd);\n\n  var scrollTop = el.scrollTop;\n  el.value = newText;\n  if (el.scrollTop !== scrollTop) {\n    el.scrollTop = scrollTop;\n  }\n  if (document.activeElement === el) {\n    el.selectionStart = selectionStart;\n    el.selectionEnd = selectionEnd;\n  }\n}\n\nfunction onTextInput(model, segments, value) {\n  var previous = model._get(segments) || '';\n  if (previous === value) return;\n  var start = 0;\n  while (previous.charAt(start) === value.charAt(start)) {\n    start++;\n  }\n  var end = 0;\n  while (\n    previous.charAt(previous.length - 1 - end) === value.charAt(value.length - 1 - end) &&\n    end + start < previous.length &&\n    end + start < value.length\n  ) {\n    end++;\n  }\n\n  if (previous.length !== start + end) {\n    var howMany = previous.length - start - end;\n    model._stringRemove(segments, start, howMany);\n  }\n  if (value.length !== start + end) {\n    var inserted = value.slice(start, value.length - end);\n    model._stringInsert(segments, start, inserted);\n  }\n}\n",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar objectCreate = Object.create || objectCreatePolyfill\nvar objectKeys = Object.keys || objectKeysPolyfill\nvar bind = Function.prototype.bind || functionBindPolyfill\n\nfunction EventEmitter() {\n  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n    this._events = objectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nvar hasDefineProperty;\ntry {\n  var o = {};\n  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });\n  hasDefineProperty = o.x === 0;\n} catch (err) { hasDefineProperty = false }\nif (hasDefineProperty) {\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n      return defaultMaxListeners;\n    },\n    set: function(arg) {\n      // check whether the input is a positive number (whose value is zero or\n      // greater and not a NaN).\n      if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n        throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n      defaultMaxListeners = arg;\n    }\n  });\n} else {\n  EventEmitter.defaultMaxListeners = defaultMaxListeners;\n}\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    if (arguments.length > 1)\n      er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n      // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n      // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = objectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n          listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n          prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n            existing.length + ' \"' + String(type) + '\" listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit.');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        if (typeof console === 'object' && console.warn) {\n          console.warn('%s: %s', w.name, w.message);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    switch (arguments.length) {\n      case 0:\n        return this.listener.call(this.target);\n      case 1:\n        return this.listener.call(this.target, arguments[0]);\n      case 2:\n        return this.listener.call(this.target, arguments[0], arguments[1]);\n      case 3:\n        return this.listener.call(this.target, arguments[0], arguments[1],\n            arguments[2]);\n      default:\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; ++i)\n          args[i] = arguments[i];\n        this.listener.apply(this.target, args);\n    }\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = bind.call(onceWrapper, state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = objectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else\n          spliceOne(list, position);\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = objectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = objectKeys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = objectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (!events)\n    return [];\n\n  var evlistener = events[type];\n  if (!evlistener)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction objectCreatePolyfill(proto) {\n  var F = function() {};\n  F.prototype = proto;\n  return new F;\n}\nfunction objectKeysPolyfill(obj) {\n  var keys = [];\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {\n    keys.push(k);\n  }\n  return k;\n}\nfunction functionBindPolyfill(context) {\n  var fn = this;\n  return function () {\n    return fn.apply(context, arguments);\n  };\n}\n",
    "var hat = module.exports = function (bits, base) {\n    if (!base) base = 16;\n    if (bits === undefined) bits = 128;\n    if (bits <= 0) return '0';\n    \n    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);\n    for (var i = 2; digits === Infinity; i *= 2) {\n        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;\n    }\n    \n    var rem = digits - Math.floor(digits);\n    \n    var res = '';\n    \n    for (var i = 0; i < Math.floor(digits); i++) {\n        var x = Math.floor(Math.random() * base).toString(base);\n        res = x + res;\n    }\n    \n    if (rem) {\n        var b = Math.pow(base, rem);\n        var x = Math.floor(Math.random() * b).toString(base);\n        res = x + res;\n    }\n    \n    var parsed = parseInt(res, base);\n    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {\n        return hat(bits, base)\n    }\n    else return res;\n};\n\nhat.rack = function (bits, base, expandBy) {\n    var fn = function (data) {\n        var iters = 0;\n        do {\n            if (iters ++ > 10) {\n                if (expandBy) bits += expandBy;\n                else throw new Error('too many ID collisions, use more bits')\n            }\n            \n            var id = hat(bits, base);\n        } while (Object.hasOwnProperty.call(hats, id));\n        \n        hats[id] = data;\n        return id;\n    };\n    var hats = fn.hats = {};\n    \n    fn.get = function (id) {\n        return fn.hats[id];\n    };\n    \n    fn.set = function (id, value) {\n        fn.hats[id] = value;\n        return fn;\n    };\n    \n    fn.bits = bits || 128;\n    fn.base = base || 16;\n    return fn;\n};\n",
    "// These methods let you build a transform function from a transformComponent\n// function for OT types like JSON0 in which operations are lists of components\n// and transforming them requires N^2 work. I find it kind of nasty that I need\n// this, but I'm not really sure what a better solution is. Maybe I should do\n// this automatically to types that don't have a compose function defined.\n\n// Add transform and transformX functions for an OT type which has\n// transformComponent defined.  transformComponent(destination array,\n// component, other component, side)\nmodule.exports = bootstrapTransform\nfunction bootstrapTransform(type, transformComponent, checkValidOp, append) {\n  var transformComponentX = function(left, right, destLeft, destRight) {\n    transformComponent(destLeft, left, right, 'left');\n    transformComponent(destRight, right, left, 'right');\n  };\n\n  var transformX = type.transformX = function(leftOp, rightOp) {\n    checkValidOp(leftOp);\n    checkValidOp(rightOp);\n    var newRightOp = [];\n\n    for (var i = 0; i < rightOp.length; i++) {\n      var rightComponent = rightOp[i];\n\n      // Generate newLeftOp by composing leftOp by rightComponent\n      var newLeftOp = [];\n      var k = 0;\n      while (k < leftOp.length) {\n        var nextC = [];\n        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);\n        k++;\n\n        if (nextC.length === 1) {\n          rightComponent = nextC[0];\n        } else if (nextC.length === 0) {\n          for (var j = k; j < leftOp.length; j++) {\n            append(newLeftOp, leftOp[j]);\n          }\n          rightComponent = null;\n          break;\n        } else {\n          // Recurse.\n          var pair = transformX(leftOp.slice(k), nextC);\n          for (var l = 0; l < pair[0].length; l++) {\n            append(newLeftOp, pair[0][l]);\n          }\n          for (var r = 0; r < pair[1].length; r++) {\n            append(newRightOp, pair[1][r]);\n          }\n          rightComponent = null;\n          break;\n        }\n      }\n\n      if (rightComponent != null) {\n        append(newRightOp, rightComponent);\n      }\n      leftOp = newLeftOp;\n    }\n    return [leftOp, newRightOp];\n  };\n\n  // Transforms op with specified type ('left' or 'right') by otherOp.\n  type.transform = function(op, otherOp, type) {\n    if (!(type === 'left' || type === 'right'))\n      throw new Error(\"type must be 'left' or 'right'\");\n\n    if (otherOp.length === 0) return op;\n\n    if (op.length === 1 && otherOp.length === 1)\n      return transformComponent([], op[0], otherOp[0], type);\n\n    if (type === 'left')\n      return transformX(op, otherOp)[0];\n    else\n      return transformX(otherOp, op)[1];\n  };\n};\n",
    "// Only the JSON type is exported, because the text type is deprecated\n// otherwise. (If you want to use it somewhere, you're welcome to pull it out\n// into a separate module that json0 can depend on).\n\nmodule.exports = {\n  type: require('./json0')\n};\n",
    "/*\n This is the implementation of the JSON OT type.\n\n Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations\n\n Note: This is being made obsolete. It will soon be replaced by the JSON2 type.\n*/\n\n/**\n * UTILITY FUNCTIONS\n */\n\n/**\n * Checks if the passed object is an Array instance. Can't use Array.isArray\n * yet because its not supported on IE8.\n *\n * @param obj\n * @returns {boolean}\n */\nvar isArray = function(obj) {\n  return Object.prototype.toString.call(obj) == '[object Array]';\n};\n\n/**\n * Checks if the passed object is an Object instance.\n * No function call (fast) version\n *\n * @param obj\n * @returns {boolean}\n */\nvar isObject = function(obj) {\n  return (!!obj) && (obj.constructor === Object);\n};\n\n/**\n * Clones the passed object using JSON serialization (which is slow).\n *\n * hax, copied from test/types/json. Apparently this is still the fastest way\n * to deep clone an object, assuming we have browser support for JSON.  @see\n * http://jsperf.com/cloning-an-object/12\n */\nvar clone = function(o) {\n  return JSON.parse(JSON.stringify(o));\n};\n\n/**\n * JSON OT Type\n * @type {*}\n */\nvar json = {\n  name: 'json0',\n  uri: 'http://sharejs.org/types/JSONv0'\n};\n\n// You can register another OT type as a subtype in a JSON document using\n// the following function. This allows another type to handle certain\n// operations instead of the builtin JSON type.\nvar subtypes = {};\njson.registerSubtype = function(subtype) {\n  subtypes[subtype.name] = subtype;\n};\n\njson.create = function(data) {\n  // Null instead of undefined if you don't pass an argument.\n  return data === undefined ? null : clone(data);\n};\n\njson.invertComponent = function(c) {\n  var c_ = {p: c.p};\n\n  // handle subtype ops\n  if (c.t && subtypes[c.t]) {\n    c_.t = c.t;\n    c_.o = subtypes[c.t].invert(c.o);\n  }\n\n  if (c.si !== void 0) c_.sd = c.si;\n  if (c.sd !== void 0) c_.si = c.sd;\n  if (c.oi !== void 0) c_.od = c.oi;\n  if (c.od !== void 0) c_.oi = c.od;\n  if (c.li !== void 0) c_.ld = c.li;\n  if (c.ld !== void 0) c_.li = c.ld;\n  if (c.na !== void 0) c_.na = -c.na;\n\n  if (c.lm !== void 0) {\n    c_.lm = c.p[c.p.length-1];\n    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);\n  }\n\n  return c_;\n};\n\njson.invert = function(op) {\n  var op_ = op.slice().reverse();\n  var iop = [];\n  for (var i = 0; i < op_.length; i++) {\n    iop.push(json.invertComponent(op_[i]));\n  }\n  return iop;\n};\n\njson.checkValidOp = function(op) {\n  for (var i = 0; i < op.length; i++) {\n    if (!isArray(op[i].p)) throw new Error('Missing path');\n  }\n};\n\njson.checkList = function(elem) {\n  if (!isArray(elem))\n    throw new Error('Referenced element not a list');\n};\n\njson.checkObj = function(elem) {\n  if (!isObject(elem)) {\n    throw new Error(\"Referenced element not an object (it was \" + JSON.stringify(elem) + \")\");\n  }\n};\n\n// helper functions to convert old string ops to and from subtype ops\nfunction convertFromText(c) {\n  c.t = 'text0';\n  var o = {p: c.p.pop()};\n  if (c.si != null) o.i = c.si;\n  if (c.sd != null) o.d = c.sd;\n  c.o = [o];\n}\n\nfunction convertToText(c) {\n  c.p.push(c.o[0].p);\n  if (c.o[0].i != null) c.si = c.o[0].i;\n  if (c.o[0].d != null) c.sd = c.o[0].d;\n  delete c.t;\n  delete c.o;\n}\n\njson.apply = function(snapshot, op) {\n  json.checkValidOp(op);\n\n  op = clone(op);\n\n  var container = {\n    data: snapshot\n  };\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n\n    // convert old string ops to use subtype for backwards compatibility\n    if (c.si != null || c.sd != null)\n      convertFromText(c);\n\n    var parent = null;\n    var parentKey = null;\n    var elem = container;\n    var key = 'data';\n\n    for (var j = 0; j < c.p.length; j++) {\n      var p = c.p[j];\n\n      parent = elem;\n      parentKey = key;\n      elem = elem[key];\n      key = p;\n\n      if (parent == null)\n        throw new Error('Path invalid');\n    }\n\n    // handle subtype ops\n    if (c.t && c.o !== void 0 && subtypes[c.t]) {\n      elem[key] = subtypes[c.t].apply(elem[key], c.o);\n\n    // Number add\n    } else if (c.na !== void 0) {\n      if (typeof elem[key] != 'number')\n        throw new Error('Referenced element not a number');\n\n      elem[key] += c.na;\n    }\n\n    // List replace\n    else if (c.li !== void 0 && c.ld !== void 0) {\n      json.checkList(elem);\n      // Should check the list element matches c.ld\n      elem[key] = c.li;\n    }\n\n    // List insert\n    else if (c.li !== void 0) {\n      json.checkList(elem);\n      elem.splice(key,0, c.li);\n    }\n\n    // List delete\n    else if (c.ld !== void 0) {\n      json.checkList(elem);\n      // Should check the list element matches c.ld here too.\n      elem.splice(key,1);\n    }\n\n    // List move\n    else if (c.lm !== void 0) {\n      json.checkList(elem);\n      if (c.lm != key) {\n        var e = elem[key];\n        // Remove it...\n        elem.splice(key,1);\n        // And insert it back.\n        elem.splice(c.lm,0,e);\n      }\n    }\n\n    // Object insert / replace\n    else if (c.oi !== void 0) {\n      json.checkObj(elem);\n\n      // Should check that elem[key] == c.od\n      elem[key] = c.oi;\n    }\n\n    // Object delete\n    else if (c.od !== void 0) {\n      json.checkObj(elem);\n\n      // Should check that elem[key] == c.od\n      delete elem[key];\n    }\n\n    else {\n      throw new Error('invalid / missing instruction in op');\n    }\n  }\n\n  return container.data;\n};\n\n// Helper to break an operation up into a bunch of small ops.\njson.shatter = function(op) {\n  var results = [];\n  for (var i = 0; i < op.length; i++) {\n    results.push([op[i]]);\n  }\n  return results;\n};\n\n// Helper for incrementally applying an operation to a snapshot. Calls yield\n// after each op component has been applied.\njson.incrementalApply = function(snapshot, op, _yield) {\n  for (var i = 0; i < op.length; i++) {\n    var smallOp = [op[i]];\n    snapshot = json.apply(snapshot, smallOp);\n    // I'd just call this yield, but thats a reserved keyword. Bah!\n    _yield(smallOp, snapshot);\n  }\n\n  return snapshot;\n};\n\n// Checks if two paths, p1 and p2 match.\nvar pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {\n  if (p1.length != p2.length)\n    return false;\n\n  for (var i = 0; i < p1.length; i++) {\n    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))\n      return false;\n  }\n\n  return true;\n};\n\njson.append = function(dest,c) {\n  c = clone(c);\n\n  if (dest.length === 0) {\n    dest.push(c);\n    return;\n  }\n\n  var last = dest[dest.length - 1];\n\n  // convert old string ops to use subtype for backwards compatibility\n  if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n    convertFromText(c);\n    convertFromText(last);\n  }\n\n  if (pathMatches(c.p, last.p)) {\n    // handle subtype ops\n    if (c.t && last.t && c.t === last.t && subtypes[c.t]) {\n      last.o = subtypes[c.t].compose(last.o, c.o);\n\n      // convert back to old string ops\n      if (c.si != null || c.sd != null) {\n        var p = c.p;\n        for (var i = 0; i < last.o.length - 1; i++) {\n          c.o = [last.o.pop()];\n          c.p = p.slice();\n          convertToText(c);\n          dest.push(c);\n        }\n\n        convertToText(last);\n      }\n    } else if (last.na != null && c.na != null) {\n      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};\n    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {\n      // insert immediately followed by delete becomes a noop.\n      if (last.ld !== undefined) {\n        // leave the delete part of the replace\n        delete last.li;\n      } else {\n        dest.pop();\n      }\n    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {\n      last.oi = c.oi;\n    } else if (last.oi !== undefined && c.od !== undefined) {\n      // The last path component inserted something that the new component deletes (or replaces).\n      // Just merge them.\n      if (c.oi !== undefined) {\n        last.oi = c.oi;\n      } else if (last.od !== undefined) {\n        delete last.oi;\n      } else {\n        // An insert directly followed by a delete turns into a no-op and can be removed.\n        dest.pop();\n      }\n    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {\n      // don't do anything\n    } else {\n      dest.push(c);\n    }\n  } else {\n    // convert string ops back\n    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n      convertToText(c);\n      convertToText(last);\n    }\n\n    dest.push(c);\n  }\n};\n\njson.compose = function(op1,op2) {\n  json.checkValidOp(op1);\n  json.checkValidOp(op2);\n\n  var newOp = clone(op1);\n\n  for (var i = 0; i < op2.length; i++) {\n    json.append(newOp,op2[i]);\n  }\n\n  return newOp;\n};\n\njson.normalize = function(op) {\n  var newOp = [];\n\n  op = isArray(op) ? op : [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = [];\n\n    json.append(newOp,c);\n  }\n\n  return newOp;\n};\n\n// Returns the common length of the paths of ops a and b\njson.commonLengthForOps = function(a, b) {\n  var alen = a.p.length;\n  var blen = b.p.length;\n  if (a.na != null || a.t)\n    alen++;\n\n  if (b.na != null || b.t)\n    blen++;\n\n  if (alen === 0) return -1;\n  if (blen === 0) return null;\n\n  alen--;\n  blen--;\n\n  for (var i = 0; i < alen; i++) {\n    var p = a.p[i];\n    if (i >= blen || p !== b.p[i])\n      return null;\n  }\n\n  return alen;\n};\n\n// Returns true if an op can affect the given path\njson.canOpAffectPath = function(op, path) {\n  return json.commonLengthForOps({p:path}, op) != null;\n};\n\n// transform c so it applies to a document with otherC applied.\njson.transformComponent = function(dest, c, otherC, type) {\n  c = clone(c);\n\n  var common = json.commonLengthForOps(otherC, c);\n  var common2 = json.commonLengthForOps(c, otherC);\n  var cplength = c.p.length;\n  var otherCplength = otherC.p.length;\n\n  if (c.na != null || c.t)\n    cplength++;\n\n  if (otherC.na != null || otherC.t)\n    otherCplength++;\n\n  // if c is deleting something, and that thing is changed by otherC, we need to\n  // update c to reflect that change for invertibility.\n  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {\n    if (c.ld !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.ld = json.apply(clone(c.ld),[oc]);\n    } else if (c.od !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.od = json.apply(clone(c.od),[oc]);\n    }\n  }\n\n  if (common != null) {\n    var commonOperand = cplength == otherCplength;\n\n    // backward compatibility for old string ops\n    var oc = otherC;\n    if ((c.si != null || c.sd != null) && (otherC.si != null || otherC.sd != null)) {\n      convertFromText(c);\n      oc = clone(otherC);\n      convertFromText(oc);\n    }\n\n    // handle subtype ops\n    if (oc.t && subtypes[oc.t]) {\n      if (c.t && c.t === oc.t) {\n        var res = subtypes[c.t].transform(c.o, oc.o, type);\n\n        // convert back to old string ops\n        if (c.si != null || c.sd != null) {\n          var p = c.p;\n          for (var i = 0; i < res.length; i++) {\n            c.o = [res[i]];\n            c.p = p.slice();\n            convertToText(c);\n            json.append(dest, c);\n          }\n        } else if (!isArray(res) || res.length > 0) {\n          c.o = res;\n          json.append(dest, c);\n        }\n\n        return dest;\n      }\n    }\n\n    // transform based on otherC\n    else if (otherC.na !== void 0) {\n      // this case is handled below\n    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {\n      if (otherC.p[common] === c.p[common]) {\n        // noop\n\n        if (!commonOperand) {\n          return dest;\n        } else if (c.ld !== void 0) {\n          // we're trying to delete the same element, -> noop\n          if (c.li !== void 0 && type === 'left') {\n            // we're both replacing one element with another. only one can survive\n            c.ld = clone(otherC.li);\n          } else {\n            return dest;\n          }\n        }\n      }\n    } else if (otherC.li !== void 0) {\n      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {\n        // in li vs. li, left wins.\n        if (type === 'right')\n          c.p[common]++;\n      } else if (otherC.p[common] <= c.p[common]) {\n        c.p[common]++;\n      }\n\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          // otherC edits the same list we edit\n          if (otherC.p[common] <= c.lm)\n            c.lm++;\n          // changing c.from is handled above.\n        }\n      }\n    } else if (otherC.ld !== void 0) {\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          if (otherC.p[common] === c.p[common]) {\n            // they deleted the thing we're trying to move\n            return dest;\n          }\n          // otherC edits the same list we edit\n          var p = otherC.p[common];\n          var from = c.p[common];\n          var to = c.lm;\n          if (p < to || (p === to && from < to))\n            c.lm--;\n\n        }\n      }\n\n      if (otherC.p[common] < c.p[common]) {\n        c.p[common]--;\n      } else if (otherC.p[common] === c.p[common]) {\n        if (otherCplength < cplength) {\n          // we're below the deleted element, so -> noop\n          return dest;\n        } else if (c.ld !== void 0) {\n          if (c.li !== void 0) {\n            // we're replacing, they're deleting. we become an insert.\n            delete c.ld;\n          } else {\n            // we're trying to delete the same element, -> noop\n            return dest;\n          }\n        }\n      }\n\n    } else if (otherC.lm !== void 0) {\n      if (c.lm !== void 0 && cplength === otherCplength) {\n        // lm vs lm, here we go!\n        var from = c.p[common];\n        var to = c.lm;\n        var otherFrom = otherC.p[common];\n        var otherTo = otherC.lm;\n        if (otherFrom !== otherTo) {\n          // if otherFrom == otherTo, we don't need to change our op.\n\n          // where did my thing go?\n          if (from === otherFrom) {\n            // they moved it! tie break.\n            if (type === 'left') {\n              c.p[common] = otherTo;\n              if (from === to) // ugh\n                c.lm = otherTo;\n            } else {\n              return dest;\n            }\n          } else {\n            // they moved around it\n            if (from > otherFrom) c.p[common]--;\n            if (from > otherTo) c.p[common]++;\n            else if (from === otherTo) {\n              if (otherFrom > otherTo) {\n                c.p[common]++;\n                if (from === to) // ugh, again\n                  c.lm++;\n              }\n            }\n\n            // step 2: where am i going to put it?\n            if (to > otherFrom) {\n              c.lm--;\n            } else if (to === otherFrom) {\n              if (to > from)\n                c.lm--;\n            }\n            if (to > otherTo) {\n              c.lm++;\n            } else if (to === otherTo) {\n              // if we're both moving in the same direction, tie break\n              if ((otherTo > otherFrom && to > from) ||\n                  (otherTo < otherFrom && to < from)) {\n                if (type === 'right') c.lm++;\n              } else {\n                if (to > from) c.lm++;\n                else if (to === otherFrom) c.lm--;\n              }\n            }\n          }\n        }\n      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {\n        // li\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p > from) c.p[common]--;\n        if (p > to) c.p[common]++;\n      } else {\n        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath\n        // the lm\n        //\n        // i.e. things care about where their item is after the move.\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p === from) {\n          c.p[common] = to;\n        } else {\n          if (p > from) c.p[common]--;\n          if (p > to) c.p[common]++;\n          else if (p === to && from > to) c.p[common]++;\n        }\n      }\n    }\n    else if (otherC.oi !== void 0 && otherC.od !== void 0) {\n      if (c.p[common] === otherC.p[common]) {\n        if (c.oi !== void 0 && commonOperand) {\n          // we inserted where someone else replaced\n          if (type === 'right') {\n            // left wins\n            return dest;\n          } else {\n            // we win, make our op replace what they inserted\n            c.od = otherC.oi;\n          }\n        } else {\n          // -> noop if the other component is deleting the same object (or any parent)\n          return dest;\n        }\n      }\n    } else if (otherC.oi !== void 0) {\n      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {\n        // left wins if we try to insert at the same place\n        if (type === 'left') {\n          json.append(dest,{p: c.p, od:otherC.oi});\n        } else {\n          return dest;\n        }\n      }\n    } else if (otherC.od !== void 0) {\n      if (c.p[common] == otherC.p[common]) {\n        if (!commonOperand)\n          return dest;\n        if (c.oi !== void 0) {\n          delete c.od;\n        } else {\n          return dest;\n        }\n      }\n    }\n  }\n\n  json.append(dest,c);\n  return dest;\n};\n\nrequire('./bootstrapTransform')(json, json.transformComponent, json.checkValidOp, json.append);\n\n/**\n * Register a subtype for string operations, using the text0 type.\n */\nvar text = require('./text0');\n\njson.registerSubtype(text);\nmodule.exports = json;\n\n",
    "// DEPRECATED!\n//\n// This type works, but is not exported. Its included here because the JSON0\n// embedded string operations use this library.\n\n\n// A simple text implementation\n//\n// Operations are lists of components. Each component either inserts or deletes\n// at a specified position in the document.\n//\n// Components are either:\n//  {i:'str', p:100}: Insert 'str' at position 100 in the document\n//  {d:'str', p:100}: Delete 'str' at position 100 in the document\n//\n// Components in an operation are executed sequentially, so the position of components\n// assumes previous components have already executed.\n//\n// Eg: This op:\n//   [{i:'abc', p:0}]\n// is equivalent to this op:\n//   [{i:'a', p:0}, {i:'b', p:1}, {i:'c', p:2}]\n\nvar text = module.exports = {\n  name: 'text0',\n  uri: 'http://sharejs.org/types/textv0',\n  create: function(initial) {\n    if ((initial != null) && typeof initial !== 'string') {\n      throw new Error('Initial data must be a string');\n    }\n    return initial || '';\n  }\n};\n\n/** Insert s2 into s1 at pos. */\nvar strInject = function(s1, pos, s2) {\n  return s1.slice(0, pos) + s2 + s1.slice(pos);\n};\n\n/** Check that an operation component is valid. Throws if its invalid. */\nvar checkValidComponent = function(c) {\n  if (typeof c.p !== 'number')\n    throw new Error('component missing position field');\n\n  if ((typeof c.i === 'string') === (typeof c.d === 'string'))\n    throw new Error('component needs an i or d field');\n\n  if (c.p < 0)\n    throw new Error('position cannot be negative');\n};\n\n/** Check that an operation is valid */\nvar checkValidOp = function(op) {\n  for (var i = 0; i < op.length; i++) {\n    checkValidComponent(op[i]);\n  }\n};\n\n/** Apply op to snapshot */\ntext.apply = function(snapshot, op) {\n  var deleted;\n\n  checkValidOp(op);\n  for (var i = 0; i < op.length; i++) {\n    var component = op[i];\n    if (component.i != null) {\n      snapshot = strInject(snapshot, component.p, component.i);\n    } else {\n      deleted = snapshot.slice(component.p, component.p + component.d.length);\n      if (component.d !== deleted)\n        throw new Error(\"Delete component '\" + component.d + \"' does not match deleted text '\" + deleted + \"'\");\n\n      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);\n    }\n  }\n  return snapshot;\n};\n\n/**\n * Append a component to the end of newOp. Exported for use by the random op\n * generator and the JSON0 type.\n */\nvar append = text._append = function(newOp, c) {\n  if (c.i === '' || c.d === '') return;\n\n  if (newOp.length === 0) {\n    newOp.push(c);\n  } else {\n    var last = newOp[newOp.length - 1];\n\n    if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {\n      // Compose the insert into the previous insert\n      newOp[newOp.length - 1] = {i:strInject(last.i, c.p - last.p, c.i), p:last.p};\n\n    } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {\n      // Compose the deletes together\n      newOp[newOp.length - 1] = {d:strInject(c.d, last.p - c.p, last.d), p:c.p};\n\n    } else {\n      newOp.push(c);\n    }\n  }\n};\n\n/** Compose op1 and op2 together */\ntext.compose = function(op1, op2) {\n  checkValidOp(op1);\n  checkValidOp(op2);\n  var newOp = op1.slice();\n  for (var i = 0; i < op2.length; i++) {\n    append(newOp, op2[i]);\n  }\n  return newOp;\n};\n\n/** Clean up an op */\ntext.normalize = function(op) {\n  var newOp = [];\n\n  // Normalize should allow ops which are a single (unwrapped) component:\n  // {i:'asdf', p:23}.\n  // There's no good way to test if something is an array:\n  // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  // so this is probably the least bad solution.\n  if (op.i != null || op.p != null) op = [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = 0;\n\n    append(newOp, c);\n  }\n\n  return newOp;\n};\n\n// This helper method transforms a position by an op component.\n//\n// If c is an insert, insertAfter specifies whether the transform\n// is pushed after the insert (true) or before it (false).\n//\n// insertAfter is optional for deletes.\nvar transformPosition = function(pos, c, insertAfter) {\n  // This will get collapsed into a giant ternary by uglify.\n  if (c.i != null) {\n    if (c.p < pos || (c.p === pos && insertAfter)) {\n      return pos + c.i.length;\n    } else {\n      return pos;\n    }\n  } else {\n    // I think this could also be written as: Math.min(c.p, Math.min(c.p -\n    // otherC.p, otherC.d.length)) but I think its harder to read that way, and\n    // it compiles using ternary operators anyway so its no slower written like\n    // this.\n    if (pos <= c.p) {\n      return pos;\n    } else if (pos <= c.p + c.d.length) {\n      return c.p;\n    } else {\n      return pos - c.d.length;\n    }\n  }\n};\n\n// Helper method to transform a cursor position as a result of an op.\n//\n// Like transformPosition above, if c is an insert, insertAfter specifies\n// whether the cursor position is pushed after an insert (true) or before it\n// (false).\ntext.transformCursor = function(position, op, side) {\n  var insertAfter = side === 'right';\n  for (var i = 0; i < op.length; i++) {\n    position = transformPosition(position, op[i], insertAfter);\n  }\n\n  return position;\n};\n\n// Transform an op component by another op component. Asymmetric.\n// The result will be appended to destination.\n//\n// exported for use in JSON type\nvar transformComponent = text._tc = function(dest, c, otherC, side) {\n  //var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;\n\n  checkValidComponent(c);\n  checkValidComponent(otherC);\n\n  if (c.i != null) {\n    // Insert.\n    append(dest, {i:c.i, p:transformPosition(c.p, otherC, side === 'right')});\n  } else {\n    // Delete\n    if (otherC.i != null) {\n      // Delete vs insert\n      var s = c.d;\n      if (c.p < otherC.p) {\n        append(dest, {d:s.slice(0, otherC.p - c.p), p:c.p});\n        s = s.slice(otherC.p - c.p);\n      }\n      if (s !== '')\n        append(dest, {d: s, p: c.p + otherC.i.length});\n\n    } else {\n      // Delete vs delete\n      if (c.p >= otherC.p + otherC.d.length)\n        append(dest, {d: c.d, p: c.p - otherC.d.length});\n      else if (c.p + c.d.length <= otherC.p)\n        append(dest, c);\n      else {\n        // They overlap somewhere.\n        var newC = {d: '', p: c.p};\n\n        if (c.p < otherC.p)\n          newC.d = c.d.slice(0, otherC.p - c.p);\n\n        if (c.p + c.d.length > otherC.p + otherC.d.length)\n          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);\n\n        // This is entirely optional - I'm just checking the deleted text in\n        // the two ops matches\n        var intersectStart = Math.max(c.p, otherC.p);\n        var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);\n        var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);\n        var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);\n        if (cIntersect !== otherIntersect)\n          throw new Error('Delete ops delete different text in the same region of the document');\n\n        if (newC.d !== '') {\n          newC.p = transformPosition(newC.p, otherC);\n          append(dest, newC);\n        }\n      }\n    }\n  }\n\n  return dest;\n};\n\nvar invertComponent = function(c) {\n  return (c.i != null) ? {d:c.i, p:c.p} : {i:c.d, p:c.p};\n};\n\n// No need to use append for invert, because the components won't be able to\n// cancel one another.\ntext.invert = function(op) {\n  // Shallow copy & reverse that sucka.\n  op = op.slice().reverse();\n  for (var i = 0; i < op.length; i++) {\n    op[i] = invertComponent(op[i]);\n  }\n  return op;\n};\n\nrequire('./bootstrapTransform')(text, transformComponent, checkValidOp, append);\n",
    "// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n",
    "// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n",
    "'use strict';\n\nvar replace = String.prototype.replace;\nvar percentTwenties = /%20/g;\n\nmodule.exports = {\n    'default': 'RFC3986',\n    formatters: {\n        RFC1738: function (value) {\n            return replace.call(value, percentTwenties, '+');\n        },\n        RFC3986: function (value) {\n            return value;\n        }\n    },\n    RFC1738: 'RFC1738',\n    RFC3986: 'RFC3986'\n};\n",
    "'use strict';\n\nvar stringify = require('./stringify');\nvar parse = require('./parse');\nvar formats = require('./formats');\n\nmodule.exports = {\n    formats: formats,\n    parse: parse,\n    stringify: stringify\n};\n",
    "'use strict';\n\nvar utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar defaults = {\n    allowDots: false,\n    allowPrototypes: false,\n    arrayLimit: 20,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    parameterLimit: 1000,\n    plainObjects: false,\n    strictNullHandling: false\n};\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = {};\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\n    var parts = cleanStr.split(options.delimiter, limit);\n\n    for (var i = 0; i < parts.length; ++i) {\n        var part = parts[i];\n\n        var bracketEqualsPos = part.indexOf(']=');\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part, defaults.decoder);\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos), defaults.decoder);\n            val = options.decoder(part.slice(pos + 1), defaults.decoder);\n        }\n        if (has.call(obj, key)) {\n            obj[key] = [].concat(obj[key]).concat(val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function (chain, val, options) {\n    var leaf = val;\n\n    for (var i = chain.length - 1; i >= 0; --i) {\n        var obj;\n        var root = chain[i];\n\n        if (root === '[]') {\n            obj = [];\n            obj = obj.concat(leaf);\n        } else {\n            obj = options.plainObjects ? Object.create(null) : {};\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n            var index = parseInt(cleanRoot, 10);\n            if (\n                !isNaN(index)\n                && root !== cleanRoot\n                && String(index) === cleanRoot\n                && index >= 0\n                && (options.parseArrays && index <= options.arrayLimit)\n            ) {\n                obj = [];\n                obj[index] = leaf;\n            } else {\n                obj[cleanRoot] = leaf;\n            }\n        }\n\n        leaf = obj;\n    }\n\n    return leaf;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n    var options = opts ? utils.assign({}, opts) : {};\n\n    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;\n    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    return utils.compact(obj);\n};\n",
    "'use strict';\n\nvar utils = require('./utils');\nvar formats = require('./formats');\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching\n        return prefix + '[]';\n    },\n    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching\n        return prefix;\n    }\n};\n\nvar toISO = Date.prototype.toISOString;\n\nvar defaults = {\n    delimiter: '&',\n    encode: true,\n    encoder: utils.encode,\n    encodeValuesOnly: false,\n    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching\n        return toISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\n\nvar stringify = function stringify( // eslint-disable-line func-name-matching\n    object,\n    prefix,\n    generateArrayPrefix,\n    strictNullHandling,\n    skipNulls,\n    encoder,\n    filter,\n    sort,\n    allowDots,\n    serializeDate,\n    formatter,\n    encodeValuesOnly\n) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = serializeDate(obj);\n    } else if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {\n        if (encoder) {\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];\n        }\n        return [formatter(prefix) + '=' + formatter(String(obj))];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (Array.isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (Array.isArray(obj)) {\n            values = values.concat(stringify(\n                obj[key],\n                generateArrayPrefix(prefix, key),\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly\n            ));\n        } else {\n            values = values.concat(stringify(\n                obj[key],\n                prefix + (allowDots ? '.' + key : '[' + key + ']'),\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly\n            ));\n        }\n    }\n\n    return values;\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = opts ? utils.assign({}, opts) : {};\n\n    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;\n    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;\n    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;\n    var sort = typeof options.sort === 'function' ? options.sort : null;\n    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;\n    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;\n    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;\n    if (typeof options.format === 'undefined') {\n        options.format = formats['default'];\n    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {\n        throw new TypeError('Unknown format option provided.');\n    }\n    var formatter = formats.formatters[options.format];\n    var objKeys;\n    var filter;\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (Array.isArray(options.filter)) {\n        filter = options.filter;\n        objKeys = filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (options.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = options.arrayFormat;\n    } else if ('indices' in options) {\n        arrayFormat = options.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (sort) {\n        objKeys.sort(sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        keys = keys.concat(stringify(\n            obj[key],\n            key,\n            generateArrayPrefix,\n            strictNullHandling,\n            skipNulls,\n            encode ? encoder : null,\n            filter,\n            sort,\n            allowDots,\n            serializeDate,\n            formatter,\n            encodeValuesOnly\n        ));\n    }\n\n    var joined = keys.join(delimiter);\n    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n    return joined.length > 0 ? prefix + joined : '';\n};\n",
    "'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar hexTable = (function () {\n    var array = [];\n    for (var i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n\n    return array;\n}());\n\nvar compactQueue = function compactQueue(queue) {\n    var obj;\n\n    while (queue.length) {\n        var item = queue.pop();\n        obj = item.obj[item.prop];\n\n        if (Array.isArray(obj)) {\n            var compacted = [];\n\n            for (var j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n\n            item.obj[item.prop] = compacted;\n        }\n    }\n\n    return obj;\n};\n\nvar arrayToObject = function arrayToObject(source, options) {\n    var obj = options && options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nvar merge = function merge(target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (Array.isArray(target)) {\n            target.push(source);\n        } else if (typeof target === 'object') {\n            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (Array.isArray(target) && !Array.isArray(source)) {\n        mergeTarget = arrayToObject(target, options);\n    }\n\n    if (Array.isArray(target) && Array.isArray(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                if (target[i] && typeof target[i] === 'object') {\n                    target[i] = merge(target[i], item, options);\n                } else {\n                    target.push(item);\n                }\n            } else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nvar assign = function assignSingleSource(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n};\n\nvar decode = function (str) {\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\nvar encode = function encode(str) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = typeof str === 'string' ? str : String(str);\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D // -\n            || c === 0x2E // .\n            || c === 0x5F // _\n            || c === 0x7E // ~\n            || (c >= 0x30 && c <= 0x39) // 0-9\n            || (c >= 0x41 && c <= 0x5A) // a-z\n            || (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)]\n            + hexTable[0x80 | ((c >> 12) & 0x3F)]\n            + hexTable[0x80 | ((c >> 6) & 0x3F)]\n            + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nvar compact = function compact(value) {\n    var queue = [{ obj: { o: value }, prop: 'o' }];\n    var refs = [];\n\n    for (var i = 0; i < queue.length; ++i) {\n        var item = queue[i];\n        var obj = item.obj[item.prop];\n\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; ++j) {\n            var key = keys[j];\n            var val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n\n    return compactQueue(queue);\n};\n\nvar isRegExp = function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar isBuffer = function isBuffer(obj) {\n    if (obj === null || typeof obj === 'undefined') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\nmodule.exports = {\n    arrayToObject: arrayToObject,\n    assign: assign,\n    compact: compact,\n    decode: decode,\n    encode: encode,\n    isBuffer: isBuffer,\n    isRegExp: isRegExp,\n    merge: merge\n};\n",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n",
    "'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n",
    "var racer = require('racer');\nvar Socket = require('./socket');\nvar CLIENT_OPTIONS = JSON.parse('{\"base\":\"/channel\",\"reconnect\":true,\"browserChannelOnly\":false,\"timeout\":10000,\"timeoutIncrement\":10000}');\n\nracer.Model.prototype._createSocket = function(bundle) {\n  return new Socket(CLIENT_OPTIONS);\n};\n\n",
    "module.exports = Socket;\n\nvar BCSocket = require('browserchannel/dist/bcsocket-uncompressed').BCSocket;\n\nfunction Socket(options) {\n  this._options = options;\n  this._messageQueue = [];\n  this._connectedOnce = false;\n  this._attemptNum = 0;\n  this._url = getWebSocketURL(options);\n\n  if (supportWebSockets() && !options.browserChannelOnly) {\n    this._createWebSocket();\n  } else {\n    this._createBrowserChannel();\n  }\n}\n\nSocket.prototype._createWebSocket = function() {\n\n  this._type = 'websocket';\n  this._socket = new WebSocket(this._url);\n\n  this.open = this._createWebSocket.bind(this);\n  this._syncState();\n\n  this._socket.onmessage = this._ws_onmessage.bind(this);\n  this._socket.onopen = this._ws_onopen.bind(this);\n  this._socket.onclose = this._ws_onclose.bind(this);\n\n};\n\nSocket.prototype._createBrowserChannel = function() {\n  this._type = 'browserchannel';\n  this._socket = BCSocket(this._options.base, this._options);\n\n  this.open = this._createBrowserChannel.bind(this);\n  this._syncState();\n\n  this._socket.onmessage = this._bc_onmessage.bind(this);\n  this._socket.onopen = this._bc_onopen.bind(this);\n  this._socket.onclose = this._bc_onclose.bind(this);\n};\n\nSocket.prototype._ws_onmessage = function(message) {\n  this._syncState();\n  message.data = JSON.parse(message.data);\n  this.onmessage && this.onmessage(message);\n};\n\nSocket.prototype._ws_onopen = function(event) {\n  this._attemptNum = 0;\n  this._connectedOnce = true;\n\n  this._syncState();\n  this._flushQueue();\n\n  this.onopen && this.onopen(event);\n};\n\nSocket.prototype._ws_onclose = function(event) {\n  this._syncState();\n  console.log('WebSocket: connection is broken', event);\n\n  this.onclose && this.onclose(event);\n\n  if (!this._connectedOnce) {\n    return this._createBrowserChannel();\n  }\n\n  var socket = this;\n\n  if (this._options.reconnect && !event.wasClean) {\n    setTimeout(function(){\n      if (socket.readyState === socket.CLOSED) {\n        socket._createWebSocket();\n      }\n    }, this._getTimeout());\n  }\n  this._attemptNum++;\n};\n\nSocket.prototype._getTimeout = function(){\n  var base = this._options.timeout;\n  var increment = this._options.timeoutIncrement * this._attemptNum;\n  var maxTimeout = base + increment;\n  return getRandom(maxTimeout / 3, maxTimeout);\n};\n\nSocket.prototype._bc_onmessage = function(data) {\n  this._syncState();\n  this.onmessage && this.onmessage(data);\n};\n\nSocket.prototype._bc_onopen = function(event) {\n  this._syncState();\n  this.onopen && this.onopen(event);\n};\n\nSocket.prototype._bc_onclose = function(event) {\n  this._syncState();\n  this.onclose && this.onclose(event);\n};\n\nSocket.prototype._flushQueue = function(){\n  while (this._messageQueue.length !== 0) {\n    var data = this._messageQueue.shift();\n    this._send(data);\n  }\n};\n\nSocket.prototype._send = function(data){\n  if (this._type === 'websocket' && (typeof data !== 'string')) data = JSON.stringify(data);\n\n  this._socket.send(data);\n};\n\nSocket.prototype.send = function(data){\n  if (this._type === 'websocket') {\n    if (this._socket.readyState === WebSocket.OPEN && this._messageQueue.length === 0) {\n      this._send(data);\n    } else {\n      this._messageQueue.push(data);\n    }\n  } else {\n    this._send(data);\n  }\n};\n\nSocket.prototype.close = function(){\n  this._socket.close();\n};\n\nSocket.prototype._syncState = function(){\n  this.readyState = this._socket.readyState;\n};\n\nSocket.prototype.reconnect = function(){\n  if (this._type === 'websocket' && this.readyState === this.CLOSED){\n    this._createWebSocket();\n  }\n};\n\n// ShareJS constants\nSocket.prototype.canSendWhileConnecting = true;\nSocket.prototype.canSendJSON = true;\n\n// WebSocket constants\nSocket.prototype.CONNECTING = 0;\nSocket.prototype.OPEN = 1;\nSocket.prototype.CLOSING = 2;\nSocket.prototype.CLOSED = 3;\n\nfunction getRandom(min, max){\n  return Math.random() * (max - min) + min;\n}\n\nfunction supportWebSockets(){\n  // The condition is from Modernizr\n  // https://github.com/Modernizr/Modernizr/blob/master/feature-detects/websockets.js#L28\n  return 'WebSocket' in window && window.WebSocket.CLOSING === 2;\n}\n\nfunction getWebSocketURL(options){\n  var port;\n\n  if (window.location && window.location.port) {\n    port = \":\" + window.location.port;\n  }\n\n  var srvPort = options.srvPort;\n  var srvSecurePort = options.srvSecurePort;\n\n  var srvHost = options.srvHost || window.location.hostname;\n  var srvProtocol = options.srvProtocol || window.location.protocol;\n\n  var protocol = (srvProtocol === 'https:' ? 'wss:' : 'ws:');\n\n  if (protocol === 'ws:' && srvPort) {\n    port = \":\" + srvPort;\n  } else if (protocol === 'wss:' && srvSecurePort) {\n    port = \":\" + srvSecurePort;\n  }\n  return protocol + '//' + srvHost + (port || \"\") + options.base;\n}\n\n// Maybe need to use reconnection timing algorithm from\n// http://blog.johnryding.com/post/78544969349/how-to-reconnect-web-sockets-in-a-realtime-web-app\n",
    "module.exports = CollectionCounter;\n\nfunction CollectionCounter() {\n  this.reset();\n}\nCollectionCounter.prototype.reset = function() {\n  this.collections = {};\n};\nCollectionCounter.prototype.get = function(collectionName, id) {\n  var collection = this.collections[collectionName];\n  return collection && collection[id];\n};\nCollectionCounter.prototype.increment = function(collectionName, id) {\n  var collection = this.collections[collectionName] ||\n    (this.collections[collectionName] = {});\n  var count = (collection[id] || 0) + 1;\n  collection[id] = count;\n  return count;\n};\nCollectionCounter.prototype.decrement = function(collectionName, id) {\n  var collection = this.collections[collectionName];\n  var count = collection && collection[id];\n  if (count == null) return;\n  if (count > 1) {\n    count--;\n    collection[id] = count;\n    return count;\n  }\n  delete collection[id];\n  // Check if the collection still has any keys\n  // eslint-disable-next-line no-unused-vars\n  for (var key in collection) return 0;\n  delete this.collections[collectionName];\n  return 0;\n};\nCollectionCounter.prototype.toJSON = function() {\n  // Check to see if we have any keys\n  // eslint-disable-next-line no-unused-vars\n  for (var key in this.collections) {\n    return this.collections;\n  }\n  return;\n};\n",
    "module.exports = Doc;\n\nfunction Doc(model, collectionName, id) {\n  this.collectionName = collectionName;\n  this.id = id;\n  this.collectionData = model && model.data[collectionName];\n}\n\nDoc.prototype.path = function(segments) {\n  var path = this.collectionName + '.' + this.id;\n  if (segments && segments.length) path += '.' + segments.join('.');\n  return path;\n};\n\nDoc.prototype._errorMessage = function(description, segments, value) {\n  return description + ' at ' + this.path(segments) + ': ' +\n    JSON.stringify(value, null, 2);\n};\n",
    "var Doc = require('./Doc');\nvar util = require('../util');\n\nmodule.exports = LocalDoc;\n\nfunction LocalDoc(model, collectionName, id, data) {\n  Doc.call(this, model, collectionName, id);\n  this.data = data;\n  this._updateCollectionData();\n}\n\nLocalDoc.prototype = new Doc();\n\nLocalDoc.prototype._updateCollectionData = function() {\n  this.collectionData[this.id] = this.data;\n};\n\nLocalDoc.prototype.create = function(value, cb) {\n  if (this.data !== undefined) {\n    var message = this._errorMessage('create on local document with data', null, this.data);\n    var err = new Error(message);\n    return cb(err);\n  }\n  this.data = value;\n  this._updateCollectionData();\n  cb();\n};\n\nLocalDoc.prototype.set = function(segments, value, cb) {\n  function set(node, key) {\n    var previous = node[key];\n    node[key] = value;\n    return previous;\n  }\n  return this._apply(segments, set, cb);\n};\n\nLocalDoc.prototype.del = function(segments, cb) {\n  // Don't do anything if the value is already undefined, since\n  // apply creates objects as it traverses, and the del method\n  // should not create anything\n  var previous = this.get(segments);\n  if (previous === undefined) {\n    cb();\n    return;\n  }\n  function del(node, key) {\n    delete node[key];\n    return previous;\n  }\n  return this._apply(segments, del, cb);\n};\n\nLocalDoc.prototype.increment = function(segments, byNumber, cb) {\n  var self = this;\n  function validate(value) {\n    if (typeof value === 'number' || value == null) return;\n    return new TypeError(self._errorMessage(\n      'increment on non-number', segments, value\n    ));\n  }\n  function increment(node, key) {\n    var value = (node[key] || 0) + byNumber;\n    node[key] = value;\n    return value;\n  }\n  return this._validatedApply(segments, validate, increment, cb);\n};\n\nLocalDoc.prototype.push = function(segments, value, cb) {\n  function push(arr) {\n    return arr.push(value);\n  }\n  return this._arrayApply(segments, push, cb);\n};\n\nLocalDoc.prototype.unshift = function(segments, value, cb) {\n  function unshift(arr) {\n    return arr.unshift(value);\n  }\n  return this._arrayApply(segments, unshift, cb);\n};\n\nLocalDoc.prototype.insert = function(segments, index, values, cb) {\n  function insert(arr) {\n    arr.splice.apply(arr, [index, 0].concat(values));\n    return arr.length;\n  }\n  return this._arrayApply(segments, insert, cb);\n};\n\nLocalDoc.prototype.pop = function(segments, cb) {\n  function pop(arr) {\n    return arr.pop();\n  }\n  return this._arrayApply(segments, pop, cb);\n};\n\nLocalDoc.prototype.shift = function(segments, cb) {\n  function shift(arr) {\n    return arr.shift();\n  }\n  return this._arrayApply(segments, shift, cb);\n};\n\nLocalDoc.prototype.remove = function(segments, index, howMany, cb) {\n  function remove(arr) {\n    return arr.splice(index, howMany);\n  }\n  return this._arrayApply(segments, remove, cb);\n};\n\nLocalDoc.prototype.move = function(segments, from, to, howMany, cb) {\n  function move(arr) {\n    // Remove from old location\n    var values = arr.splice(from, howMany);\n    // Insert in new location\n    arr.splice.apply(arr, [to, 0].concat(values));\n    return values;\n  }\n  return this._arrayApply(segments, move, cb);\n};\n\nLocalDoc.prototype.stringInsert = function(segments, index, value, cb) {\n  var self = this;\n  function validate(value) {\n    if (typeof value === 'string' || value == null) return;\n    return new TypeError(self._errorMessage(\n      'stringInsert on non-string', segments, value\n    ));\n  }\n  function stringInsert(node, key) {\n    var previous = node[key];\n    if (previous == null) {\n      node[key] = value;\n      return previous;\n    }\n    node[key] = previous.slice(0, index) + value + previous.slice(index);\n    return previous;\n  }\n  return this._validatedApply(segments, validate, stringInsert, cb);\n};\n\nLocalDoc.prototype.stringRemove = function(segments, index, howMany, cb) {\n  var self = this;\n  function validate(value) {\n    if (typeof value === 'string' || value == null) return;\n    return new TypeError(self._errorMessage(\n      'stringRemove on non-string', segments, value\n    ));\n  }\n  function stringRemove(node, key) {\n    var previous = node[key];\n    if (previous == null) return previous;\n    if (index < 0) index += previous.length;\n    node[key] = previous.slice(0, index) + previous.slice(index + howMany);\n    return previous;\n  }\n  return this._validatedApply(segments, validate, stringRemove, cb);\n};\n\nLocalDoc.prototype.get = function(segments) {\n  return util.lookup(segments, this.data);\n};\n\n/**\n * @param {Array} segments is the array representing a path\n * @param {Function} fn(node, key) applies a mutation on node[key]\n * @return {Object} returns the return value of fn(node, key)\n */\nLocalDoc.prototype._createImplied = function(segments, fn) {\n  var node = this;\n  var key = 'data';\n  var i = 0;\n  var nextKey = segments[i++];\n  while (nextKey != null) {\n    // Get or create implied object or array\n    node = node[key] || (node[key] = /^\\d+$/.test(nextKey) ? [] : {});\n    key = nextKey;\n    nextKey = segments[i++];\n  }\n  return fn(node, key);\n};\n\nLocalDoc.prototype._apply = function(segments, fn, cb) {\n  var out = this._createImplied(segments, fn);\n  this._updateCollectionData();\n  cb();\n  return out;\n};\n\nLocalDoc.prototype._validatedApply = function(segments, validate, fn, cb) {\n  var out = this._createImplied(segments, function(node, key) {\n    var err = validate(node[key]);\n    if (err) return cb(err);\n    return fn(node, key);\n  });\n  this._updateCollectionData();\n  cb();\n  return out;\n};\n\nLocalDoc.prototype._arrayApply = function(segments, fn, cb) {\n  // Lookup a pointer to the property or nested property &\n  // return the current value or create a new array\n  var arr = this._createImplied(segments, nodeCreateArray);\n\n  if (!Array.isArray(arr)) {\n    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);\n    var err = new TypeError(message);\n    return cb(err);\n  }\n  var out = fn(arr);\n  this._updateCollectionData();\n  cb();\n  return out;\n};\n\nfunction nodeCreateArray(node, key) {\n  var node = node[key] || (node[key] = []);\n  return node;\n}\n",
    "var uuid = require('uuid');\n\nModel.INITS = [];\n\nmodule.exports = Model;\n\nfunction Model(options) {\n  this.root = this;\n\n  var inits = Model.INITS;\n  if (!options) options = {};\n  this.debug = options.debug || {};\n  for (var i = 0; i < inits.length; i++) {\n    inits[i](this, options);\n  }\n}\n\nModel.prototype.id = function() {\n  return uuid.v4();\n};\n\nModel.prototype._child = function() {\n  return new ChildModel(this);\n};\n\nModel.ChildModel = ChildModel;\n\nfunction ChildModel(model) {\n  // Shared properties should be accessed via the root. This makes inheritance\n  // cheap and easily extensible\n  this.root = model.root;\n\n  // EventEmitter methods access these properties directly, so they must be\n  // inherited manually instead of via the root\n  this._events = model._events;\n  this._maxListeners = model._maxListeners;\n\n  // Properties specific to a child instance\n  this._context = model._context;\n  this._at = model._at;\n  this._pass = model._pass;\n  this._silent = model._silent;\n  this._eventContext = model._eventContext;\n  this._preventCompose = model._preventCompose;\n}\nChildModel.prototype = new Model();\n",
    "var util = require('../util');\nvar Model = require('./Model');\nvar defaultType = require('sharedb/lib/client').types.defaultType;\n\nmodule.exports = Query;\n\nModel.INITS.push(function(model) {\n  model.root._queries = new Queries();\n});\n\nModel.prototype.query = function(collectionName, expression, options) {\n  // DEPRECATED: Passing in a string as the third argument specifies the db\n  // option for backward compatibility\n  if (typeof options === 'string') {\n    options = {db: options};\n  }\n  return this._getOrCreateQuery(collectionName, expression, options, Query);\n};\n\n/**\n * If an existing query is present with the same `collectionName`, `expression`,\n * and `options`, then returns the existing query; otherwise, constructs and\n * returns a new query using `QueryConstructor`.\n *\n * @param {string} collectionName\n * @param {*} expression\n * @param {*} options\n * @param {new (model: Model, collectionName: string, expression: any, options: any) => Query} QueryConstructor -\n *   constructor function for a Query, to create one if not already present on this model\n */\nModel.prototype._getOrCreateQuery = function(collectionName, expression, options, QueryConstructor) {\n  expression = this.sanitizeQuery(expression);\n  var query = this.root._queries.get(collectionName, expression, options);\n  if (query) return query;\n  query = new QueryConstructor(this, collectionName, expression, options);\n  this.root._queries.add(query);\n  return query;\n};\n\n// This method replaces undefined in query objects with null, because\n// undefined properties are removed in JSON stringify. This can be dangerous\n// in queries, where presenece of a property may indicate that it should be a\n// filter and absence means that all values are accepted. We aren't checking\n// for cycles, which aren't allowed in JSON, so this could throw a max call\n// stack error\nModel.prototype.sanitizeQuery = function(expression) {\n  if (expression && typeof expression === 'object') {\n    for (var key in expression) {\n      if (expression.hasOwnProperty(key)) {\n        var value = expression[key];\n        if (value === undefined) {\n          expression[key] = null;\n        } else {\n          this.sanitizeQuery(value);\n        }\n      }\n    }\n  }\n  return expression;\n};\n\n// Called during initialization of the bundle on page load.\nModel.prototype._initQueries = function(items) {\n  var queries = this.root._queries;\n  for (var i = 0; i < items.length; i++) {\n    var item = items[i];\n    var counts = item[0];\n    var collectionName = item[1];\n    var expression = item[2];\n    var results = item[3] || [];\n    var options = item[4];\n    var extra = item[5];\n    var query = this.root._queries.get(collectionName, expression, options);\n    if (!query) {\n      query = new Query(this, collectionName, expression, options);\n      queries.add(query);\n    }\n\n    query._setExtra(extra);\n\n    var ids = [];\n    for (var resultIndex = 0; resultIndex < results.length; resultIndex++) {\n      var result = results[resultIndex];\n      if (typeof result === 'string') {\n        ids.push(result);\n        continue;\n      }\n      var data = result[0];\n      var v = result[1];\n      var id = result[2] || data.id;\n      var type = result[3];\n      ids.push(id);\n      var snapshot = {data: data, v: v, type: type};\n      this.getOrCreateDoc(collectionName, id, snapshot);\n    }\n    query._addMapIds(ids);\n    this._set(query.idsSegments, ids);\n\n    for (var countIndex = 0; countIndex < counts.length; countIndex++) {\n      var count = counts[countIndex];\n      var subscribed = count[0] || 0;\n      var fetched = count[1] || 0;\n      var contextId = count[2];\n      if (contextId) query.model.setContext(contextId);\n      while (subscribed--) {\n        query.subscribe();\n      }\n      query.fetchCount += fetched;\n      while (fetched--) {\n        query.model._context.fetchQuery(query);\n      }\n    }\n  }\n};\n\nfunction Queries() {\n  // Map is a flattened map of queries by hash. Currently used in contexts\n  this.map = {};\n  // Collections is a nested map of queries by collection then hash\n  this.collections = {};\n}\nQueries.prototype.add = function(query) {\n  this.map[query.hash] = query;\n  var collection = this.collections[query.collectionName] ||\n    (this.collections[query.collectionName] = {});\n  collection[query.hash] = query;\n};\nQueries.prototype.remove = function(query) {\n  delete this.map[query.hash];\n  var collection = this.collections[query.collectionName];\n  if (!collection) return;\n  delete collection[query.hash];\n  // Check if the collection still has any keys\n  // eslint-disable-next-line no-unused-vars\n  for (var key in collection) return;\n  delete this.collections[query.collectionName];\n};\nQueries.prototype.get = function(collectionName, expression, options) {\n  var hash = queryHash(collectionName, expression, options);\n  return this.map[hash];\n};\nQueries.prototype.toJSON = function() {\n  var out = [];\n  for (var hash in this.map) {\n    var query = this.map[hash];\n    if (query.subscribeCount || query.fetchCount) {\n      out.push(query.serialize());\n    }\n  }\n  return out;\n};\n\nfunction Query(model, collectionName, expression, options) {\n  this.model = model.pass({$query: this});\n  this.collectionName = collectionName;\n  this.expression = util.deepCopy(expression);\n  this.options = options;\n  this.hash = queryHash(collectionName, expression, options);\n  this.segments = ['$queries', this.hash];\n  this.idsSegments = ['$queries', this.hash, 'ids'];\n  this.extraSegments = ['$queries', this.hash, 'extra'];\n\n  this._pendingSubscribeCallbacks = [];\n\n  // These are used to help cleanup appropriately when calling unsubscribe and\n  // unfetch. A query won't be fully cleaned up until unfetch and unsubscribe\n  // are called the same number of times that fetch and subscribe were called.\n  this.subscribeCount = 0;\n  this.fetchCount = 0;\n\n  this.created = false;\n  this.shareQuery = null;\n\n  // idMap is checked in maybeUnload to see if the query is currently holding\n  // a reference to an id in its results set. This map is duplicative of the\n  // actual results id list stored in the model, but we are maintaining it,\n  // because otherwise maybeUnload would be looping through the entire results\n  // set of each query on the same collection for every doc checked\n  //\n  // Map of id -> count of ids\n  this.idMap = {};\n}\n\nQuery.prototype.create = function() {\n  this.created = true;\n  this.model.root._queries.add(this);\n};\n\nQuery.prototype.destroy = function() {\n  var ids = this.getIds();\n  this.created = false;\n  if (this.shareQuery) {\n    this.shareQuery.destroy();\n    this.shareQuery = null;\n  }\n  this.model.root._queries.remove(this);\n  this.idMap = {};\n  this.model._del(this.segments);\n  this._maybeUnloadDocs(ids);\n};\n\nQuery.prototype.fetch = function(cb) {\n  cb = this.model.wrapCallback(cb);\n  this.model._context.fetchQuery(this);\n\n  this.fetchCount++;\n\n  if (!this.created) this.create();\n\n  var query = this;\n  function fetchCb(err, results, extra) {\n    if (err) return cb(err);\n    query._setExtra(extra);\n    query._setResults(results);\n    cb();\n  }\n  this.model.root.connection.createFetchQuery(\n    this.collectionName,\n    this.expression,\n    this.options,\n    fetchCb\n  );\n  return this;\n};\n\nQuery.prototype.subscribe = function(cb) {\n  cb = this.model.wrapCallback(cb);\n  this.model._context.subscribeQuery(this);\n\n  if (this.subscribeCount++) {\n    var query = this;\n    process.nextTick(function() {\n      var data = query.model._get(query.segments);\n      if (data) {\n        cb();\n      } else {\n        query._pendingSubscribeCallbacks.push(cb);\n      }\n    });\n    return this;\n  }\n\n  if (!this.created) this.create();\n\n  var options = (this.options) ? util.copy(this.options) : {};\n  options.results = this._getShareResults();\n\n  // When doing server-side rendering, we actually do a fetch the first time\n  // that subscribe is called, but keep track of the state as if subscribe\n  // were called for proper initialization in the client\n  if (this.model.root.fetchOnly) {\n    this._shareFetchedSubscribe(options, cb);\n  } else {\n    this._shareSubscribe(options, cb);\n  }\n\n  return this;\n};\n\nQuery.prototype._subscribeCb = function(cb) {\n  var query = this;\n  return function subscribeCb(err, results, extra) {\n    if (err) return query._flushSubscribeCallbacks(err, cb);\n    query._setExtra(extra);\n    query._setResults(results);\n    query._flushSubscribeCallbacks(null, cb);\n  };\n};\n\nQuery.prototype._shareFetchedSubscribe = function(options, cb) {\n  this.model.root.connection.createFetchQuery(\n    this.collectionName,\n    this.expression,\n    options,\n    this._subscribeCb(cb)\n  );\n};\n\nQuery.prototype._shareSubscribe = function(options, cb) {\n  var query = this;\n  // Sanity check, though this shouldn't happen\n  if (this.shareQuery) {\n    this.shareQuery.destroy();\n  }\n  this.shareQuery = this.model.root.connection.createSubscribeQuery(\n    this.collectionName,\n    this.expression,\n    options,\n    this._subscribeCb(cb)\n  );\n  this.shareQuery.on('insert', function(shareDocs, index) {\n    var ids = resultsIds(shareDocs);\n    query._addMapIds(ids);\n    query.model._insert(query.idsSegments, index, ids);\n  });\n  this.shareQuery.on('remove', function(shareDocs, index) {\n    var ids = resultsIds(shareDocs);\n    query._removeMapIds(ids);\n    query.model._remove(query.idsSegments, index, shareDocs.length);\n  });\n  this.shareQuery.on('move', function(shareDocs, from, to) {\n    query.model._move(query.idsSegments, from, to, shareDocs.length);\n  });\n  this.shareQuery.on('extra', function(extra) {\n    query.model._setDiffDeep(query.extraSegments, extra);\n  });\n  this.shareQuery.on('error', function(err) {\n    query.model._emitError(err, query.hash);\n  });\n};\n\nQuery.prototype._removeMapIds = function(ids) {\n  for (var i = ids.length; i--;) {\n    var id = ids[i];\n    if (this.idMap[id] > 1) {\n      this.idMap[id]--;\n    } else {\n      delete this.idMap[id];\n    }\n  }\n  // Technically this isn't quite right and we might not wait the full unload\n  // delay if someone else calls maybeUnload for the same doc id. However,\n  // it is a lot easier to implement than delaying the removal until later and\n  // dealing with adds that might happen in the meantime. This will probably\n  // work to avoid thrashing subscribe/unsubscribe in expected cases\n  if (this.model.root.unloadDelay) {\n    var query = this;\n    setTimeout(function() {\n      query._maybeUnloadDocs(ids);\n    }, this.model.root.unloadDelay);\n    return;\n  }\n  this._maybeUnloadDocs(ids);\n};\nQuery.prototype._addMapIds = function(ids) {\n  for (var i = ids.length; i--;) {\n    var id = ids[i];\n    this.idMap[id] = (this.idMap[id] || 0) + 1;\n  }\n};\nQuery.prototype._diffMapIds = function(ids) {\n  var addedIds = [];\n  var removedIds = [];\n  var newMap = {};\n  for (var i = ids.length; i--;) {\n    var id = ids[i];\n    newMap[id] = true;\n    if (this.idMap[id]) continue;\n    addedIds.push(id);\n  }\n  for (var id in this.idMap) {\n    if (newMap[id]) continue;\n    removedIds.push(id);\n  }\n  if (addedIds.length) this._addMapIds(addedIds);\n  if (removedIds.length) this._removeMapIds(removedIds);\n};\nQuery.prototype._setExtra = function(extra) {\n  if (extra === undefined) return;\n  this.model._setDiffDeep(this.extraSegments, extra);\n};\nQuery.prototype._setResults = function(results) {\n  var ids = resultsIds(results);\n  this._setResultIds(ids);\n};\nQuery.prototype._setResultIds = function(ids) {\n  this._diffMapIds(ids);\n  this.model._setArrayDiff(this.idsSegments, ids);\n};\nQuery.prototype._maybeUnloadDocs = function(ids) {\n  for (var i = 0; i < ids.length; i++) {\n    var id = ids[i];\n    this.model._maybeUnloadDoc(this.collectionName, id);\n  }\n};\n\n// Flushes `_pendingSubscribeCallbacks`, calling each callback in the array,\n// with an optional error to pass into each. `_pendingSubscribeCallbacks` will\n// be empty after this runs.\nQuery.prototype._flushSubscribeCallbacks = function(err, cb) {\n  cb(err);\n  var pendingCallback;\n  while ((pendingCallback = this._pendingSubscribeCallbacks.shift())) {\n    pendingCallback(err);\n  }\n};\n\nQuery.prototype.unfetch = function(cb) {\n  cb = this.model.wrapCallback(cb);\n  this.model._context.unfetchQuery(this);\n\n  // No effect if the query is not currently fetched\n  if (!this.fetchCount) {\n    cb();\n    return this;\n  }\n\n  var query = this;\n  if (this.model.root.unloadDelay) {\n    setTimeout(finishUnfetchQuery, this.model.root.unloadDelay);\n  } else {\n    finishUnfetchQuery();\n  }\n  function finishUnfetchQuery() {\n    var count = --query.fetchCount;\n    if (count) return cb(null, count);\n    // Cleanup when no fetches or subscribes remain\n    if (!query.subscribeCount) query.destroy();\n    cb(null, 0);\n  }\n  return this;\n};\n\nQuery.prototype.unsubscribe = function(cb) {\n  cb = this.model.wrapCallback(cb);\n  this.model._context.unsubscribeQuery(this);\n\n  // No effect if the query is not currently subscribed\n  if (!this.subscribeCount) {\n    cb();\n    return this;\n  }\n\n  var query = this;\n  if (this.model.root.unloadDelay) {\n    setTimeout(finishUnsubscribeQuery, this.model.root.unloadDelay);\n  } else {\n    finishUnsubscribeQuery();\n  }\n  function finishUnsubscribeQuery() {\n    var count = --query.subscribeCount;\n    if (count) return cb(null, count);\n\n    if (query.shareQuery) {\n      query.shareQuery.destroy();\n      query.shareQuery = null;\n    }\n\n    unsubscribeQueryCallback();\n  }\n  function unsubscribeQueryCallback(err) {\n    if (err) return cb(err);\n    // Cleanup when no fetches or subscribes remain\n    if (!query.fetchCount) query.destroy();\n    cb(null, 0);\n  }\n  return this;\n};\n\nQuery.prototype._getShareResults = function() {\n  var ids = this.model._get(this.idsSegments);\n  if (!ids) return;\n\n  var collection = this.model.getCollection(this.collectionName);\n  if (!collection) return;\n\n  var results = [];\n  for (var i = 0; i < ids.length; i++) {\n    var id = ids[i];\n    var doc = collection.docs[id];\n    results.push(doc && doc.shareDoc);\n  }\n  return results;\n};\n\nQuery.prototype.get = function() {\n  var results = [];\n  var data = this.model._get(this.segments);\n  if (!data) {\n    console.warn('You must fetch or subscribe to a query before getting its results.');\n    return results;\n  }\n  var ids = data.ids;\n  if (!ids) return results;\n\n  var collection = this.model.getCollection(this.collectionName);\n  for (var i = 0, l = ids.length; i < l; i++) {\n    var id = ids[i];\n    var doc = collection && collection.docs[id];\n    results.push(doc && doc.get());\n  }\n  return results;\n};\n\nQuery.prototype.getIds = function() {\n  return this.model._get(this.idsSegments) || [];\n};\n\nQuery.prototype.getExtra = function() {\n  return this.model._get(this.extraSegments);\n};\n\nQuery.prototype.ref = function(from) {\n  var idsPath = this.idsSegments.join('.');\n  return this.model.refList(from, this.collectionName, idsPath);\n};\n\nQuery.prototype.refIds = function(from) {\n  var idsPath = this.idsSegments.join('.');\n  return this.model.root.ref(from, idsPath);\n};\n\nQuery.prototype.refExtra = function(from, relPath) {\n  var extraPath = this.extraSegments.join('.');\n  if (relPath) extraPath += '.' + relPath;\n  return this.model.root.ref(from, extraPath);\n};\n\nQuery.prototype.serialize = function() {\n  var ids = this.getIds();\n  var collection = this.model.getCollection(this.collectionName);\n  var results;\n  if (collection) {\n    results = [];\n    for (var i = 0; i < ids.length; i++) {\n      var id = ids[i];\n      var doc = collection.docs[id];\n      if (doc) {\n        delete collection.docs[id];\n        var data = doc.shareDoc.data;\n        var result = [data, doc.shareDoc.version];\n        if (!data || data.id !== id) {\n          result[2] = id;\n        }\n        if (doc.shareDoc.type !== defaultType) {\n          result[3] = doc.shareDoc.type && doc.shareDoc.type.name;\n        }\n        results.push(result);\n      } else {\n        results.push(id);\n      }\n    }\n  }\n  var counts = [];\n  var contexts = this.model.root._contexts;\n  for (var key in contexts) {\n    var context = contexts[key];\n    var subscribed = context.subscribedQueries[this.hash] || 0;\n    var fetched = context.fetchedQueries[this.hash] || 0;\n    if (subscribed || fetched) {\n      if (key !== 'root') {\n        counts.push([subscribed, fetched, key]);\n      } else if (fetched) {\n        counts.push([subscribed, fetched]);\n      } else {\n        counts.push([subscribed]);\n      }\n    }\n  }\n  var serialized = [\n    counts,\n    this.collectionName,\n    this.expression,\n    results,\n    this.options,\n    this.getExtra()\n  ];\n  while (serialized[serialized.length - 1] == null) {\n    serialized.pop();\n  }\n  return serialized;\n};\n\nfunction queryHash(collectionName, expression, options) {\n  var args = [collectionName, expression, options];\n  return JSON.stringify(args).replace(/\\./g, '|');\n}\n\nfunction resultsIds(results) {\n  var ids = [];\n  for (var i = 0; i < results.length; i++) {\n    var shareDoc = results[i];\n    ids.push(shareDoc.id);\n  }\n  return ids;\n}\n",
    "/**\n * RemoteDoc adapts the ShareJS operation protocol to Racer's mutator\n * interface.\n *\n * 1. It maps Racer's mutator methods to outgoing ShareJS operations.\n * 2. It maps incoming ShareJS operations to Racer events.\n */\n\nvar Doc = require('./Doc');\nvar util = require('../util');\n\nmodule.exports = RemoteDoc;\n\nfunction RemoteDoc(model, collectionName, id, snapshot, collection) {\n  // This is a bit messy, but we have to immediately register this doc on the\n  // collection that added it, so that when we create the shareDoc and the\n  // connection emits the 'doc' event, we'll find this doc instead of\n  // creating a new one\n  if (collection) collection.docs[id] = this;\n\n  Doc.call(this, model, collectionName, id);\n  this.model = model.pass({$remote: true});\n  this.debugMutations = model.root.debug.remoteMutations;\n\n  // Get or create the Share document. Note that we must have already added\n  // this doc to the collection to avoid creating a duplicate doc\n  this.shareDoc = model.root.connection.get(collectionName, id);\n  this.shareDoc.ingestSnapshot(snapshot);\n  this._initShareDoc();\n}\n\nRemoteDoc.prototype = new Doc();\n\nRemoteDoc.prototype._initShareDoc = function() {\n  var doc = this;\n  var model = this.model;\n  var collectionName = this.collectionName;\n  var id = this.id;\n  var shareDoc = this.shareDoc;\n  // Override submitOp to disable all writes and perform a dry-run\n  if (model.root.debug.disableSubmit) {\n    shareDoc.submitOp = function() {};\n    shareDoc.create = function() {};\n    shareDoc.del = function() {};\n  }\n  // Subscribe to doc events\n  shareDoc.on('op', function(op, isLocal) {\n    // Don't emit on local operations, since they are emitted in the mutator\n    if (isLocal) return;\n    doc._updateCollectionData();\n    doc._onOp(op);\n  });\n  shareDoc.on('del', function(previous, isLocal) {\n    // Calling the shareDoc.del method does not emit an operation event,\n    // so we create the appropriate event here.\n    if (isLocal) return;\n    delete doc.collectionData[id];\n    model.emit('change', [collectionName, id], [undefined, previous, model._pass]);\n  });\n  shareDoc.on('create', function(isLocal) {\n    // Local creates should not emit an event, since they only happen\n    // implicitly as a result of another mutation, and that operation will\n    // emit the appropriate event. Remote creates can set the snapshot data\n    // without emitting an operation event, so an event needs to be emitted\n    // for them.\n    if (isLocal) return;\n    doc._updateCollectionData();\n    var value = shareDoc.data;\n    model.emit('change', [collectionName, id], [value, undefined, model._pass]);\n  });\n  shareDoc.on('error', function(err) {\n    model._emitError(err, collectionName + '.' + id);\n  });\n  shareDoc.on('load', function() {\n    doc._updateCollectionData();\n    var value = shareDoc.data;\n    // If we subscribe to an uncreated document, no need to emit 'load' event\n    if (value === undefined) return;\n    model.emit('load', [collectionName, id], [value, model._pass]);\n  });\n  this._updateCollectionData();\n};\n\nRemoteDoc.prototype._updateCollectionData = function() {\n  var data = this.shareDoc.data;\n  if (typeof data === 'object' && !Array.isArray(data) && data !== null) {\n    data.id = this.id;\n  }\n  this.collectionData[this.id] = data;\n};\n\nRemoteDoc.prototype.create = function(value, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc create', this.path(), value);\n  }\n  // We copy the snapshot data at time of create to prevent the id added\n  // outside of ShareJS from getting stored in the data\n  var data = util.deepCopy(value);\n  if (data) delete data.id;\n  this.shareDoc.create(data, cb);\n  // The id value will get added to the data that was passed in\n  this.shareDoc.data = value;\n  this._updateCollectionData();\n  this.model._context.createDoc(this.collectionName, this.id);\n  return;\n};\n\nRemoteDoc.prototype.set = function(segments, value, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc set', this.path(segments), value);\n  }\n  var previous = this._createImplied(segments);\n  var lastSegment = segments[segments.length - 1];\n  if (previous instanceof ImpliedOp) {\n    previous.value[lastSegment] = value;\n    this.shareDoc.submitOp(previous.op, cb);\n    this._updateCollectionData();\n    return;\n  }\n  var op = (util.isArrayIndex(lastSegment)) ?\n    [new ListReplaceOp(segments.slice(0, -1), lastSegment, previous, value)] :\n    [new ObjectReplaceOp(segments, previous, value)];\n  this.shareDoc.submitOp(op, cb);\n  this._updateCollectionData();\n  return previous;\n};\n\nRemoteDoc.prototype.del = function(segments, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc del', this.path(segments));\n  }\n  if (segments.length === 0) {\n    var previous = this.get();\n    this.shareDoc.del(cb);\n    delete this.collectionData[this.id];\n    return previous;\n  }\n  // Don't do anything if the value is already undefined, since\n  // the del method should not create anything\n  var previous = this.get(segments);\n  if (previous === undefined) {\n    cb();\n    return;\n  }\n  var op = [new ObjectDeleteOp(segments, previous)];\n  this.shareDoc.submitOp(op, cb);\n  this._updateCollectionData();\n  return previous;\n};\n\nRemoteDoc.prototype.increment = function(segments, byNumber, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc increment', this.path(segments), byNumber);\n  }\n  var previous = this._createImplied(segments);\n  if (previous instanceof ImpliedOp) {\n    var lastSegment = segments[segments.length - 1];\n    previous.value[lastSegment] = byNumber;\n    this.shareDoc.submitOp(previous.op, cb);\n    this._updateCollectionData();\n    return byNumber;\n  }\n  if (previous == null) {\n    var lastSegment = segments[segments.length - 1];\n    var op = (util.isArrayIndex(lastSegment)) ?\n      [new ListInsertOp(segments.slice(0, -1), lastSegment, byNumber)] :\n      [new ObjectInsertOp(segments, byNumber)];\n    this.shareDoc.submitOp(op, cb);\n    this._updateCollectionData();\n    return byNumber;\n  }\n  var op = [new IncrementOp(segments, byNumber)];\n  this.shareDoc.submitOp(op, cb);\n  this._updateCollectionData();\n  return previous + byNumber;\n};\n\nRemoteDoc.prototype.push = function(segments, value, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc push', this.path(segments), value);\n  }\n  var shareDoc = this.shareDoc;\n  function push(arr, fnCb) {\n    var op = [new ListInsertOp(segments, arr.length, value)];\n    shareDoc.submitOp(op, fnCb);\n    return arr.length;\n  }\n  return this._arrayApply(segments, push, cb);\n};\n\nRemoteDoc.prototype.unshift = function(segments, value, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc unshift', this.path(segments), value);\n  }\n  var shareDoc = this.shareDoc;\n  function unshift(arr, fnCb) {\n    var op = [new ListInsertOp(segments, 0, value)];\n    shareDoc.submitOp(op, fnCb);\n    return arr.length;\n  }\n  return this._arrayApply(segments, unshift, cb);\n};\n\nRemoteDoc.prototype.insert = function(segments, index, values, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc insert', this.path(segments), index, values);\n  }\n  var shareDoc = this.shareDoc;\n  function insert(arr, fnCb) {\n    var op = createInsertOp(segments, index, values);\n    shareDoc.submitOp(op, fnCb);\n    return arr.length;\n  }\n  return this._arrayApply(segments, insert, cb);\n};\n\nfunction createInsertOp(segments, index, values) {\n  if (!Array.isArray(values)) {\n    return [new ListInsertOp(segments, index, values)];\n  }\n  var op = [];\n  for (var i = 0, len = values.length; i < len; i++) {\n    op.push(new ListInsertOp(segments, index++, values[i]));\n  }\n  return op;\n}\n\nRemoteDoc.prototype.pop = function(segments, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc pop', this.path(segments));\n  }\n  var shareDoc = this.shareDoc;\n  function pop(arr, fnCb) {\n    var index = arr.length - 1;\n    var value = arr[index];\n    var op = [new ListRemoveOp(segments, index, value)];\n    shareDoc.submitOp(op, fnCb);\n    return value;\n  }\n  return this._arrayApply(segments, pop, cb);\n};\n\nRemoteDoc.prototype.shift = function(segments, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc shift', this.path(segments));\n  }\n  var shareDoc = this.shareDoc;\n  function shift(arr, fnCb) {\n    var value = arr[0];\n    var op = [new ListRemoveOp(segments, 0, value)];\n    shareDoc.submitOp(op, fnCb);\n    return value;\n  }\n  return this._arrayApply(segments, shift, cb);\n};\n\nRemoteDoc.prototype.remove = function(segments, index, howMany, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc remove', this.path(segments), index, howMany);\n  }\n  var shareDoc = this.shareDoc;\n  function remove(arr, fnCb) {\n    var values = arr.slice(index, index + howMany);\n    var op = [];\n    for (var i = 0, len = values.length; i < len; i++) {\n      op.push(new ListRemoveOp(segments, index, values[i]));\n    }\n    shareDoc.submitOp(op, fnCb);\n    return values;\n  }\n  return this._arrayApply(segments, remove, cb);\n};\n\nRemoteDoc.prototype.move = function(segments, from, to, howMany, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc move', this.path(segments), from, to, howMany);\n  }\n  var shareDoc = this.shareDoc;\n  function move(arr, fnCb) {\n    // Get the return value\n    var values = arr.slice(from, from + howMany);\n\n    // Build an op that moves each item individually\n    var op = [];\n    for (var i = 0; i < howMany; i++) {\n      op.push(new ListMoveOp(segments, (from < to) ? from : from + howMany - 1, (from < to) ? to + howMany - 1 : to));\n    }\n    shareDoc.submitOp(op, fnCb);\n\n    return values;\n  }\n  return this._arrayApply(segments, move, cb);\n};\n\nRemoteDoc.prototype.stringInsert = function(segments, index, value, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc stringInsert', this.path(segments), index, value);\n  }\n  var previous = this._createImplied(segments);\n  if (previous instanceof ImpliedOp) {\n    var lastSegment = segments[segments.length - 1];\n    previous.value[lastSegment] = value;\n    this.shareDoc.submitOp(previous.op, cb);\n    this._updateCollectionData();\n    return;\n  }\n  if (previous == null) {\n    var lastSegment = segments[segments.length - 1];\n    var op = (util.isArrayIndex(lastSegment)) ?\n      [new ListInsertOp(segments.slice(0, -1), lastSegment, value)] :\n      [new ObjectInsertOp(segments, value)];\n    this.shareDoc.submitOp(op, cb);\n    this._updateCollectionData();\n    return previous;\n  }\n  var op = [new StringInsertOp(segments, index, value)];\n  this.shareDoc.submitOp(op, cb);\n  this._updateCollectionData();\n  return previous;\n};\n\nRemoteDoc.prototype.stringRemove = function(segments, index, howMany, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc stringRemove', this.path(segments), index, howMany);\n  }\n  var previous = this._createImplied(segments);\n  if (previous instanceof ImpliedOp) return;\n  if (previous == null) return previous;\n  var removed = previous.slice(index, index + howMany);\n  var op = [new StringRemoveOp(segments, index, removed)];\n  this.shareDoc.submitOp(op, cb);\n  this._updateCollectionData();\n  return previous;\n};\n\nRemoteDoc.prototype.subtypeSubmit = function(segments, subtype, subtypeOp, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc subtypeSubmit', this.path(segments), subtype, subtypeOp);\n  }\n  var previous = this._createImplied(segments);\n  if (previous instanceof ImpliedOp) {\n    this.shareDoc.submitOp(previous.op);\n    previous = undefined;\n  }\n  var op = new SubtypeOp(segments, subtype, subtypeOp);\n  this.shareDoc.submitOp(op, cb);\n  this._updateCollectionData();\n  return previous;\n};\n\nRemoteDoc.prototype.get = function(segments) {\n  return util.lookup(segments, this.shareDoc.data);\n};\n\nRemoteDoc.prototype._createImplied = function(segments) {\n  if (!this.shareDoc.type) {\n    throw new Error('Mutation on uncreated remote document');\n  }\n  var parent = this.shareDoc;\n  var key = 'data';\n  var node = parent[key];\n  var i = 0;\n  var nextKey = segments[i++];\n  var op, value;\n  while (nextKey != null) {\n    if (!node) {\n      if (op) {\n        value = value[key] = util.isArrayIndex(nextKey) ? [] : {};\n      } else {\n        value = util.isArrayIndex(nextKey) ? [] : {};\n        if (Array.isArray(parent)) {\n          if (key >= parent.length) {\n            op = new ListInsertOp(segments.slice(0, i - 2), key, value);\n          } else {\n            op = new ListReplaceOp(segments.slice(0, i - 2), key, node, value);\n          }\n        } else {\n          op = new ObjectInsertOp(segments.slice(0, i - 1), value);\n        }\n      }\n      node = value;\n    }\n    parent = node;\n    key = nextKey;\n    node = parent[key];\n    nextKey = segments[i++];\n  }\n  if (op) return new ImpliedOp(op, value);\n  return node;\n};\n\nfunction ImpliedOp(op, value) {\n  this.op = op;\n  this.value = value;\n}\n\nRemoteDoc.prototype._arrayApply = function(segments, fn, cb) {\n  var arr = this._createImplied(segments);\n  if (arr instanceof ImpliedOp) {\n    this.shareDoc.submitOp(arr.op);\n    arr = this.get(segments);\n  }\n  if (arr == null) {\n    var lastSegment = segments[segments.length - 1];\n    var op = (util.isArrayIndex(lastSegment)) ?\n      [new ListInsertOp(segments.slice(0, -1), lastSegment, [])] :\n      [new ObjectInsertOp(segments, [])];\n    this.shareDoc.submitOp(op);\n    arr = this.get(segments);\n  }\n\n  if (!Array.isArray(arr)) {\n    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);\n    var err = new TypeError(message);\n    return cb(err);\n  }\n  var out = fn(arr, cb);\n  this._updateCollectionData();\n  return out;\n};\n\nRemoteDoc.prototype._onOp = function(op) {\n  var item;\n  if (op.length === 1) {\n    // ShareDB docs shatter json0 ops into single components during apply\n    item = op[0];\n  } else if (op.length === 0) {\n    // Ignore no-ops\n    return;\n  } else {\n    try {\n      op = JSON.stringify(op);\n    } catch (err) {}\n    throw new Error('Received op with multiple components from ShareDB ' + op);\n  }\n  var segments = [this.collectionName, this.id].concat(item.p);\n  var model = this.model;\n\n  // ObjectReplaceOp, ObjectInsertOp, or ObjectDeleteOp\n  if (defined(item.oi) || defined(item.od)) {\n    var value = item.oi;\n    var previous = item.od;\n    model.emit('change', segments, [value, previous, model._pass]);\n\n  // ListReplaceOp\n  } else if (defined(item.li) && defined(item.ld)) {\n    var value = item.li;\n    var previous = item.ld;\n    model.emit('change', segments, [value, previous, model._pass]);\n\n  // ListInsertOp\n  } else if (defined(item.li)) {\n    var index = segments[segments.length - 1];\n    var values = [item.li];\n    model.emit('insert', segments.slice(0, -1), [index, values, model._pass]);\n\n  // ListRemoveOp\n  } else if (defined(item.ld)) {\n    var index = segments[segments.length - 1];\n    var removed = [item.ld];\n    model.emit('remove', segments.slice(0, -1), [index, removed, model._pass]);\n\n  // ListMoveOp\n  } else if (defined(item.lm)) {\n    var from = segments[segments.length - 1];\n    var to = item.lm;\n    var howMany = 1;\n    model.emit('move', segments.slice(0, -1), [from, to, howMany, model._pass]);\n\n  // StringInsertOp\n  } else if (defined(item.si)) {\n    var index = segments[segments.length - 1];\n    var text = item.si;\n    segments = segments.slice(0, -1);\n    var value = model._get(segments);\n    var previous = value.slice(0, index) + value.slice(index + text.length);\n    var pass = model.pass({$stringInsert: {index: index, text: text}})._pass;\n    model.emit('change', segments, [value, previous, pass]);\n\n  // StringRemoveOp\n  } else if (defined(item.sd)) {\n    var index = segments[segments.length - 1];\n    var text = item.sd;\n    var howMany = text.length;\n    segments = segments.slice(0, -1);\n    var value = model._get(segments);\n    var previous = value.slice(0, index) + text + value.slice(index);\n    var pass = model.pass({$stringRemove: {index: index, howMany: howMany}})._pass;\n    model.emit('change', segments, [value, previous, pass]);\n\n  // IncrementOp\n  } else if (defined(item.na)) {\n    var value = this.get(item.p);\n    var previous = value - item.na;\n    model.emit('change', segments, [value, previous, model._pass]);\n\n  // SubtypeOp\n  } else if (defined(item.t)) {\n    var value = this.get(item.p);\n    // Since this is generic to all subtypes, we don't know how to get a copy\n    // of the previous value efficiently. We could make a copy eagerly, but\n    // given that embedded types are likely to be used for custom editors,\n    // we'll assume they primarily use the returned op and are unlikely to\n    // need the previous snapshot data\n    var previous = undefined;\n    var type = item.t;\n    var op = item.o;\n    var pass = model.pass({$subtype: {type: type, op: op}})._pass;\n    model.emit('change', segments, [value, previous, pass]);\n  }\n};\n\nfunction ObjectReplaceOp(segments, before, after) {\n  this.p = util.castSegments(segments);\n  this.od = before;\n  this.oi = (after === undefined) ? null : after;\n}\nfunction ObjectInsertOp(segments, value) {\n  this.p = util.castSegments(segments);\n  this.oi = (value === undefined) ? null : value;\n}\nfunction ObjectDeleteOp(segments, value) {\n  this.p = util.castSegments(segments);\n  this.od = (value === undefined) ? null : value;\n}\nfunction ListReplaceOp(segments, index, before, after) {\n  this.p = util.castSegments(segments.concat(index));\n  this.ld = before;\n  this.li = (after === undefined) ? null : after;\n}\nfunction ListInsertOp(segments, index, value) {\n  this.p = util.castSegments(segments.concat(index));\n  this.li = (value === undefined) ? null : value;\n}\nfunction ListRemoveOp(segments, index, value) {\n  this.p = util.castSegments(segments.concat(index));\n  this.ld = (value === undefined) ? null : value;\n}\nfunction ListMoveOp(segments, from, to) {\n  this.p = util.castSegments(segments.concat(from));\n  this.lm = to;\n}\nfunction StringInsertOp(segments, index, value) {\n  this.p = util.castSegments(segments.concat(index));\n  this.si = value;\n}\nfunction StringRemoveOp(segments, index, value) {\n  this.p = util.castSegments(segments.concat(index));\n  this.sd = value;\n}\nfunction IncrementOp(segments, byNumber) {\n  this.p = util.castSegments(segments);\n  this.na = byNumber;\n}\nfunction SubtypeOp(segments, subtype, subtypeOp) {\n  this.p = util.castSegments(segments);\n  this.t = subtype;\n  this.o = subtypeOp;\n}\n\nfunction defined(value) {\n  return value !== undefined;\n}\n",
    "var Model = require('./Model');\nvar LocalDoc = require('./LocalDoc');\nvar util = require('../util');\n\nfunction CollectionMap() {}\nfunction ModelData() {}\nfunction DocMap() {}\nfunction CollectionData() {}\n\nModel.INITS.push(function(model) {\n  model.root.collections = new CollectionMap();\n  model.root.data = new ModelData();\n});\n\nModel.prototype.getCollection = function(collectionName) {\n  return this.root.collections[collectionName];\n};\nModel.prototype.getDoc = function(collectionName, id) {\n  var collection = this.root.collections[collectionName];\n  return collection && collection.docs[id];\n};\nModel.prototype.get = function(subpath) {\n  var segments = this._splitPath(subpath);\n  return this._get(segments);\n};\nModel.prototype._get = function(segments) {\n  return util.lookup(segments, this.root.data);\n};\nModel.prototype.getCopy = function(subpath) {\n  var segments = this._splitPath(subpath);\n  return this._getCopy(segments);\n};\nModel.prototype._getCopy = function(segments) {\n  var value = this._get(segments);\n  return util.copy(value);\n};\nModel.prototype.getDeepCopy = function(subpath) {\n  var segments = this._splitPath(subpath);\n  return this._getDeepCopy(segments);\n};\nModel.prototype._getDeepCopy = function(segments) {\n  var value = this._get(segments);\n  return util.deepCopy(value);\n};\nModel.prototype.getOrCreateCollection = function(name) {\n  var collection = this.root.collections[name];\n  if (collection) return collection;\n  var Doc = this._getDocConstructor(name);\n  collection = new Collection(this.root, name, Doc);\n  this.root.collections[name] = collection;\n  return collection;\n};\nModel.prototype._getDocConstructor = function() {\n  // Only create local documents. This is overriden in ./connection.js, so that\n  // the RemoteDoc behavior can be selectively included\n  return LocalDoc;\n};\n\n/**\n * Returns an existing document with id in a collection. If the document does\n * not exist, then creates the document with id in a collection and returns the\n * new document.\n * @param {String} collectionName\n * @param {String} id\n * @param {Object} [data] data to create if doc with id does not exist in collection\n */\nModel.prototype.getOrCreateDoc = function(collectionName, id, data) {\n  var collection = this.getOrCreateCollection(collectionName);\n  return collection.docs[id] || collection.add(id, data);\n};\n\n/**\n * @param {String} subpath\n */\nModel.prototype.destroy = function(subpath) {\n  var segments = this._splitPath(subpath);\n  // Silently remove all types of listeners within subpath\n  var silentModel = this.silent();\n  silentModel.removeAllListeners(null, subpath);\n  silentModel._removeAllRefs(segments);\n  silentModel._stopAll(segments);\n  silentModel._removeAllFilters(segments);\n  // Silently remove all model data within subpath\n  if (segments.length === 0) {\n    this.root.collections = new CollectionMap();\n    // Delete each property of data instead of creating a new object so that\n    // it is possible to continue using a reference to the original data object\n    var data = this.root.data;\n    for (var key in data) {\n      delete data[key];\n    }\n  } else if (segments.length === 1) {\n    var collection = this.getCollection(segments[0]);\n    collection && collection.destroy();\n  } else {\n    silentModel._del(segments);\n  }\n};\n\nfunction Collection(model, name, Doc) {\n  this.model = model;\n  this.name = name;\n  this.Doc = Doc;\n  this.docs = new DocMap();\n  this.data = model.data[name] = new CollectionData();\n}\n\n/**\n * Adds a document with `id` and `data` to `this` Collection.\n * @param {String} id\n * @param {Object} data\n * @return {LocalDoc|RemoteDoc} doc\n */\nCollection.prototype.add = function(id, data) {\n  var doc = new this.Doc(this.model, this.name, id, data, this);\n  this.docs[id] = doc;\n  return doc;\n};\nCollection.prototype.destroy = function() {\n  delete this.model.collections[this.name];\n  delete this.model.data[this.name];\n};\n\n/**\n * Removes the document with `id` from `this` Collection. If there are no more\n * documents in the Collection after the given document is removed, then this\n * also destroys the Collection.\n * @param {String} id\n */\nCollection.prototype.remove = function(id) {\n  delete this.docs[id];\n  delete this.data[id];\n  if (noKeys(this.docs)) this.destroy();\n};\n\n/**\n * Returns an object that maps doc ids to fully resolved documents.\n * @return {Object}\n */\nCollection.prototype.get = function() {\n  return this.data;\n};\n\nfunction noKeys(object) {\n  // eslint-disable-next-line no-unused-vars\n  for (var key in object) {\n    return false;\n  }\n  return true;\n}\n",
    "var Connection = require('sharedb/lib/client').Connection;\nvar Model = require('./Model');\nvar LocalDoc = require('./LocalDoc');\nvar RemoteDoc = require('./RemoteDoc');\n\nModel.INITS.push(function(model) {\n  model.root._preventCompose = false;\n});\n\nModel.prototype.preventCompose = function() {\n  var model = this._child();\n  model._preventCompose = true;\n  return model;\n};\n\nModel.prototype.allowCompose = function() {\n  var model = this._child();\n  model._preventCompose = false;\n  return model;\n};\n\nModel.prototype.createConnection = function(bundle) {\n  // Model::_createSocket should be defined by the socket plugin\n  this.root.socket = this._createSocket(bundle);\n\n  // The Share connection will bind to the socket by defining the onopen,\n  // onmessage, etc. methods\n  var model = this;\n  this.root.connection = new Connection(this.root.socket);\n  this.root.connection.on('state', function(state, reason) {\n    model._setDiff(['$connection', 'state'], state);\n    model._setDiff(['$connection', 'reason'], reason);\n  });\n  this._set(['$connection', 'state'], 'connected');\n\n  this._finishCreateConnection();\n};\n\nModel.prototype._finishCreateConnection = function() {\n  var model = this;\n  this.root.connection.on('error', function(err) {\n    model._emitError(err);\n  });\n  // Share docs can be created by queries, so we need to register them\n  // with Racer as soon as they are created to capture their events\n  this.root.connection.on('doc', function(shareDoc) {\n    model.getOrCreateDoc(shareDoc.collection, shareDoc.id);\n  });\n};\n\nModel.prototype.connect = function() {\n  this.root.socket.open();\n};\nModel.prototype.disconnect = function() {\n  this.root.socket.close();\n};\nModel.prototype.reconnect = function() {\n  this.disconnect();\n  this.connect();\n};\n// Clean delayed disconnect\nModel.prototype.close = function(cb) {\n  cb = this.wrapCallback(cb);\n  var model = this;\n  this.whenNothingPending(function() {\n    model.root.socket.close();\n    cb();\n  });\n};\n\n// Returns a reference to the ShareDB agent if it is connected directly on the\n// server. Will return null if the ShareDB connection has been disconnected or\n// if we are not in the same process and we do not have a reference to the\n// server-side agent object\nModel.prototype.getAgent = function() {\n  return this.root.connection.agent;\n};\n\nModel.prototype._isLocal = function(name) {\n  // Whether the collection is local or remote is determined by its name.\n  // Collections starting with an underscore ('_') are for user-defined local\n  // collections, those starting with a dollar sign ('$'') are for\n  // framework-defined local collections, and all others are remote.\n  var firstCharcter = name.charAt(0);\n  return firstCharcter === '_' || firstCharcter === '$';\n};\n\nModel.prototype._getDocConstructor = function(name) {\n  return (this._isLocal(name)) ? LocalDoc : RemoteDoc;\n};\n\nModel.prototype.hasPending = function() {\n  return this.root.connection.hasPending();\n};\nModel.prototype.hasWritePending = function() {\n  return this.root.connection.hasWritePending();\n};\nModel.prototype.whenNothingPending = function(cb) {\n  return this.root.connection.whenNothingPending(cb);\n};\n",
    "/**\n * Contexts are useful for keeping track of the origin of subscribes.\n */\n\nvar Model = require('./Model');\nvar CollectionCounter = require('./CollectionCounter');\n\nModel.INITS.push(function(model) {\n  model.root._contexts = new Contexts();\n  model.root.setContext('root');\n});\n\nModel.prototype.context = function(id) {\n  var model = this._child();\n  model.setContext(id);\n  return model;\n};\n\nModel.prototype.setContext = function(id) {\n  this._context = this.getOrCreateContext(id);\n};\n\nModel.prototype.getOrCreateContext = function(id) {\n  var context = this.root._contexts[id] ||\n    (this.root._contexts[id] = new Context(this, id));\n  return context;\n};\n\nModel.prototype.unload = function(id) {\n  var context = (id) ? this.root._contexts[id] : this._context;\n  context && context.unload();\n};\n\nModel.prototype.unloadAll = function() {\n  var contexts = this.root._contexts;\n  for (var key in contexts) {\n    contexts[key].unload();\n  }\n};\n\nfunction Contexts() {}\n\nfunction FetchedQueries() {}\nfunction SubscribedQueries() {}\n\nfunction Context(model, id) {\n  this.model = model;\n  this.id = id;\n  this.fetchedDocs = new CollectionCounter();\n  this.subscribedDocs = new CollectionCounter();\n  this.createdDocs = new CollectionCounter();\n  this.fetchedQueries = new FetchedQueries();\n  this.subscribedQueries = new SubscribedQueries();\n}\n\nContext.prototype.toJSON = function() {\n  var fetchedDocs = this.fetchedDocs.toJSON();\n  var subscribedDocs = this.subscribedDocs.toJSON();\n  var createdDocs = this.createdDocs.toJSON();\n  if (!fetchedDocs && !subscribedDocs && !createdDocs) return;\n  return {\n    fetchedDocs: fetchedDocs,\n    subscribedDocs: subscribedDocs,\n    createdDocs: createdDocs\n  };\n};\n\nContext.prototype.fetchDoc = function(collectionName, id) {\n  this.fetchedDocs.increment(collectionName, id);\n};\nContext.prototype.subscribeDoc = function(collectionName, id) {\n  this.subscribedDocs.increment(collectionName, id);\n};\nContext.prototype.unfetchDoc = function(collectionName, id) {\n  this.fetchedDocs.decrement(collectionName, id);\n};\nContext.prototype.unsubscribeDoc = function(collectionName, id) {\n  this.subscribedDocs.decrement(collectionName, id);\n};\nContext.prototype.createDoc = function(collectionName, id) {\n  this.createdDocs.increment(collectionName, id);\n};\nContext.prototype.fetchQuery = function(query) {\n  mapIncrement(this.fetchedQueries, query.hash);\n};\nContext.prototype.subscribeQuery = function(query) {\n  mapIncrement(this.subscribedQueries, query.hash);\n};\nContext.prototype.unfetchQuery = function(query) {\n  mapDecrement(this.fetchedQueries, query.hash);\n};\nContext.prototype.unsubscribeQuery = function(query) {\n  mapDecrement(this.subscribedQueries, query.hash);\n};\nfunction mapIncrement(map, key) {\n  map[key] = (map[key] || 0) + 1;\n}\nfunction mapDecrement(map, key) {\n  map[key] && map[key]--;\n  if (!map[key]) delete map[key];\n}\n\nContext.prototype.unload = function() {\n  var model = this.model;\n  for (var hash in this.fetchedQueries) {\n    var query = model.root._queries.map[hash];\n    if (!query) continue;\n    var count = this.fetchedQueries[hash];\n    while (count--) query.unfetch();\n  }\n  for (var hash in this.subscribedQueries) {\n    var query = model.root._queries.map[hash];\n    if (!query) continue;\n    var count = this.subscribedQueries[hash];\n    while (count--) query.unsubscribe();\n  }\n  for (var collectionName in this.fetchedDocs.collections) {\n    var collection = this.fetchedDocs.collections[collectionName];\n    for (var id in collection) {\n      var count = collection[id];\n      while (count--) model.unfetchDoc(collectionName, id);\n    }\n  }\n  for (var collectionName in this.subscribedDocs.collections) {\n    var collection = this.subscribedDocs.collections[collectionName];\n    for (var id in collection) {\n      var count = collection[id];\n      while (count--) model.unsubscribeDoc(collectionName, id);\n    }\n  }\n  for (var collectionName in this.createdDocs.collections) {\n    var collection = this.createdDocs.collections[collectionName];\n    for (var id in collection) {\n      model._maybeUnloadDoc(collectionName, id);\n    }\n  }\n  this.createdDocs.reset();\n};\n",
    "var defaultFns = module.exports = new DefaultFns();\n\ndefaultFns.reverse = new FnPair(getReverse, setReverse);\ndefaultFns.asc = asc;\ndefaultFns.desc = desc;\n\nfunction DefaultFns() {}\nfunction FnPair(get, set) {\n  this.get = get;\n  this.set = set;\n}\n\nfunction getReverse(array) {\n  return array && array.slice().reverse();\n}\nfunction setReverse(values) {\n  return {0: getReverse(values)};\n}\n\nfunction asc(a, b) {\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n}\nfunction desc(a, b) {\n  if (a > b) return -1;\n  if (a < b) return 1;\n  return 0;\n}\n",
    "// @ts-check\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('../util');\n/** @type any */\nvar Model = require('./Model');\n\n// These events are re-emitted as 'all' events, and they are queued up and\n// emitted in sequence, so that events generated by other events are not\n// seen in a different order by later listeners\nModel.MUTATOR_EVENTS = {\n  change: true,\n  insert: true,\n  remove: true,\n  move: true,\n  load: true,\n  unload: true\n};\n\nModel.INITS.push(function(model) {\n  EventEmitter.call(this);\n\n  // Set max listeners to unlimited\n  model.setMaxListeners(0);\n\n  // Used in async methods to emit an error event if a callback is not supplied.\n  // This will throw if there is no handler for model.on('error')\n  model.root._defaultCallback = defaultCallback;\n  function defaultCallback(err) {\n    if (err) model._emitError(err);\n  }\n\n  model.root._mutatorEventQueue = null;\n  model.root._pass = new Passed({}, {});\n  model.root._silent = null;\n  model.root._eventContext = null;\n});\n\nutil.mergeInto(Model.prototype, EventEmitter.prototype);\n\nModel.prototype.wrapCallback = function(cb) {\n  if (!cb) return this.root._defaultCallback;\n  var model = this;\n  return function wrappedCallback() {\n    try {\n      return cb.apply(this, arguments);\n    } catch (err) {\n      model._emitError(err);\n    }\n  };\n};\n\nModel.prototype._emitError = function(err, context) {\n  var message = (err.message) ? err.message :\n    (typeof err === 'string') ? err :\n      'Unknown model error';\n  if (context) {\n    message += ' ' + context;\n  }\n  if (err.data) {\n    try {\n      message += ' ' + JSON.stringify(err.data);\n    } catch (stringifyErr) {}\n  }\n  if (err instanceof Error) {\n    err.message = message;\n  } else {\n    err = new Error(message);\n  }\n  this.emit('error', err);\n};\n\n// EventEmitter.prototype.on, EventEmitter.prototype.addListener, and\n// EventEmitter.prototype.once return `this`. The Model equivalents return\n// the listener instead, since it is made internally for method subscriptions\n// and may need to be passed to removeListener.\n\nModel.prototype._emit = EventEmitter.prototype.emit;\nModel.prototype.emit = function(type) {\n  if (type === 'error') {\n    return this._emit.apply(this, arguments);\n  }\n  if (Model.MUTATOR_EVENTS[type]) {\n    if (this._silent) return this;\n    // `segments` is almost definitely an array of strings.\n    //\n    // A search for `.emit(` shows that `segments` is generated from either\n    // `Model#_splitPath` or `Model#_dereference`, both of which return an array\n    // of strings.\n    var segments = arguments[1];\n    var eventArgs = arguments[2];\n    this._emit(type + 'Immediate', segments, eventArgs);\n    if (this.root._mutatorEventQueue) {\n      this.root._mutatorEventQueue.push([type, segments, eventArgs]);\n      return this;\n    }\n    this.root._mutatorEventQueue = [];\n    this._emit(type, segments, eventArgs);\n    this._emit('all', segments, [type].concat(eventArgs));\n    while (this.root._mutatorEventQueue.length) {\n      var queued = this.root._mutatorEventQueue.shift();\n      type = queued[0];\n      segments = queued[1];\n      eventArgs = queued[2];\n      this._emit(type, segments, eventArgs);\n      this._emit('all', segments, [type].concat(eventArgs));\n    }\n    this.root._mutatorEventQueue = null;\n    return this;\n  }\n  return this._emit.apply(this, arguments);\n};\n\nModel.prototype._on = EventEmitter.prototype.on;\nModel.prototype.addListener =\nModel.prototype.on = function(type, pattern, options, cb) {\n  var listener = eventListener(this, type, pattern, options, cb);\n  this._on(type, listener);\n  return listener;\n};\n\nModel.prototype.once = function(type, pattern, options, cb) {\n  var listener = eventListener(this, type, pattern, options, cb);\n  function g() {\n    var matches = listener.apply(null, arguments);\n    if (matches) this.removeListener(type, g);\n  }\n  this._on(type, g);\n  return g;\n};\n\n/**\n * @typedef {Object} ModelOnOptions\n * @property {boolean} [useEventObjects] - If true, the listener is called with\n *   `cb(event: ___Event, captures: string[])`, instead of the legacy var-args\n *   style `cb(captures..., [eventType], eventArgs..., passed)`.\n */\n\nModel.prototype._removeAllListeners = EventEmitter.prototype.removeAllListeners;\nModel.prototype.removeAllListeners = function(type, subpattern) {\n  // If a pattern is specified without an event type, remove all model event\n  // listeners under that pattern for all events\n  if (!type) {\n    for (var key in this._events) {\n      this.removeAllListeners(key, subpattern);\n    }\n    return this;\n  }\n\n  var pattern = this.path(subpattern);\n  // If no pattern is specified, remove all listeners like normal\n  if (!pattern) {\n    if (arguments.length === 0) {\n      return this._removeAllListeners();\n    }\n    return this._removeAllListeners(type);\n  }\n\n  // Remove all listeners for an event under a pattern\n  var listeners = this.listeners(type);\n  var segments = pattern.split('.');\n  // Make sure to iterate in reverse, since the array might be\n  // mutated as listeners are removed\n  for (var i = listeners.length; i--;) {\n    var listener = listeners[i];\n    if (patternContained(pattern, segments, listener)) {\n      this.removeListener(type, listener);\n    }\n  }\n  return this;\n};\n\nfunction patternContained(pattern, segments, listener) {\n  var listenerSegments = listener.patternSegments;\n  if (!listenerSegments) return false;\n  if (pattern === listener.pattern || pattern === '**') return true;\n  var len = segments.length;\n  if (len > listenerSegments.length) return false;\n  for (var i = 0; i < len; i++) {\n    if (segments[i] !== listenerSegments[i]) return false;\n  }\n  return true;\n}\n\nModel.prototype.pass = function(object, invert) {\n  var model = this._child();\n  model._pass = (invert) ?\n    new Passed(object, this._pass) :\n    new Passed(this._pass, object);\n  return model;\n};\n\nfunction Passed(previous, value) {\n  for (var key in previous) {\n    this[key] = previous[key];\n  }\n  for (var key in value) {\n    this[key] = value[key];\n  }\n}\n\n/**\n * The returned Model will or won't trigger event handlers when the model emits\n * events, depending on `value`\n * @param {Boolean|Null} value defaults to true\n * @return {Model}\n */\nModel.prototype.silent = function(value) {\n  var model = this._child();\n  model._silent = (value == null) ? true : value;\n  return model;\n};\n\nModel.prototype.eventContext = function(value) {\n  var model = this._child();\n  model._eventContext = value;\n  return model;\n};\n\nModel.prototype.removeContextListeners = function(value) {\n  if (arguments.length === 0) {\n    value = this._eventContext;\n  }\n  // Remove all events created within a given context\n  for (var type in this._events) {\n    var listeners = this.listeners(type);\n    // Make sure to iterate in reverse, since the array might be\n    // mutated as listeners are removed\n    for (var i = listeners.length; i--;) {\n      var listener = listeners[i];\n      if (listener.eventContext === value) {\n        this.removeListener(type, listener);\n      }\n    }\n  }\n  return this;\n};\n\n/**\n * @param {Model} model\n * @param {string} eventType\n */\nfunction eventListener(model, eventType, arg2, arg3, arg4) {\n  var subpattern, options, cb;\n  if (arg4) {\n    // on(eventType, path, options, cb)\n    subpattern = arg2;\n    options = arg3;\n    cb = arg4;\n  } else if (arg3) {\n    // on(eventType, path, cb)\n    // on(eventType, options, cb)\n    cb = arg3;\n    if (model.isPath(arg2)) {\n      subpattern = arg2;\n    } else {\n      options = arg2;\n    }\n  } else { // if (arg2)\n    // on(eventType, cb)\n    cb = arg2;\n  }\n  if (options) {\n    if (options.useEventObjects) {\n      var useEventObjects = true;\n    }\n  }\n\n  if (subpattern) {\n    // For signatures with pattern:\n    // model.on('change', 'example.subpath.**', callback)\n    // model.at('example').on('change', 'subpath', callback)\n    var pattern = model.path(subpattern);\n    return (useEventObjects) ?\n      modelEventListener(eventType, pattern, cb, model._eventContext) :\n      modelEventListenerLegacy(pattern, cb, model._eventContext);\n  }\n  // For signature without explicit pattern:\n  // model.at('example').on('change', callback)\n  /** @type string */\n  var path = model.path();\n  if (path) {\n    return (useEventObjects) ?\n      modelEventListener(eventType, path, cb, model._eventContext) :\n      modelEventListenerLegacy(path, cb, model._eventContext);\n  }\n  // For signature:\n  // model.on('normalEvent', callback)\n  return cb;\n}\n\n/**\n * Legacy version of `modelEventListener` that calls `cb` with var-args\n * `(captures..., [eventType], args..., passed)` instead of new-style\n * `___Event` objects.\n *\n * @param {string} pattern\n * @param {Function} cb\n * @param {*} eventContext\n * @return {ModelListenerFn & ModelListenerProps}\n */\nfunction modelEventListenerLegacy(pattern, cb, eventContext) {\n  var patternSegments = util.castSegments(pattern.split('.'));\n  var testFn = testPatternFn(pattern, patternSegments);\n\n  /** @type ModelListenerFn */\n  function modelListener(segments, eventArgs) {\n    var captures = testFn(segments);\n    if (!captures) return;\n\n    var args = (captures.length) ? captures.concat(eventArgs) : eventArgs;\n    cb.apply(null, args);\n    return true;\n  }\n\n  // Used in Model#removeAllListeners\n  modelListener.pattern = pattern;\n  modelListener.patternSegments = patternSegments;\n  modelListener.eventContext = eventContext;\n\n  return modelListener;\n}\n\n/**\n * Returns a function that can be passed to `EventEmitter#on`, with some\n * additional properties used for `Model#removeAllListeners`.\n *\n * When the function is called, it checks if the event matches `patternArg`, and\n * if there's a match, it calls `cb`.\n *\n * @param {string} eventType\n * @param {string} pattern\n * @param {Function} cb\n * @param {*} eventContext\n * @return {ModelListenerFn & ModelListenerProps}\n */\nfunction modelEventListener(eventType, pattern, cb, eventContext) {\n  var patternSegments = util.castSegments(pattern.split('.'));\n  var testFn = testPatternFn(pattern, patternSegments);\n\n  var eventFactory = getEventFactory(eventType);\n  /** @type ModelListenerFn */\n  function modelListener(segments, eventArgs) {\n    var captures = testFn(segments);\n    if (!captures) return;\n\n    var event = eventFactory(eventArgs);\n    cb(event, captures);\n    return true;\n  }\n\n  // Used in Model#removeAllListeners\n  modelListener.pattern = pattern;\n  modelListener.patternSegments = patternSegments;\n  modelListener.eventContext = eventContext;\n\n  return modelListener;\n}\n\n/** @typedef { (segments: string[], eventArgs: any[]) => (boolean | undefined) } ModelListenerFn */\n/** @typedef { {pattern: string, patternSegments: Array<string | number>, eventContext: any} } ModelListenerProps */\n\n/**\n * Returns a factory function that creates an `___Event` object based on an\n * old-style `eventArgs` array.\n *\n * @param {string} eventType\n * @return {(eventArgs: any[]) => ChangeEvent | InsertEvent | RemoveEvent | MoveEvent | LoadEvent | UnloadEvent}\n */\nfunction getEventFactory(eventType) {\n  switch (eventType) {\n    case 'change':\n      return function(eventArgs) {\n        return new ChangeEvent(eventArgs);\n      };\n    case 'insert':\n      return function(eventArgs) {\n        return new InsertEvent(eventArgs);\n      };\n    case 'remove':\n      return function(eventArgs) {\n        return new RemoveEvent(eventArgs);\n      };\n    case 'move':\n      return function(eventArgs) {\n        return new MoveEvent(eventArgs);\n      };\n    case 'load':\n      return function(eventArgs) {\n        return new LoadEvent(eventArgs);\n      };\n    case 'unload':\n      return function(eventArgs) {\n        return new UnloadEvent(eventArgs);\n      };\n    case 'all':\n      return function(eventArgs) {\n        var concreteEventType = eventArgs[0]; // 'change', 'insert', etc.\n        var concreteEventFactory = getEventFactory(concreteEventType);\n        return concreteEventFactory(eventArgs.slice(1));\n      };\n    default: throw new Error('Unknown event: ' + eventType);\n  }\n}\n\n// These constructors accept the `eventArgs` array format that Racer uses\n// internally when calling `Model#emit`.\n//\n// Eventually, Racer should switch to passing these events around directly,\n// but that will require updating all the places that parse the `eventArgs`\n// array format, to extract things like `passed`.\n\nfunction ChangeEvent(eventArgs) {\n  this.value = eventArgs[0];\n  this.previous = eventArgs[1];\n  this.passed = eventArgs[2];\n}\nChangeEvent.prototype.type = 'change';\n\nfunction InsertEvent(eventArgs) {\n  this.index = eventArgs[0];\n  this.values = eventArgs[1];\n  this.passed = eventArgs[2];\n}\nInsertEvent.prototype.type = 'insert';\n\nfunction RemoveEvent(eventArgs) {\n  this.index = eventArgs[0];\n  this.removed = eventArgs[1];\n  this.passed = eventArgs[2];\n}\nRemoveEvent.prototype.type = 'remove';\n\nfunction MoveEvent(eventArgs) {\n  this.from = eventArgs[0];\n  this.to = eventArgs[1];\n  this.howMany = eventArgs[2];\n  this.passed = eventArgs[3];\n}\nMoveEvent.prototype.type = 'move';\n\nfunction LoadEvent(eventArgs) {\n  this.document = eventArgs[0];\n  this.passed = eventArgs[1];\n}\nLoadEvent.prototype.type = 'load';\n\nfunction UnloadEvent(eventArgs) {\n  this.previousDocument = eventArgs[0];\n  this.passed = eventArgs[1];\n}\nUnloadEvent.prototype.type = 'unload';\n\n/**\n * Returns a function that tests an array of event segments against the\n * `patternSegments`. (`pattern` only matters if it's exactly `'**'`.)\n *\n * @param {string?} pattern\n * @param {Array<string | number>} patternSegments\n * @return {(segments: string[]) => (string[] | undefined)} A function to test\n *   an array of event segments. If the event segments match, an array of 0 or\n *   more segments captured by `'*'` / `'**'` is returned, one per wildcard. If\n *   the event segments don't match, `undefined` is returned.\n */\nfunction testPatternFn(pattern, patternSegments) {\n  if (pattern === '**') {\n    return function testPattern(segments) {\n      return [segments.join('.')];\n    };\n  }\n\n  var endingRest = stripRestWildcard(patternSegments);\n\n  return function testPattern(segments) {\n    // Any pattern with more segments does not match\n    var patternLen = patternSegments.length;\n    if (patternLen > segments.length) return;\n\n    // A pattern with the same number of segments matches if each\n    // of the segments are wildcards or equal. A shorter pattern matches\n    // if it ends in a rest wildcard and each of the corresponding\n    // segments are wildcards or equal.\n    if (patternLen === segments.length || endingRest) {\n      /** @type string[] */\n      var captures = [];\n      for (var i = 0; i < patternLen; i++) {\n        var patternSegment = patternSegments[i];\n        var segment = segments[i];\n        if (patternSegment === '*' || patternSegment === '**') {\n          captures.push(segment);\n          continue;\n        }\n        if (patternSegment !== segment) return;\n      }\n      if (endingRest) {\n        var remainder = segments.slice(i).join('.');\n        captures.push(remainder);\n      }\n      return captures;\n    }\n  };\n}\n\n/**\n * @param {Array<string | number>} segments\n */\nfunction stripRestWildcard(segments) {\n  // ['example', '**'] -> ['example']; return true\n  var lastIndex = segments.length - 1;\n  var lastSegment = segments[lastIndex];\n  if (lastSegment === '**') {\n    segments.pop();\n    return true;\n  }\n  // ['example', 'subpath**'] -> ['example', 'subpath']; return true\n  if (typeof lastSegment !== 'string') return false;\n  var match = /^([^\\*]+)\\*\\*$/.exec(lastSegment);\n  if (!match) return false;\n  segments[lastIndex] = match[1];\n  return true;\n}\n",
    "var util = require('../util');\nvar Model = require('./Model');\nvar defaultFns = require('./defaultFns');\n\nModel.INITS.push(function(model) {\n  model.root._filters = new Filters(model);\n  model.on('all', filterListener);\n  function filterListener(segments, eventArgs) {\n    var pass = eventArgs[eventArgs.length - 1];\n    var map = model.root._filters.fromMap;\n    for (var path in map) {\n      var filter = map[path];\n      if (pass.$filter === filter) continue;\n      if (\n        util.mayImpact(filter.segments, segments) ||\n        (filter.inputsSegments && util.mayImpactAny(filter.inputsSegments, segments))\n      ) {\n        filter.update(pass);\n      }\n    }\n  }\n});\n\nfunction parseFilterArguments(model, args) {\n  var fn = args.pop();\n  var options, inputPaths;\n  var path = model.path(args.shift());\n\n  var last = args[args.length - 1];\n  if (!model.isPath(last) && !Array.isArray(last)) {\n    options = args.pop();\n  }\n  if (args.length === 1 && Array.isArray(args[0])) {\n    // inputPaths provided as one array:\n    //   model.filter(inputPath, [inputPath1, inputPath2], fn)\n    inputPaths = args[0];\n  } else {\n    // inputPaths provided as var-args:\n    //   model.filter(inputPath, inputPath1, inputPath2, fn)\n    inputPaths = args;\n  }\n  var i = inputPaths.length;\n  while (i--) {\n    inputPaths[i] = model.path(inputPaths[i]);\n  }\n  return {\n    path: path,\n    inputPaths: (inputPaths.length) ? inputPaths : null,\n    options: options,\n    fn: fn\n  };\n}\n\nModel.prototype.filter = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var parsed = parseFilterArguments(this, args);\n  return this.root._filters.add(\n    parsed.path,\n    parsed.fn,\n    null,\n    parsed.inputPaths,\n    parsed.options\n  );\n};\n\nModel.prototype.sort = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var parsed = parseFilterArguments(this, args);\n  return this.root._filters.add(\n    parsed.path,\n    null,\n    parsed.fn || 'asc',\n    parsed.inputPaths,\n    parsed.options\n  );\n};\n\nModel.prototype.removeAllFilters = function(subpath) {\n  var segments = this._splitPath(subpath);\n  this._removeAllFilters(segments);\n};\nModel.prototype._removeAllFilters = function(segments) {\n  var filters = this.root._filters.fromMap;\n  for (var from in filters) {\n    if (util.contains(segments, filters[from].fromSegments)) {\n      filters[from].destroy();\n    }\n  }\n};\n\nfunction FromMap() {}\nfunction Filters(model) {\n  this.model = model;\n  this.fromMap = new FromMap();\n}\n\nFilters.prototype.add = function(path, filterFn, sortFn, inputPaths, options) {\n  return new Filter(this, path, filterFn, sortFn, inputPaths, options);\n};\n\nFilters.prototype.toJSON = function() {\n  var out = [];\n  for (var from in this.fromMap) {\n    var filter = this.fromMap[from];\n    // Don't try to bundle if functions were passed directly instead of by name\n    if (!filter.bundle) continue;\n    var args = [from, filter.path, filter.filterName, filter.sortName, filter.inputPaths];\n    if (filter.options) args.push(filter.options);\n    out.push(args);\n  }\n  return out;\n};\n\nfunction Filter(filters, path, filterFn, sortFn, inputPaths, options) {\n  this.filters = filters;\n  this.model = filters.model.pass({$filter: this});\n  this.path = path;\n  this.segments = path.split('.');\n  this.filterName = null;\n  this.sortName = null;\n  this.bundle = true;\n  this.filterFn = null;\n  this.sortFn = null;\n  this.inputPaths = inputPaths;\n  this.inputsSegments = null;\n  if (inputPaths) {\n    this.inputsSegments = [];\n    for (var i = 0; i < this.inputPaths.length; i++) {\n      var segments = this.inputPaths[i].split('.');\n      this.inputsSegments.push(segments);\n    }\n  }\n  this.options = options;\n  this.skip = options && options.skip;\n  this.limit = options && options.limit;\n  if (filterFn) this.filter(filterFn);\n  if (sortFn) this.sort(sortFn);\n  this.idsSegments = null;\n  this.from = null;\n  this.fromSegments = null;\n}\n\nFilter.prototype.filter = function(fn) {\n  if (typeof fn === 'function') {\n    this.filterFn = fn;\n    this.bundle = false;\n    return this;\n  } else if (typeof fn === 'string') {\n    this.filterName = fn;\n    this.filterFn = this.model.root._namedFns[fn] || defaultFns[fn];\n    if (!this.filterFn) {\n      throw new TypeError('Filter function not found: ' + fn);\n    }\n  }\n  return this;\n};\n\nFilter.prototype.sort = function(fn) {\n  if (!fn) fn = 'asc';\n  if (typeof fn === 'function') {\n    this.sortFn = fn;\n    this.bundle = false;\n    return this;\n  } else if (typeof fn === 'string') {\n    this.sortName = fn;\n    this.sortFn = this.model.root._namedFns[fn] || defaultFns[fn];\n    if (!this.sortFn) {\n      throw new TypeError('Sort function not found: ' + fn);\n    }\n  }\n  return this;\n};\n\nFilter.prototype._slice = function(results) {\n  if (this.skip == null && this.limit == null) return results;\n  var begin = this.skip || 0;\n  // A limit of zero is equivalent to setting no limit\n  var end;\n  if (this.limit) end = begin + this.limit;\n  return results.slice(begin, end);\n};\n\nFilter.prototype.getInputs = function() {\n  if (!this.inputsSegments) return;\n  var inputs = [];\n  for (var i = 0, len = this.inputsSegments.length; i < len; i++) {\n    var input = this.model._get(this.inputsSegments[i]);\n    inputs.push(input);\n  }\n  return inputs;\n};\n\nFilter.prototype.callFilter = function(items, key, inputs) {\n  var item = items[key];\n  return (inputs) ?\n    this.filterFn.apply(this.model, [item, key, items].concat(inputs)) :\n    this.filterFn.call(this.model, item, key, items);\n};\n\nFilter.prototype.ids = function() {\n  var items = this.model._get(this.segments);\n  var ids = [];\n  if (!items) return ids;\n  if (Array.isArray(items)) {\n    throw new Error('model.filter is not currently supported on arrays');\n  }\n  if (this.filterFn) {\n    var inputs = this.getInputs();\n    for (var key in items) {\n      if (items.hasOwnProperty(key) && this.callFilter(items, key, inputs)) {\n        ids.push(key);\n      }\n    }\n  } else {\n    ids = Object.keys(items);\n  }\n  var sortFn = this.sortFn;\n  if (sortFn) {\n    ids.sort(function(a, b) {\n      return sortFn(items[a], items[b]);\n    });\n  }\n  return this._slice(ids);\n};\n\nFilter.prototype.get = function() {\n  var items = this.model._get(this.segments);\n  var results = [];\n  if (Array.isArray(items)) {\n    throw new Error('model.filter is not currently supported on arrays');\n  }\n  if (this.filterFn) {\n    var inputs = this.getInputs();\n    for (var key in items) {\n      if (items.hasOwnProperty(key) && this.callFilter(items, key, inputs)) {\n        results.push(items[key]);\n      }\n    }\n  } else {\n    for (var key in items) {\n      if (items.hasOwnProperty(key)) {\n        results.push(items[key]);\n      }\n    }\n  }\n  if (this.sortFn) results.sort(this.sortFn);\n  return this._slice(results);\n};\n\nFilter.prototype.update = function(pass) {\n  var ids = this.ids();\n  this.model.pass(pass, true)._setArrayDiff(this.idsSegments, ids);\n};\n\nFilter.prototype.ref = function(from) {\n  from = this.model.path(from);\n  this.from = from;\n  this.fromSegments = from.split('.');\n  this.filters.fromMap[from] = this;\n  this.idsSegments = ['$filters', from.replace(/\\./g, '|')];\n  this.update();\n  return this.model.refList(from, this.path, this.idsSegments.join('.'));\n};\n\nFilter.prototype.destroy = function() {\n  delete this.filters.fromMap[this.from];\n  this.model._removeRef(this.idsSegments);\n  this.model._del(this.idsSegments);\n};\n",
    "var util = require('../util');\nvar Model = require('./Model');\nvar defaultFns = require('./defaultFns');\n\nfunction NamedFns() {}\n\nModel.INITS.push(function(model) {\n  model.root._namedFns = new NamedFns();\n  model.root._fns = new Fns(model);\n  model.on('all', fnListener);\n  function fnListener(segments, eventArgs) {\n    var pass = eventArgs[eventArgs.length - 1];\n    var map = model.root._fns.fromMap;\n    for (var path in map) {\n      var fn = map[path];\n      if (pass.$fn === fn) continue;\n      if (util.mayImpactAny(fn.inputsSegments, segments)) {\n        // Mutation affecting input path\n        fn.onInput(pass);\n      } else if (util.mayImpact(fn.fromSegments, segments)) {\n        // Mutation affecting output path\n        fn.onOutput(pass);\n      }\n    }\n  }\n});\n\nModel.prototype.fn = function(name, fns) {\n  this.root._namedFns[name] = fns;\n};\n\nfunction parseStartArguments(model, args, hasPath) {\n  var last = args.pop();\n  var fns, name;\n  if (typeof last === 'string') {\n    name = last;\n  } else {\n    fns = last;\n  }\n  // For `Model#start`, the first parameter is the output path.\n  var path;\n  if (hasPath) {\n    path = model.path(args.shift());\n  }\n  // The second-to-last original argument could be an options object.\n  // If it's not an array and not path-like, then it's an options object.\n  last = args[args.length - 1];\n  var options;\n  if (!Array.isArray(last) && !model.isPath(last)) {\n    options = args.pop();\n  }\n\n  // `args` is just the input paths at this point.\n  var inputs;\n  if (args.length === 1 && Array.isArray(args[0])) {\n    // Inputs provided as one array:\n    //   model.start(outPath, [inPath1, inPath2], fn);\n    inputs = args[0];\n  } else {\n    // Inputs provided as var-args:\n    //   model.start(outPath, inPath1, inPath2, fn);\n    inputs = args;\n  }\n\n  // Normalize each input into a string path.\n  var i = inputs.length;\n  while (i--) {\n    inputs[i] = model.path(inputs[i]);\n  }\n  return {\n    name: name,\n    path: path,\n    inputPaths: inputs,\n    fns: fns,\n    options: options\n  };\n}\n\nModel.prototype.evaluate = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var parsed = parseStartArguments(this, args, false);\n  return this.root._fns.get(parsed.name, parsed.inputPaths, parsed.fns, parsed.options);\n};\n\nModel.prototype.start = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var parsed = parseStartArguments(this, args, true);\n  return this.root._fns.start(parsed.name, parsed.path, parsed.inputPaths, parsed.fns, parsed.options);\n};\n\nModel.prototype.stop = function(subpath) {\n  var path = this.path(subpath);\n  this._stop(path);\n};\nModel.prototype._stop = function(fromPath) {\n  this.root._fns.stop(fromPath);\n};\n\nModel.prototype.stopAll = function(subpath) {\n  var segments = this._splitPath(subpath);\n  this._stopAll(segments);\n};\nModel.prototype._stopAll = function(segments) {\n  var fns = this.root._fns.fromMap;\n  for (var from in fns) {\n    var fromSegments = fns[from].fromSegments;\n    if (util.contains(segments, fromSegments)) {\n      this._stop(from);\n    }\n  }\n};\n\nfunction FromMap() {}\nfunction Fns(model) {\n  this.model = model;\n  this.nameMap = model.root._namedFns;\n  this.fromMap = new FromMap();\n}\n\nFns.prototype.get = function(name, inputPaths, fns, options) {\n  fns || (fns = this.nameMap[name] || defaultFns[name]);\n  var fn = new Fn(this.model, name, null, inputPaths, fns, options);\n  return fn.get();\n};\n\nFns.prototype.start = function(name, path, inputPaths, fns, options) {\n  fns || (fns = this.nameMap[name] || defaultFns[name]);\n  var fn = new Fn(this.model, name, path, inputPaths, fns, options);\n  this.fromMap[path] = fn;\n  return fn._onInput();\n};\n\nFns.prototype.stop = function(path) {\n  var fn = this.fromMap[path];\n  delete this.fromMap[path];\n  return fn;\n};\n\nFns.prototype.toJSON = function() {\n  var out = [];\n  for (var from in this.fromMap) {\n    var fn = this.fromMap[from];\n    // Don't try to bundle non-named functions that were started via\n    // model.start directly instead of by name\n    if (!fn.name) continue;\n    var args = [fn.from].concat(fn.inputPaths);\n    if (fn.options) args.push(fn.options);\n    args.push(fn.name);\n    out.push(args);\n  }\n  return out;\n};\n\nfunction Fn(model, name, from, inputPaths, fns, options) {\n  this.model = model.pass({$fn: this});\n  this.name = name;\n  this.from = from;\n  this.inputPaths = inputPaths;\n  this.options = options;\n  if (!fns) {\n    throw new TypeError('Model function not found: ' + name);\n  }\n  this.getFn = fns.get || fns;\n  this.setFn = fns.set;\n  this.fromSegments = from && from.split('.');\n  this.inputsSegments = [];\n  for (var i = 0; i < this.inputPaths.length; i++) {\n    var segments = this.inputPaths[i].split('.');\n    this.inputsSegments.push(segments);\n  }\n\n  // Copy can be 'output', 'input', 'both', or 'none'\n  var copy = (options && options.copy) || 'output';\n  this.copyInput = (copy === 'input' || copy === 'both');\n  this.copyOutput = (copy === 'output' || copy === 'both');\n\n  // Mode can be 'diffDeep', 'diff', 'arrayDeep', or 'array'\n  this.mode = (options && options.mode) || 'diffDeep';\n\n  this.async = !!(options && options.async);\n  this.eventPending = false;\n}\n\nFn.prototype.apply = function(fn, inputs) {\n  for (var i = 0, len = this.inputsSegments.length; i < len; i++) {\n    var input = this.model._get(this.inputsSegments[i]);\n    inputs.push(this.copyInput ? util.deepCopy(input) : input);\n  }\n  return fn.apply(this.model, inputs);\n};\n\nFn.prototype.get = function() {\n  return this.apply(this.getFn, []);\n};\n\nFn.prototype.set = function(value, pass) {\n  if (!this.setFn) return;\n  var out = this.apply(this.setFn, [value]);\n  if (!out) return;\n  var inputsSegments = this.inputsSegments;\n  var model = this.model.pass(pass, true);\n  for (var key in out) {\n    var value = (this.copyOutput) ? util.deepCopy(out[key]) : out[key];\n    this._setValue(model, inputsSegments[key], value);\n  }\n};\n\nFn.prototype.onInput = function(pass) {\n  if (this.async) {\n    if (this.eventPending) return;\n    this.eventPending = true;\n    var fn = this;\n    process.nextTick(function() {\n      fn._onInput(pass);\n      fn.eventPending = false;\n    });\n    return;\n  }\n  return this._onInput(pass);\n};\n\nFn.prototype._onInput = function(pass) {\n  var value = (this.copyOutput) ? util.deepCopy(this.get()) : this.get();\n  this._setValue(this.model.pass(pass, true), this.fromSegments, value);\n  return value;\n};\n\nFn.prototype.onOutput = function(pass) {\n  var value = this.model._get(this.fromSegments);\n  return this.set(value, pass);\n};\n\nFn.prototype._setValue = function(model, segments, value) {\n  if (this.mode === 'diffDeep') {\n    model._setDiffDeep(segments, value);\n  } else if (this.mode === 'arrayDeep') {\n    model._setArrayDiffDeep(segments, value);\n  } else if (this.mode === 'array') {\n    model._setArrayDiff(segments, value);\n  } else {\n    model._setDiff(segments, value);\n  }\n};\n",
    "module.exports = require('./Model');\nvar util = require('../util');\n\n// Extend model on both server and client //\nrequire('./unbundle');\nrequire('./events');\nrequire('./paths');\nrequire('./collections');\nrequire('./mutators');\nrequire('./setDiff');\n\nrequire('./connection');\nrequire('./subscriptions');\nrequire('./Query');\nrequire('./contexts');\n\nrequire('./fn');\nrequire('./filter');\nrequire('./refList');\nrequire('./ref');\n\n// Extend model for server //\nutil.serverRequire(module, './bundle');\nutil.serverRequire(module, './connection.server');\n",
    "var util = require('../util');\nvar Model = require('./Model');\n\nModel.prototype._mutate = function(segments, fn, cb) {\n  cb = this.wrapCallback(cb);\n  var collectionName = segments[0];\n  var id = segments[1];\n  if (!collectionName || !id) {\n    var message = fn.name + ' must be performed under a collection ' +\n      'and document id. Invalid path: ' + segments.join('.');\n    return cb(new Error(message));\n  }\n  var doc = this.getOrCreateDoc(collectionName, id);\n  var docSegments = segments.slice(2);\n  if (this._preventCompose && doc.shareDoc) {\n    var oldPreventCompose = doc.shareDoc.preventCompose;\n    doc.shareDoc.preventCompose = true;\n    var out = fn(doc, docSegments, cb);\n    doc.shareDoc.preventCompose = oldPreventCompose;\n    return out;\n  }\n  return fn(doc, docSegments, cb);\n};\n\nModel.prototype.set = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._set(segments, value, cb);\n};\nModel.prototype._set = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function set(doc, docSegments, fnCb) {\n    var previous = doc.set(docSegments, value, fnCb);\n    // On setting the entire doc, remote docs sometimes do a copy to add the\n    // id without it being stored in the database by ShareJS\n    if (docSegments.length === 0) value = doc.get(docSegments);\n    model.emit('change', segments, [value, previous, model._pass]);\n    return previous;\n  }\n  return this._mutate(segments, set, cb);\n};\n\nModel.prototype.setNull = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setNull(segments, value, cb);\n};\nModel.prototype._setNull = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function setNull(doc, docSegments, fnCb) {\n    var previous = doc.get(docSegments);\n    if (previous != null) {\n      fnCb();\n      return previous;\n    }\n    doc.set(docSegments, value, fnCb);\n    model.emit('change', segments, [value, previous, model._pass]);\n    return value;\n  }\n  return this._mutate(segments, setNull, cb);\n};\n\nModel.prototype.setEach = function() {\n  var subpath, object, cb;\n  if (arguments.length === 1) {\n    object = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    object = arguments[1];\n  } else {\n    subpath = arguments[0];\n    object = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setEach(segments, object, cb);\n};\nModel.prototype._setEach = function(segments, object, cb) {\n  segments = this._dereference(segments);\n  var group = util.asyncGroup(this.wrapCallback(cb));\n  for (var key in object) {\n    var value = object[key];\n    this._set(segments.concat(key), value, group());\n  }\n};\n\nModel.prototype.create = function() {\n  var subpath, value, cb;\n  if (arguments.length === 0) {\n    value = {};\n  } else if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      value = {};\n      cb = arguments[0];\n    } else {\n      value = arguments[0];\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      value = arguments[0];\n      cb = arguments[1];\n    } else {\n      subpath = arguments[0];\n      value = arguments[1];\n    }\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._create(segments, value, cb);\n};\nModel.prototype._create = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  if (segments.length !== 2) {\n    var message = 'create may only be used on a document path. ' +\n      'Invalid path: ' + segments.join('.');\n    cb = this.wrapCallback(cb);\n    return cb(new Error(message));\n  }\n  var model = this;\n  function create(doc, docSegments, fnCb) {\n    var previous;\n    doc.create(value, fnCb);\n    // On creating the doc, remote docs do a copy to add the id without\n    // it being stored in the database by ShareJS\n    value = doc.get();\n    model.emit('change', segments, [value, previous, model._pass]);\n  }\n  this._mutate(segments, create, cb);\n};\n\nModel.prototype.createNull = function() {\n  var subpath, value, cb;\n  if (arguments.length === 0) {\n    value = {};\n  } else if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      value = {};\n      cb = arguments[0];\n    } else {\n      value = arguments[0];\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      value = arguments[0];\n      cb = arguments[1];\n    } else {\n      subpath = arguments[0];\n      value = arguments[1];\n    }\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._createNull(segments, value, cb);\n};\nModel.prototype._createNull = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  var doc = this.getDoc(segments[0], segments[1]);\n  if (doc && doc.get() != null) return;\n  this._create(segments, value, cb);\n};\n\nModel.prototype.add = function() {\n  var subpath, value, cb;\n  if (arguments.length === 0) {\n    value = {};\n  } else if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      value = {};\n      cb = arguments[0];\n    } else {\n      value = arguments[0];\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      value = arguments[0];\n      cb = arguments[1];\n    } else {\n      subpath = arguments[0];\n      value = arguments[1];\n    }\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._add(segments, value, cb);\n};\nModel.prototype._add = function(segments, value, cb) {\n  if (typeof value !== 'object') {\n    var message = 'add requires an object value. Invalid value: ' + value;\n    cb = this.wrapCallback(cb);\n    return cb(new Error(message));\n  }\n  var id = value.id || this.id();\n  value.id = id;\n  segments = this._dereference(segments.concat(id));\n  var model = this;\n  function add(doc, docSegments, fnCb) {\n    var previous;\n    if (docSegments.length) {\n      previous = doc.set(docSegments, value, fnCb);\n    } else {\n      doc.create(value, fnCb);\n      // On creating the doc, remote docs do a copy to add the id without\n      // it being stored in the database by ShareJS\n      value = doc.get();\n    }\n    model.emit('change', segments, [value, previous, model._pass]);\n  }\n  this._mutate(segments, add, cb);\n  return id;\n};\n\nModel.prototype.del = function() {\n  var subpath, cb;\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      cb = arguments[0];\n    } else {\n      subpath = arguments[0];\n    }\n  } else {\n    subpath = arguments[0];\n    cb = arguments[1];\n  }\n  var segments = this._splitPath(subpath);\n  return this._del(segments, cb);\n};\nModel.prototype._del = function(segments, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function del(doc, docSegments, fnCb) {\n    var previous = doc.del(docSegments, fnCb);\n    // When deleting an entire document, also remove the reference to the\n    // document object from its collection\n    if (segments.length === 2) {\n      var collectionName = segments[0];\n      var id = segments[1];\n      model.root.collections[collectionName].remove(id);\n    }\n    model.emit('change', segments, [undefined, previous, model._pass]);\n    return previous;\n  }\n  return this._mutate(segments, del, cb);\n};\n\nModel.prototype.increment = function() {\n  var subpath, byNumber, cb;\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      cb = arguments[0];\n    } else if (typeof arguments[0] === 'number') {\n      byNumber = arguments[0];\n    } else {\n      subpath = arguments[0];\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      cb = arguments[1];\n      if (typeof arguments[0] === 'number') {\n        byNumber = arguments[0];\n      } else {\n        subpath = arguments[0];\n      }\n    } else {\n      subpath = arguments[0];\n      byNumber = arguments[1];\n    }\n  } else {\n    subpath = arguments[0];\n    byNumber = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._increment(segments, byNumber, cb);\n};\nModel.prototype._increment = function(segments, byNumber, cb) {\n  segments = this._dereference(segments);\n  if (byNumber == null) byNumber = 1;\n  var model = this;\n  function increment(doc, docSegments, fnCb) {\n    var value = doc.increment(docSegments, byNumber, fnCb);\n    var previous = value - byNumber;\n    model.emit('change', segments, [value, previous, model._pass]);\n    return value;\n  }\n  return this._mutate(segments, increment, cb);\n};\n\nModel.prototype.push = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._push(segments, value, cb);\n};\nModel.prototype._push = function(segments, value, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function push(doc, docSegments, fnCb) {\n    var length = doc.push(docSegments, value, fnCb);\n    model.emit('insert', segments, [length - 1, [value], model._pass]);\n    return length;\n  }\n  return this._mutate(segments, push, cb);\n};\n\nModel.prototype.unshift = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._unshift(segments, value, cb);\n};\nModel.prototype._unshift = function(segments, value, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function unshift(doc, docSegments, fnCb) {\n    var length = doc.unshift(docSegments, value, fnCb);\n    model.emit('insert', segments, [0, [value], model._pass]);\n    return length;\n  }\n  return this._mutate(segments, unshift, cb);\n};\n\nModel.prototype.insert = function() {\n  var subpath, index, values, cb;\n  if (arguments.length < 2) {\n    throw new Error('Not enough arguments for insert');\n  } else if (arguments.length === 2) {\n    index = arguments[0];\n    values = arguments[1];\n  } else if (arguments.length === 3) {\n    subpath = arguments[0];\n    index = arguments[1];\n    values = arguments[2];\n  } else {\n    subpath = arguments[0];\n    index = arguments[1];\n    values = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  return this._insert(segments, +index, values, cb);\n};\nModel.prototype._insert = function(segments, index, values, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function insert(doc, docSegments, fnCb) {\n    var inserted = (Array.isArray(values)) ? values : [values];\n    var length = doc.insert(docSegments, index, inserted, fnCb);\n    model.emit('insert', segments, [index, inserted, model._pass]);\n    return length;\n  }\n  return this._mutate(segments, insert, cb);\n};\n\nModel.prototype.pop = function() {\n  var subpath, cb;\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      cb = arguments[0];\n    } else {\n      subpath = arguments[0];\n    }\n  } else {\n    subpath = arguments[0];\n    cb = arguments[1];\n  }\n  var segments = this._splitPath(subpath);\n  return this._pop(segments, cb);\n};\nModel.prototype._pop = function(segments, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function pop(doc, docSegments, fnCb) {\n    var arr = doc.get(docSegments);\n    var length = arr && arr.length;\n    if (!length) {\n      fnCb();\n      return;\n    }\n    var value = doc.pop(docSegments, fnCb);\n    model.emit('remove', segments, [length - 1, [value], model._pass]);\n    return value;\n  }\n  return this._mutate(segments, pop, cb);\n};\n\nModel.prototype.shift = function() {\n  var subpath, cb;\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      cb = arguments[0];\n    } else {\n      subpath = arguments[0];\n    }\n  } else {\n    subpath = arguments[0];\n    cb = arguments[1];\n  }\n  var segments = this._splitPath(subpath);\n  return this._shift(segments, cb);\n};\nModel.prototype._shift = function(segments, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function shift(doc, docSegments, fnCb) {\n    var arr = doc.get(docSegments);\n    var length = arr && arr.length;\n    if (!length) {\n      fnCb();\n      return;\n    }\n    var value = doc.shift(docSegments, fnCb);\n    model.emit('remove', segments, [0, [value], model._pass]);\n    return value;\n  }\n  return this._mutate(segments, shift, cb);\n};\n\nModel.prototype.remove = function() {\n  var subpath, index, howMany, cb;\n  if (arguments.length < 2) {\n    index = arguments[0];\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      cb = arguments[1];\n      if (typeof arguments[0] === 'number') {\n        index = arguments[0];\n      } else {\n        subpath = arguments[0];\n      }\n    } else {\n      // eslint-disable-next-line no-lonely-if\n      if (typeof arguments[0] === 'number') {\n        index = arguments[0];\n        howMany = arguments[1];\n      } else {\n        subpath = arguments[0];\n        index = arguments[1];\n      }\n    }\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      cb = arguments[2];\n      if (typeof arguments[0] === 'number') {\n        index = arguments[0];\n        howMany = arguments[1];\n      } else {\n        subpath = arguments[0];\n        index = arguments[1];\n      }\n    } else {\n      subpath = arguments[0];\n      index = arguments[1];\n      howMany = arguments[2];\n    }\n  } else {\n    subpath = arguments[0];\n    index = arguments[1];\n    howMany = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  if (index == null) index = segments.pop();\n  return this._remove(segments, +index, howMany, cb);\n};\nModel.prototype._remove = function(segments, index, howMany, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  if (howMany == null) howMany = 1;\n  var model = this;\n  function remove(doc, docSegments, fnCb) {\n    var removed = doc.remove(docSegments, index, howMany, fnCb);\n    model.emit('remove', segments, [index, removed, model._pass]);\n    return removed;\n  }\n  return this._mutate(segments, remove, cb);\n};\n\nModel.prototype.move = function() {\n  var subpath, from, to, howMany, cb;\n  if (arguments.length < 2) {\n    throw new Error('Not enough arguments for move');\n  } else if (arguments.length === 2) {\n    from = arguments[0];\n    to = arguments[1];\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      from = arguments[0];\n      to = arguments[1];\n      cb = arguments[2];\n    } else if (typeof arguments[0] === 'number') {\n      from = arguments[0];\n      to = arguments[1];\n      howMany = arguments[2];\n    } else {\n      subpath = arguments[0];\n      from = arguments[1];\n      to = arguments[2];\n    }\n  } else if (arguments.length === 4) {\n    if (typeof arguments[3] === 'function') {\n      cb = arguments[3];\n      if (typeof arguments[0] === 'number') {\n        from = arguments[0];\n        to = arguments[1];\n        howMany = arguments[2];\n      } else {\n        subpath = arguments[0];\n        from = arguments[1];\n        to = arguments[2];\n      }\n    } else {\n      subpath = arguments[0];\n      from = arguments[1];\n      to = arguments[2];\n      howMany = arguments[3];\n    }\n  } else {\n    subpath = arguments[0];\n    from = arguments[1];\n    to = arguments[2];\n    howMany = arguments[3];\n    cb = arguments[4];\n  }\n  var segments = this._splitPath(subpath);\n  return this._move(segments, from, to, howMany, cb);\n};\nModel.prototype._move = function(segments, from, to, howMany, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  if (howMany == null) howMany = 1;\n  var model = this;\n  function move(doc, docSegments, fnCb) {\n    // Cast to numbers\n    from = +from;\n    to = +to;\n    // Convert negative indices into positive\n    if (from < 0 || to < 0) {\n      var len = doc.get(docSegments).length;\n      if (from < 0) from += len;\n      if (to < 0) to += len;\n    }\n    var moved = doc.move(docSegments, from, to, howMany, fnCb);\n    model.emit('move', segments, [from, to, moved.length, model._pass]);\n    return moved;\n  }\n  return this._mutate(segments, move, cb);\n};\n\nModel.prototype.stringInsert = function() {\n  var subpath, index, text, cb;\n  if (arguments.length < 2) {\n    throw new Error('Not enough arguments for stringInsert');\n  } else if (arguments.length === 2) {\n    index = arguments[0];\n    text = arguments[1];\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      index = arguments[0];\n      text = arguments[1];\n      cb = arguments[2];\n    } else {\n      subpath = arguments[0];\n      index = arguments[1];\n      text = arguments[2];\n    }\n  } else {\n    subpath = arguments[0];\n    index = arguments[1];\n    text = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  return this._stringInsert(segments, index, text, cb);\n};\nModel.prototype._stringInsert = function(segments, index, text, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function stringInsert(doc, docSegments, fnCb) {\n    var previous = doc.stringInsert(docSegments, index, text, fnCb);\n    var value = doc.get(docSegments);\n    var pass = model.pass({$stringInsert: {index: index, text: text}})._pass;\n    model.emit('change', segments, [value, previous, pass]);\n    return;\n  }\n  return this._mutate(segments, stringInsert, cb);\n};\n\nModel.prototype.stringRemove = function() {\n  var subpath, index, howMany, cb;\n  if (arguments.length < 2) {\n    throw new Error('Not enough arguments for stringRemove');\n  } else if (arguments.length === 2) {\n    index = arguments[0];\n    howMany = arguments[1];\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      index = arguments[0];\n      howMany = arguments[1];\n      cb = arguments[2];\n    } else {\n      subpath = arguments[0];\n      index = arguments[1];\n      howMany = arguments[2];\n    }\n  } else {\n    subpath = arguments[0];\n    index = arguments[1];\n    howMany = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  return this._stringRemove(segments, index, howMany, cb);\n};\nModel.prototype._stringRemove = function(segments, index, howMany, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function stringRemove(doc, docSegments, fnCb) {\n    var previous = doc.stringRemove(docSegments, index, howMany, fnCb);\n    var value = doc.get(docSegments);\n    var pass = model.pass({$stringRemove: {index: index, howMany: howMany}})._pass;\n    model.emit('change', segments, [value, previous, pass]);\n    return;\n  }\n  return this._mutate(segments, stringRemove, cb);\n};\n\nModel.prototype.subtypeSubmit = function() {\n  var subpath, subtype, subtypeOp, cb;\n  if (arguments.length < 2) {\n    throw new Error('Not enough arguments for subtypeSubmit');\n  } else if (arguments.length === 2) {\n    subtype = arguments[0];\n    subtypeOp = arguments[1];\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      subtype = arguments[0];\n      subtypeOp = arguments[1];\n      cb = arguments[2];\n    } else {\n      subpath = arguments[0];\n      subtype = arguments[1];\n      subtypeOp = arguments[2];\n    }\n  } else {\n    subpath = arguments[0];\n    subtype = arguments[1];\n    subtypeOp = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  return this._subtypeSubmit(segments, subtype, subtypeOp, cb);\n};\n\nModel.prototype._subtypeSubmit = function(segments, subtype, subtypeOp, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function subtypeSubmit(doc, docSegments, fnCb) {\n    var previous = doc.subtypeSubmit(docSegments, subtype, subtypeOp, fnCb);\n    var value = doc.get(docSegments);\n    var pass = model.pass({$subtype: {type: subtype, op: subtypeOp}})._pass;\n    // Emit undefined for the previous value, since we don't really know\n    // whether or not the previous value returned by the subtypeSubmit is the\n    // same object returned by reference or not. This may cause change\n    // listeners to over-trigger, but that is usually going to be better than\n    // under-triggering\n    model.emit('change', segments, [value, undefined, pass]);\n    return previous;\n  }\n  return this._mutate(segments, subtypeSubmit, cb);\n};\n",
    "var Model = require('./Model');\n\nexports.mixin = {};\n\nModel.prototype._splitPath = function(subpath) {\n  var path = this.path(subpath);\n  return (path && path.split('.')) || [];\n};\n\n/**\n * Returns the path equivalent to the path of the current scoped model plus\n * (optionally) a suffix subpath\n *\n * @optional @param {String} subpath\n * @return {String} absolute path\n * @api public\n */\nModel.prototype.path = function(subpath) {\n  if (subpath == null || subpath === '') return (this._at) ? this._at : '';\n  if (typeof subpath === 'string' || typeof subpath === 'number') {\n    return (this._at) ? this._at + '.' + subpath : '' + subpath;\n  }\n  if (typeof subpath.path === 'function') return subpath.path();\n};\n\nModel.prototype.isPath = function(subpath) {\n  return this.path(subpath) != null;\n};\n\nModel.prototype.scope = function(path) {\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      path = path + '.' + arguments[i];\n    }\n  }\n  return createScoped(this, path);\n};\n\n/**\n * Create a model object scoped to a particular path.\n * Example:\n *     var user = model.at('users.1');\n *     user.set('username', 'brian');\n *     user.on('push', 'todos', function(todo) {\n *       // ...\n *     });\n *\n *  @param {String} segment\n *  @return {Model} a scoped model\n *  @api public\n */\nModel.prototype.at = function(subpath) {\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      subpath = subpath + '.' + arguments[i];\n    }\n  }\n  var path = this.path(subpath);\n  return createScoped(this, path);\n};\n\nfunction createScoped(model, path) {\n  var scoped = model._child();\n  scoped._at = path;\n  return scoped;\n}\n\n/**\n * Returns a model scope that is a number of levels above the current scoped\n * path. Number of levels defaults to 1, so this method called without\n * arguments returns the model scope's parent model scope.\n *\n * @optional @param {Number} levels\n * @return {Model} a scoped model\n */\nModel.prototype.parent = function(levels) {\n  if (levels == null) levels = 1;\n  var segments = this._splitPath();\n  var len = Math.max(0, segments.length - levels);\n  var path = segments.slice(0, len).join('.');\n  return this.scope(path);\n};\n\n/**\n * Returns the last property segment of the current model scope path\n *\n * @optional @param {String} path\n * @return {String}\n */\nModel.prototype.leaf = function(path) {\n  if (!path) path = this.path();\n  var i = path.lastIndexOf('.');\n  return path.slice(i + 1);\n};\n",
    "var util = require('../util');\nvar Model = require('./Model');\n\nModel.INITS.push(function(model) {\n  var root = model.root;\n  root._refs = new Refs();\n  addIndexListeners(root);\n  addListener(root, 'change', refChange);\n  addListener(root, 'load', refLoad);\n  addListener(root, 'unload', refUnload);\n  addListener(root, 'insert', refInsert);\n  addListener(root, 'remove', refRemove);\n  addListener(root, 'move', refMove);\n});\n\nfunction addIndexListeners(model) {\n  model.on('insertImmediate', function refInsertIndex(segments, eventArgs) {\n    var index = eventArgs[0];\n    var howMany = eventArgs[1].length;\n    function patchInsert(refIndex) {\n      return (index <= refIndex) ? refIndex + howMany : refIndex;\n    }\n    onIndexChange(segments, patchInsert);\n  });\n  model.on('removeImmediate', function refRemoveIndex(segments, eventArgs) {\n    var index = eventArgs[0];\n    var howMany = eventArgs[1].length;\n    function patchRemove(refIndex) {\n      return (index <= refIndex) ? refIndex - howMany : refIndex;\n    }\n    onIndexChange(segments, patchRemove);\n  });\n  model.on('moveImmediate', function refMoveIndex(segments, eventArgs) {\n    var from = eventArgs[0];\n    var to = eventArgs[1];\n    var howMany = eventArgs[2];\n    function patchMove(refIndex) {\n      // If the index was moved itself\n      if (from <= refIndex && refIndex < from + howMany) {\n        return refIndex + to - from;\n      }\n      // Remove part of a move\n      if (from <= refIndex) refIndex -= howMany;\n      // Insert part of a move\n      if (to <= refIndex) refIndex += howMany;\n      return refIndex;\n    }\n    onIndexChange(segments, patchMove);\n  });\n  function onIndexChange(segments, patch) {\n    var fromMap = model._refs.fromMap;\n    for (var from in fromMap) {\n      var ref = fromMap[from];\n      if (!(ref.updateIndices &&\n        util.contains(segments, ref.toSegments) &&\n        ref.toSegments.length > segments.length)) continue;\n      var index = +ref.toSegments[segments.length];\n      var patched = patch(index);\n      if (index === patched) continue;\n      model._refs.remove(from);\n      ref.toSegments[segments.length] = '' + patched;\n      ref.to = ref.toSegments.join('.');\n      model._refs.add(ref);\n    }\n  }\n}\n\nfunction refChange(model, dereferenced, eventArgs, segments) {\n  var value = eventArgs[0];\n  // Detect if we are deleting vs. setting to undefined\n  if (value === undefined) {\n    var parentSegments = segments.slice();\n    var last = parentSegments.pop();\n    var parent = model._get(parentSegments);\n    if (!parent || !(last in parent)) {\n      model._del(dereferenced);\n      return;\n    }\n  }\n  model._set(dereferenced, value);\n}\nfunction refLoad(model, dereferenced, eventArgs) {\n  var value = eventArgs[0];\n  model._set(dereferenced, value);\n}\nfunction refUnload(model, dereferenced) {\n  model._del(dereferenced);\n}\nfunction refInsert(model, dereferenced, eventArgs) {\n  var index = eventArgs[0];\n  var values = eventArgs[1];\n  model._insert(dereferenced, index, values);\n}\nfunction refRemove(model, dereferenced, eventArgs) {\n  var index = eventArgs[0];\n  var howMany = eventArgs[1].length;\n  model._remove(dereferenced, index, howMany);\n}\nfunction refMove(model, dereferenced, eventArgs) {\n  var from = eventArgs[0];\n  var to = eventArgs[1];\n  var howMany = eventArgs[2];\n  model._move(dereferenced, from, to, howMany);\n}\n\nfunction addListener(model, type, fn) {\n  model.on(type + 'Immediate', refListener);\n  function refListener(segments, eventArgs) {\n    var pass = eventArgs[eventArgs.length - 1];\n    // Find cases where an event is emitted on a path where a reference\n    // is pointing. All original mutations happen on the fully dereferenced\n    // location, so this detection only needs to happen in one direction\n    var toMap = model._refs.toMap;\n    var subpath;\n    for (var i = 0, len = segments.length; i < len; i++) {\n      subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];\n      // If a ref is found pointing to a matching subpath, re-emit on the\n      // place where the reference is coming from as if the mutation also\n      // occured at that path\n      var refs = toMap[subpath];\n      if (!refs) continue;\n\n      // Shallow clone refs in case a ref is removed while going through\n      // the loop\n      refs = refs.slice();\n      var remaining = segments.slice(i + 1);\n      for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {\n        var ref = refs[refIndex];\n        var dereferenced = ref.fromSegments.concat(remaining);\n        // The value may already be up to date via object reference. If so,\n        // simply re-emit the event. Otherwise, perform the same mutation on\n        // the ref's path\n        if (model._get(dereferenced) === model._get(segments)) {\n          model.emit(type, dereferenced, eventArgs);\n        } else {\n          var setterModel = ref.model.pass(pass, true);\n          setterModel._dereference = noopDereference;\n          fn(setterModel, dereferenced, eventArgs, segments);\n        }\n      }\n    }\n    // If a ref points to a child of a matching subpath, get the value in\n    // case it has changed and set if different\n    var parentToMap = model._refs.parentToMap;\n    var refs = parentToMap[subpath];\n    if (!refs) return;\n    for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {\n      var ref = refs[refIndex];\n      var value = model._get(ref.toSegments);\n      var previous = model._get(ref.fromSegments);\n      if (previous !== value) {\n        var setterModel = ref.model.pass(pass, true);\n        setterModel._dereference = noopDereference;\n        setterModel._set(ref.fromSegments, value);\n      }\n    }\n  }\n}\n\nModel.prototype._canRefTo = function(value) {\n  return this.isPath(value) || (value && typeof value.ref === 'function');\n};\n\nModel.prototype.ref = function() {\n  var from, to, options;\n  if (arguments.length === 1) {\n    to = arguments[0];\n  } else if (arguments.length === 2) {\n    if (this._canRefTo(arguments[1])) {\n      from = arguments[0];\n      to = arguments[1];\n    } else {\n      to = arguments[0];\n      options = arguments[1];\n    }\n  } else {\n    from = arguments[0];\n    to = arguments[1];\n    options = arguments[2];\n  }\n  var fromPath = this.path(from);\n  var toPath = this.path(to);\n  // Make ref to reffable object, such as query or filter\n  if (!toPath) return to.ref(fromPath);\n  var ref = new Ref(this.root, fromPath, toPath, options);\n  if (ref.fromSegments.length < 2) {\n    throw new Error('ref must be performed under a collection ' +\n      'and document id. Invalid path: ' + fromPath);\n  }\n  this.root._refs.remove(fromPath);\n  this.root._refLists.remove(fromPath);\n  var value = this.get(to);\n  ref.model._set(ref.fromSegments, value);\n  this.root._refs.add(ref);\n  return this.scope(fromPath);\n};\n\nModel.prototype.removeRef = function(subpath) {\n  var segments = this._splitPath(subpath);\n  var fromPath = segments.join('.');\n  this._removeRef(segments, fromPath);\n};\nModel.prototype._removeRef = function(segments, fromPath) {\n  this.root._refs.remove(fromPath);\n  this.root._refLists.remove(fromPath);\n  this._del(segments);\n};\n\nModel.prototype.removeAllRefs = function(subpath) {\n  var segments = this._splitPath(subpath);\n  this._removeAllRefs(segments);\n};\nModel.prototype._removeAllRefs = function(segments) {\n  this._removeMapRefs(segments, this.root._refs.fromMap);\n  this._removeMapRefs(segments, this.root._refLists.fromMap);\n};\nModel.prototype._removeMapRefs = function(segments, map) {\n  for (var from in map) {\n    var fromSegments = map[from].fromSegments;\n    if (util.contains(segments, fromSegments)) {\n      this._removeRef(fromSegments, from);\n    }\n  }\n};\n\nModel.prototype.dereference = function(subpath) {\n  var segments = this._splitPath(subpath);\n  return this._dereference(segments).join('.');\n};\n\nModel.prototype._dereference = function(segments, forArrayMutator, ignore) {\n  if (segments.length === 0) return segments;\n  var refs = this.root._refs.fromMap;\n  var refLists = this.root._refLists.fromMap;\n  var doAgain;\n  do {\n    var subpath = '';\n    doAgain = false;\n    for (var i = 0, len = segments.length; i < len; i++) {\n      subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];\n\n      var ref = refs[subpath];\n      if (ref) {\n        var remaining = segments.slice(i + 1);\n        segments = ref.toSegments.concat(remaining);\n        doAgain = true;\n        break;\n      }\n\n      var refList = refLists[subpath];\n      if (refList && refList !== ignore) {\n        var belowDescendant = i + 2 < len;\n        var belowChild = i + 1 < len;\n        if (!(belowDescendant || forArrayMutator && belowChild)) continue;\n        segments = refList.dereference(segments, i);\n        doAgain = true;\n        break;\n      }\n    }\n  } while (doAgain);\n  // If a dereference fails, return a path that will result in a null value\n  // instead of a path to everything in the model\n  if (segments.length === 0) return ['$null'];\n  return segments;\n};\n\nfunction noopDereference(segments) {\n  return segments;\n}\n\nfunction Ref(model, from, to, options) {\n  this.model = model && model.pass({$ref: this});\n  this.from = from;\n  this.to = to;\n  this.fromSegments = from.split('.');\n  this.toSegments = to.split('.');\n  this.parentTos = [];\n  for (var i = 1, len = this.toSegments.length; i < len; i++) {\n    var parentTo = this.toSegments.slice(0, i).join('.');\n    this.parentTos.push(parentTo);\n  }\n  this.updateIndices = options && options.updateIndices;\n}\nfunction FromMap() {}\nfunction ToMap() {}\n\nfunction Refs() {\n  this.fromMap = new FromMap();\n  this.toMap = new ToMap();\n  this.parentToMap = new ToMap();\n}\n\nRefs.prototype.add = function(ref) {\n  this.fromMap[ref.from] = ref;\n  listMapAdd(this.toMap, ref.to, ref);\n  for (var i = 0, len = ref.parentTos.length; i < len; i++) {\n    listMapAdd(this.parentToMap, ref.parentTos[i], ref);\n  }\n};\n\nRefs.prototype.remove = function(from) {\n  var ref = this.fromMap[from];\n  if (!ref) return;\n  delete this.fromMap[from];\n  listMapRemove(this.toMap, ref.to, ref);\n  for (var i = 0, len = ref.parentTos.length; i < len; i++) {\n    listMapRemove(this.parentToMap, ref.parentTos[i], ref);\n  }\n  return ref;\n};\n\nRefs.prototype.toJSON = function() {\n  var out = [];\n  for (var from in this.fromMap) {\n    var ref = this.fromMap[from];\n    out.push([ref.from, ref.to]);\n  }\n  return out;\n};\n\nfunction listMapAdd(map, name, item) {\n  map[name] || (map[name] = []);\n  map[name].push(item);\n}\n\nfunction listMapRemove(map, name, item) {\n  var items = map[name];\n  if (!items) return;\n  var index = items.indexOf(item);\n  if (index === -1) return;\n  items.splice(index, 1);\n  if (!items.length) delete map[name];\n}\n",
    "var util = require('../util');\nvar Model = require('./Model');\n\nModel.INITS.push(function(model) {\n  var root = model.root;\n  root._refLists = new RefLists();\n  for (var type in Model.MUTATOR_EVENTS) {\n    addListener(root, type);\n  }\n});\n\nfunction addListener(model, type) {\n  model.on(type + 'Immediate', refListListener);\n  function refListListener(segments, eventArgs) {\n    var pass = eventArgs[eventArgs.length - 1];\n    // Check for updates on or underneath paths\n    var fromMap = model._refLists.fromMap;\n    for (var from in fromMap) {\n      var refList = fromMap[from];\n      if (pass.$refList === refList) continue;\n      refList.onMutation(type, segments, eventArgs);\n    }\n  }\n}\n\n/**\n * @param {String} type\n * @param {Array} segments\n * @param {Array} eventArgs\n * @param {RefList} refList\n */\nfunction patchFromEvent(type, segments, eventArgs, refList) {\n  var fromLength = refList.fromSegments.length;\n  var segmentsLength = segments.length;\n  var pass = eventArgs[eventArgs.length - 1];\n  var model = refList.model.pass(pass, true);\n\n  // Mutation on the `from` output itself\n  if (segmentsLength === fromLength) {\n    if (type === 'insert') {\n      var index = eventArgs[0];\n      var values = eventArgs[1];\n      var ids = setNewToValues(model, refList, values);\n      model._insert(refList.idsSegments, index, ids);\n      return;\n    }\n\n    if (type === 'remove') {\n      var index = eventArgs[0];\n      var howMany = eventArgs[1].length;\n      var ids = model._remove(refList.idsSegments, index, howMany);\n      // Delete the appropriate items underneath `to` if the `deleteRemoved`\n      // option was set true\n      if (refList.deleteRemoved) {\n        for (var i = 0; i < ids.length; i++) {\n          var item = refList.itemById(ids[i]);\n          model._del(refList.toSegmentsByItem(item));\n        }\n      }\n      return;\n    }\n\n    if (type === 'move') {\n      var from = eventArgs[0];\n      var to = eventArgs[1];\n      var howMany = eventArgs[2];\n      model._move(refList.idsSegments, from, to, howMany);\n      return;\n    }\n\n    // Change of the entire output\n    var values = (type === 'change') ?\n      eventArgs[0] : model._get(refList.fromSegments);\n    // Set ids to empty list if output is set to null\n    if (!values) {\n      model._set(refList.idsSegments, []);\n      return;\n    }\n    // If the entire output is set, create a list of ids based on the output,\n    // and update the corresponding items\n    var ids = setNewToValues(model, refList, values);\n    model._set(refList.idsSegments, ids);\n    return;\n  }\n\n  // If mutation is on a parent of `from`, we might need to re-create the\n  // entire refList output\n  if (segmentsLength < fromLength) {\n    model._setArrayDiff(refList.fromSegments, refList.get());\n    return;\n  }\n\n  var index = segments[fromLength];\n  var value = model._get(refList.fromSegments.concat(index));\n  var toSegments = refList.toSegmentsByItem(value);\n\n  // Mutation underneath a child of the `from` object.\n  if (segmentsLength > fromLength + 1) {\n    throw new Error('Mutation on descendant of refList `from`' +\n      ' should have been dereferenced: ' + segments.join('.'));\n  }\n\n  // Otherwise, mutation of a child of the `from` object\n\n  // If changing the item itself, it will also have to be re-set on the\n  // original object\n  if (type === 'change') {\n    model._set(toSegments, value);\n    updateIdForValue(model, refList, index, value);\n    return;\n  }\n  if (type === 'insert' || type === 'remove' || type === 'move') {\n    throw new Error('Array mutation on child of refList `from`' +\n      'should have been dereferenced: ' + segments.join('.'));\n  }\n}\n\n/**\n * @private\n * @param {Model} model\n * @param {RefList} refList\n * @param {Array} values\n */\nfunction setNewToValues(model, refList, values) {\n  var ids = [];\n  for (var i = 0; i < values.length; i++) {\n    var value = values[i];\n    var id = refList.idByItem(value);\n    if (id === undefined && typeof value === 'object') {\n      id = value.id = model.id();\n    }\n    var toSegments = refList.toSegmentsByItem(value);\n    if (id === undefined || toSegments === undefined) {\n      throw new Error('Unable to add item to refList: ' + value);\n    }\n    if (model._get(toSegments) !== value) {\n      model._set(toSegments, value);\n    }\n    ids.push(id);\n  }\n  return ids;\n}\nfunction updateIdForValue(model, refList, index, value) {\n  var id = refList.idByItem(value);\n  var outSegments = refList.idsSegments.concat(index);\n  model._set(outSegments, id);\n}\n\nfunction patchToEvent(type, segments, eventArgs, refList) {\n  var toLength = refList.toSegments.length;\n  var segmentsLength = segments.length;\n  var pass = eventArgs[eventArgs.length - 1];\n  var model = refList.model.pass(pass, true);\n\n  // Mutation on the `to` object itself\n  if (segmentsLength === toLength) {\n    if (type === 'insert') {\n      var values = eventArgs[1];\n      for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        var indices = refList.indicesByItem(value);\n        if (!indices) continue;\n        for (var j = 0; j < indices.length; j++) {\n          var outSegments = refList.fromSegments.concat(indices[j]);\n          model._set(outSegments, value);\n        }\n      }\n      return;\n    }\n\n    if (type === 'remove') {\n      var removeIndex = eventArgs[0];\n      var values = eventArgs[1];\n      var howMany = values.length;\n      for (var i = removeIndex, len = removeIndex + howMany; i < len; i++) {\n        var indices = refList.indicesByItem(values[i]);\n        if (!indices) continue;\n        for (var j = 0, indicesLen = indices.length; j < indicesLen; j++) {\n          var outSegments = refList.fromSegments.concat(indices[j]);\n          model._set(outSegments, undefined);\n        }\n      }\n      return;\n    }\n\n    if (type === 'move') {\n      // Moving items in the `to` object should have no effect on the output\n      return;\n    }\n  }\n\n  // Mutation on or above the `to` object\n  if (segmentsLength <= toLength) {\n    // If the entire `to` object is updated, we need to re-create the\n    // entire refList output and apply what is different\n    model._setArrayDiff(refList.fromSegments, refList.get());\n    return;\n  }\n\n  // Mutation underneath a child of the `to` object. The item will already\n  // be up to date, since it is under an object reference. Just re-emit\n  if (segmentsLength > toLength + 1) {\n    var value = model._get(segments.slice(0, toLength + 1));\n    var indices = refList.indicesByItem(value);\n    if (!indices) return;\n    var remaining = segments.slice(toLength + 1);\n    for (var i = 0; i < indices.length; i++) {\n      var index = indices[i];\n      var dereferenced = refList.fromSegments.concat(index, remaining);\n      dereferenced = model._dereference(dereferenced, null, refList);\n      eventArgs = eventArgs.slice();\n      eventArgs[eventArgs.length - 1] = model._pass;\n      model.emit(type, dereferenced, eventArgs);\n    }\n    return;\n  }\n\n  // Otherwise, mutation of a child of the `to` object\n\n  // If changing the item itself, it will also have to be re-set on the\n  // array created by the refList\n  if (type === 'change' || type === 'load' || type === 'unload') {\n    var value, previous;\n    if (type === 'change') {\n      value = eventArgs[0];\n      previous = eventArgs[1];\n    } else if (type === 'load') {\n      value = eventArgs[0];\n      previous = undefined;\n    } else if (type === 'unload') {\n      value = undefined;\n      previous = eventArgs[0];\n    }\n    var newIndices = refList.indicesByItem(value);\n    var oldIndices = refList.indicesByItem(previous);\n    if (!newIndices && !oldIndices) return;\n    if (oldIndices && !equivalentArrays(oldIndices, newIndices)) {\n      // The changed item used to refer to some indices, but no longer does\n      for (var i = 0; i < oldIndices.length; i++) {\n        var outSegments = refList.fromSegments.concat(oldIndices[i]);\n        model._set(outSegments, undefined);\n      }\n    }\n    if (newIndices) {\n      for (var i = 0; i < newIndices.length; i++) {\n        var outSegments = refList.fromSegments.concat(newIndices[i]);\n        model._set(outSegments, value);\n      }\n    }\n    return;\n  }\n\n  var value = model._get(segments.slice(0, toLength + 1));\n  var indices = refList.indicesByItem(value);\n  if (!indices) return;\n\n  if (type === 'insert' || type === 'remove' || type === 'move') {\n    // Array mutations will have already been updated via an object\n    // reference, so only re-emit\n    for (var i = 0; i < indices.length; i++) {\n      var dereferenced = refList.fromSegments.concat(indices[i]);\n      dereferenced = model._dereference(dereferenced, null, refList);\n      eventArgs = eventArgs.slice();\n      eventArgs[eventArgs.length - 1] = model._pass;\n      model.emit(type, dereferenced, eventArgs);\n    }\n  }\n}\nfunction equivalentArrays(a, b) {\n  if (!a || !b) return false;\n  if (a.length !== b.length) return false;\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nfunction patchIdsEvent(type, segments, eventArgs, refList) {\n  var idsLength = refList.idsSegments.length;\n  var segmentsLength = segments.length;\n  var pass = eventArgs[eventArgs.length - 1];\n  var model = refList.model.pass(pass, true);\n\n  // An array mutation of the ids should be mirrored with a like change in\n  // the output array\n  if (segmentsLength === idsLength) {\n    if (type === 'insert') {\n      var index = eventArgs[0];\n      var inserted = eventArgs[1];\n      var values = [];\n      for (var i = 0; i < inserted.length; i++) {\n        var value = refList.itemById(inserted[i]);\n        values.push(value);\n      }\n      model._insert(refList.fromSegments, index, values);\n      return;\n    }\n\n    if (type === 'remove') {\n      var index = eventArgs[0];\n      var howMany = eventArgs[1].length;\n      model._remove(refList.fromSegments, index, howMany);\n      return;\n    }\n\n    if (type === 'move') {\n      var from = eventArgs[0];\n      var to = eventArgs[1];\n      var howMany = eventArgs[2];\n      model._move(refList.fromSegments, from, to, howMany);\n      return;\n    }\n  }\n\n  // Mutation on the `ids` list itself\n  if (segmentsLength <= idsLength) {\n    // If the entire `ids` array is updated, we need to re-create the\n    // entire refList output and apply what is different\n    model._setArrayDiff(refList.fromSegments, refList.get());\n    return;\n  }\n\n  // Otherwise, direct mutation of a child in the `ids` object or mutation\n  // underneath an item in the `ids` list. Update the item for the appropriate\n  // id if it has changed\n  var index = segments[idsLength];\n  var id = refList.idByIndex(index);\n  var item = refList.itemById(id);\n  var itemSegments = refList.fromSegments.concat(index);\n  if (model._get(itemSegments) !== item) {\n    model._set(itemSegments, item);\n  }\n}\n\nModel.prototype.refList = function() {\n  var from, to, ids, options;\n  if (arguments.length === 2) {\n    to = arguments[0];\n    ids = arguments[1];\n  } else if (arguments.length === 3) {\n    if (this.isPath(arguments[2])) {\n      from = arguments[0];\n      to = arguments[1];\n      ids = arguments[2];\n    } else {\n      to = arguments[0];\n      ids = arguments[1];\n      options = arguments[2];\n    }\n  } else {\n    from = arguments[0];\n    to = arguments[1];\n    ids = arguments[2];\n    options = arguments[3];\n  }\n  var fromPath = this.path(from);\n  var toPath;\n  if (Array.isArray(to)) {\n    toPath = [];\n    for (var i = 0; i < to.length; i++) {\n      toPath.push(this.path(to[i]));\n    }\n  } else {\n    toPath = this.path(to);\n  }\n  var idsPath = this.path(ids);\n  var refList = new RefList(this.root, fromPath, toPath, idsPath, options);\n  this.root._refLists.remove(fromPath);\n  refList.model._setArrayDiff(refList.fromSegments, refList.get());\n  this.root._refLists.add(refList);\n  return this.scope(fromPath);\n};\n\nfunction RefList(model, from, to, ids, options) {\n  this.model = model && model.pass({$refList: this});\n  this.from = from;\n  this.to = to;\n  this.ids = ids;\n  this.fromSegments = from && from.split('.');\n  this.toSegments = to && to.split('.');\n  this.idsSegments = ids && ids.split('.');\n  this.options = options;\n  this.deleteRemoved = options && options.deleteRemoved;\n}\n\n// The default implementation assumes that the ids array is a flat list of\n// keys on the to object. Ideally, this mapping could be customized via\n// inheriting from RefList and overriding these methods without having to\n// modify the above event handling code.\n//\n// In the default refList implementation, `key` and `id` are equal.\n//\n// Terms in the below methods:\n//   `item`  - Object on the `to` path, which gets mirrored on the `from` path\n//   `key`   - The property under `to` at which an item is located\n//   `id`    - String or object in the array at the `ids` path\n//   `index` - The index of an id, which corresponds to an index on `from`\nRefList.prototype.get = function() {\n  var ids = this.model._get(this.idsSegments);\n  if (!ids) return [];\n  var items = this.model._get(this.toSegments);\n  var out = [];\n  for (var i = 0; i < ids.length; i++) {\n    var key = ids[i];\n    out.push(items && items[key]);\n  }\n  return out;\n};\nRefList.prototype.dereference = function(segments, i) {\n  var remaining = segments.slice(i + 1);\n  var key = this.idByIndex(remaining[0]);\n  if (key == null) return [];\n  remaining[0] = key;\n  return this.toSegments.concat(remaining);\n};\nRefList.prototype.toSegmentsByItem = function(item) {\n  var key = this.idByItem(item);\n  if (key === undefined) return;\n  return this.toSegments.concat(key);\n};\nRefList.prototype.idByItem = function(item) {\n  if (item && item.id) return item.id;\n  var items = this.model._get(this.toSegments);\n  for (var key in items) {\n    if (item === items[key]) return key;\n  }\n};\nRefList.prototype.indicesByItem = function(item) {\n  var id = this.idByItem(item);\n  var ids = this.model._get(this.idsSegments);\n  if (!ids) return;\n  var indices;\n  var index = -1;\n  for (;;) {\n    index = ids.indexOf(id, index + 1);\n    if (index === -1) break;\n    if (indices) {\n      indices.push(index);\n    } else {\n      indices = [index];\n    }\n  }\n  return indices;\n};\nRefList.prototype.itemById = function(id) {\n  return this.model._get(this.toSegments.concat(id));\n};\nRefList.prototype.idByIndex = function(index) {\n  return this.model._get(this.idsSegments.concat(index));\n};\nRefList.prototype.onMutation = function(type, segments, eventArgs) {\n  if (util.mayImpact(this.toSegments, segments)) {\n    patchToEvent(type, segments, eventArgs, this);\n  } else if (util.mayImpact(this.idsSegments, segments)) {\n    patchIdsEvent(type, segments, eventArgs, this);\n  } else if (util.mayImpact(this.fromSegments, segments)) {\n    patchFromEvent(type, segments, eventArgs, this);\n  }\n};\n\nfunction FromMap() {}\n\nfunction RefLists() {\n  this.fromMap = new FromMap();\n}\n\nRefLists.prototype.add = function(refList) {\n  this.fromMap[refList.from] = refList;\n};\n\nRefLists.prototype.remove = function(from) {\n  var refList = this.fromMap[from];\n  delete this.fromMap[from];\n  return refList;\n};\n\nRefLists.prototype.toJSON = function() {\n  var out = [];\n  for (var from in this.fromMap) {\n    var refList = this.fromMap[from];\n    out.push([refList.from, refList.to, refList.ids, refList.options]);\n  }\n  return out;\n};\n",
    "var util = require('../util');\nvar Model = require('./Model');\nvar arrayDiff = require('arraydiff');\n\nModel.prototype.setDiff = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setDiff(segments, value, cb);\n};\nModel.prototype._setDiff = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function setDiff(doc, docSegments, fnCb) {\n    var previous = doc.get(docSegments);\n    if (util.equal(previous, value)) {\n      fnCb();\n      return previous;\n    }\n    doc.set(docSegments, value, fnCb);\n    model.emit('change', segments, [value, previous, model._pass]);\n    return previous;\n  }\n  return this._mutate(segments, setDiff, cb);\n};\n\nModel.prototype.setDiffDeep = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setDiffDeep(segments, value, cb);\n};\nModel.prototype._setDiffDeep = function(segments, value, cb) {\n  var before = this._get(segments);\n  cb = this.wrapCallback(cb);\n  var group = util.asyncGroup(cb);\n  var finished = group();\n  diffDeep(this, segments, before, value, group);\n  finished();\n};\nfunction diffDeep(model, segments, before, after, group) {\n  if (typeof before !== 'object' || !before ||\n      typeof after !== 'object' || !after) {\n    // Diff the entire value if not diffable objects\n    model._setDiff(segments, after, group());\n    return;\n  }\n  if (Array.isArray(before) && Array.isArray(after)) {\n    var diff = arrayDiff(before, after, util.deepEqual);\n    if (!diff.length) return;\n    // If the only change is a single item replacement, diff the item instead\n    if (\n      diff.length === 2 &&\n      diff[0].index === diff[1].index &&\n      diff[0] instanceof arrayDiff.RemoveDiff &&\n      diff[0].howMany === 1 &&\n      diff[1] instanceof arrayDiff.InsertDiff &&\n      diff[1].values.length === 1\n    ) {\n      var index = diff[0].index;\n      var itemSegments = segments.concat(index);\n      diffDeep(model, itemSegments, before[index], after[index], group);\n      return;\n    }\n    model._applyArrayDiff(segments, diff, group());\n    return;\n  }\n\n  // Delete keys that were in before but not after\n  for (var key in before) {\n    if (key in after) continue;\n    var itemSegments = segments.concat(key);\n    model._del(itemSegments, group());\n  }\n\n  // Diff each property in after\n  for (var key in after) {\n    if (util.deepEqual(before[key], after[key])) continue;\n    var itemSegments = segments.concat(key);\n    diffDeep(model, itemSegments, before[key], after[key], group);\n  }\n}\n\nModel.prototype.setArrayDiff = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setArrayDiff(segments, value, cb);\n};\nModel.prototype.setArrayDiffDeep = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setArrayDiffDeep(segments, value, cb);\n};\nModel.prototype._setArrayDiffDeep = function(segments, value, cb) {\n  return this._setArrayDiff(segments, value, cb, util.deepEqual);\n};\nModel.prototype._setArrayDiff = function(segments, value, cb, _equalFn) {\n  var before = this._get(segments);\n  if (before === value) return this.wrapCallback(cb)();\n  if (!Array.isArray(before) || !Array.isArray(value)) {\n    this._set(segments, value, cb);\n    return;\n  }\n  var diff = arrayDiff(before, value, _equalFn);\n  this._applyArrayDiff(segments, diff, cb);\n};\nModel.prototype._applyArrayDiff = function(segments, diff, cb) {\n  if (!diff.length) return this.wrapCallback(cb)();\n  segments = this._dereference(segments);\n  var model = this;\n  function applyArrayDiff(doc, docSegments, fnCb) {\n    var group = util.asyncGroup(fnCb);\n    for (var i = 0, len = diff.length; i < len; i++) {\n      var item = diff[i];\n      if (item instanceof arrayDiff.InsertDiff) {\n        // Insert\n        doc.insert(docSegments, item.index, item.values, group());\n        model.emit('insert', segments, [item.index, item.values, model._pass]);\n      } else if (item instanceof arrayDiff.RemoveDiff) {\n        // Remove\n        var removed = doc.remove(docSegments, item.index, item.howMany, group());\n        model.emit('remove', segments, [item.index, removed, model._pass]);\n      } else if (item instanceof arrayDiff.MoveDiff) {\n        // Move\n        var moved = doc.move(docSegments, item.from, item.to, item.howMany, group());\n        model.emit('move', segments, [item.from, item.to, moved.length, model._pass]);\n      }\n    }\n  }\n  return this._mutate(segments, applyArrayDiff, cb);\n};\n",
    "var util = require('../util');\nvar Model = require('./Model');\nvar Query = require('./Query');\nvar CollectionCounter = require('./CollectionCounter');\n\nModel.INITS.push(function(model, options) {\n  model.root.fetchOnly = options.fetchOnly;\n  model.root.unloadDelay = options.unloadDelay || (util.isServer) ? 0 : 1000;\n\n  // Track the total number of active fetches per doc\n  model.root._fetchedDocs = new CollectionCounter();\n  // Track the total number of active susbscribes per doc\n  model.root._subscribedDocs = new CollectionCounter();\n});\n\nModel.prototype.fetch = function() {\n  this._forSubscribable(arguments, 'fetch');\n  return this;\n};\nModel.prototype.unfetch = function() {\n  this._forSubscribable(arguments, 'unfetch');\n  return this;\n};\nModel.prototype.subscribe = function() {\n  this._forSubscribable(arguments, 'subscribe');\n  return this;\n};\nModel.prototype.unsubscribe = function() {\n  this._forSubscribable(arguments, 'unsubscribe');\n  return this;\n};\n\nModel.prototype._forSubscribable = function(argumentsObject, method) {\n  var args, cb;\n  if (!argumentsObject.length) {\n    // Use this model's scope if no arguments\n    args = [null];\n  } else if (typeof argumentsObject[0] === 'function') {\n    // Use this model's scope if the first argument is a callback\n    args = [null];\n    cb = argumentsObject[0];\n  } else if (Array.isArray(argumentsObject[0])) {\n    // Items can be passed in as an array\n    args = argumentsObject[0];\n    cb = argumentsObject[1];\n  } else {\n    // Or as multiple arguments\n    args = Array.prototype.slice.call(argumentsObject);\n    var last = args[args.length - 1];\n    if (typeof last === 'function') cb = args.pop();\n  }\n\n  var group = util.asyncGroup(this.wrapCallback(cb));\n  var finished = group();\n  var docMethod = method + 'Doc';\n\n  this.root.connection.startBulk();\n  for (var i = 0; i < args.length; i++) {\n    var item = args[i];\n    if (item instanceof Query) {\n      item[method](group());\n    } else {\n      var segments = this._dereference(this._splitPath(item));\n      if (segments.length === 2) {\n        // Do the appropriate method for a single document.\n        this[docMethod](segments[0], segments[1], group());\n      } else {\n        var message = 'Cannot ' + method + ' to path: ' + segments.join('.');\n        group()(new Error(message));\n      }\n    }\n  }\n  this.root.connection.endBulk();\n  process.nextTick(finished);\n};\n\nModel.prototype.fetchDoc = function(collectionName, id, cb) {\n  cb = this.wrapCallback(cb);\n\n  // Maintain a count of fetches so that we can unload the document\n  // when there are no remaining fetches or subscribes for that document\n  this._context.fetchDoc(collectionName, id);\n  this.root._fetchedDocs.increment(collectionName, id);\n\n  // Fetch\n  var doc = this.getOrCreateDoc(collectionName, id);\n  doc.shareDoc.fetch(cb);\n};\n\nModel.prototype.subscribeDoc = function(collectionName, id, cb) {\n  cb = this.wrapCallback(cb);\n\n  // Maintain a count of subscribes so that we can unload the document\n  // when there are no remaining fetches or subscribes for that document\n  this._context.subscribeDoc(collectionName, id);\n  this.root._subscribedDocs.increment(collectionName, id);\n\n  var doc = this.getOrCreateDoc(collectionName, id);\n  // Early return if we know we are already subscribed\n  if (doc.shareDoc.subscribed) {\n    return cb();\n  }\n  // Subscribe\n  if (this.root.fetchOnly) {\n    doc.shareDoc.fetch(cb);\n  } else {\n    doc.shareDoc.subscribe(cb);\n  }\n};\n\nModel.prototype.unfetchDoc = function(collectionName, id, cb) {\n  cb = this.wrapCallback(cb);\n  this._context.unfetchDoc(collectionName, id);\n\n  // No effect if the document is not currently fetched\n  if (!this.root._fetchedDocs.get(collectionName, id)) return cb();\n\n  var model = this;\n  if (this.root.unloadDelay) {\n    setTimeout(finishUnfetchDoc, this.root.unloadDelay);\n  } else {\n    finishUnfetchDoc();\n  }\n  function finishUnfetchDoc() {\n    var count = model.root._fetchedDocs.decrement(collectionName, id);\n    if (count) return cb(null, count);\n    model._maybeUnloadDoc(collectionName, id);\n    cb(null, 0);\n  }\n};\n\nModel.prototype.unsubscribeDoc = function(collectionName, id, cb) {\n  cb = this.wrapCallback(cb);\n  this._context.unsubscribeDoc(collectionName, id);\n\n  // No effect if the document is not currently subscribed\n  if (!this.root._subscribedDocs.get(collectionName, id)) return cb();\n\n  var model = this;\n  if (this.root.unloadDelay) {\n    setTimeout(finishUnsubscribeDoc, this.root.unloadDelay);\n  } else {\n    finishUnsubscribeDoc();\n  }\n  function finishUnsubscribeDoc() {\n    var count = model.root._subscribedDocs.decrement(collectionName, id);\n    // If there are more remaining subscriptions, only decrement the count\n    // and callback with how many subscriptions are remaining\n    if (count) return cb(null, count);\n\n    // If there is only one remaining subscription, actually unsubscribe\n    if (model.root.fetchOnly) {\n      unsubscribeDocCallback();\n    } else {\n      var doc = model.getDoc(collectionName, id);\n      var shareDoc = doc && doc.shareDoc;\n      if (!shareDoc) return unsubscribeDocCallback();\n      shareDoc.unsubscribe(unsubscribeDocCallback);\n    }\n  }\n  function unsubscribeDocCallback(err) {\n    model._maybeUnloadDoc(collectionName, id);\n    if (err) return cb(err);\n    cb(null, 0);\n  }\n};\n\n// Removes the document from the local model if the model no longer has any\n// remaining fetches or subscribes via a query or direct loading\nModel.prototype._maybeUnloadDoc = function(collectionName, id) {\n  var model = this;\n  var doc = this.getDoc(collectionName, id);\n  if (!doc) return;\n\n  // If there is a query or direct fetch or subscribe that is holding reference\n  // to this doc, leave it loaded\n  if (this._hasDocReferences(collectionName, id)) return;\n  // Calling sharedDoc.destroy() will remove it from the connection only when\n  // there aren't any operations, fetches, or subscribes pending on the doc.\n  // Thus, if we remove the doc from Racer's model but don't remove it from\n  // ShareDB, we can end up with an inconsistent state, with the data existing\n  // in ShareDB not reflected in the racer model data\n  if (doc.shareDoc && doc.shareDoc.hasPending()) {\n    // If the Share doc still has pending activity, retry _maybeUnloadDoc once\n    // the pending activity is done.\n    doc.shareDoc.whenNothingPending(function() {\n      model._maybeUnloadDoc(collectionName, id);\n    });\n  } else {\n    // Otherwise, actually do the unload.\n    var previous = doc.get();\n\n    // Remove doc from Racer\n    if (model.root.collections[collectionName]) model.root.collections[collectionName].remove(id);\n    // Remove doc from Share\n    if (doc.shareDoc) doc.shareDoc.destroy();\n\n    model.emit('unload', [collectionName, id], [previous, model._pass]);\n  }\n};\n\nModel.prototype._hasDocReferences = function(collectionName, id) {\n  // Check if any fetched or subscribed queries currently have the\n  // id in their results\n  var queries = this.root._queries.collections[collectionName];\n  if (queries) {\n    for (var hash in queries) {\n      var query = queries[hash];\n      if (!query.subscribeCount && !query.fetchCount) continue;\n      if (query.idMap[id] > 0) return true;\n    }\n  }\n\n  // Check if document currently has direct fetch or subscribe\n  if (\n    this.root._fetchedDocs.get(collectionName, id) ||\n    this.root._subscribedDocs.get(collectionName, id)\n  ) return true;\n\n  return false;\n};\n",
    "var Model = require('./Model');\n\nModel.prototype.unbundle = function(data) {\n  if (this.connection) this.connection.startBulk();\n\n  // Re-create and subscribe queries; re-create documents associated with queries\n  this._initQueries(data.queries);\n\n  // Re-create other documents\n  for (var collectionName in data.collections) {\n    var collection = data.collections[collectionName];\n    for (var id in collection) {\n      this.getOrCreateDoc(collectionName, id, collection[id]);\n    }\n  }\n\n  for (var contextId in data.contexts) {\n    var contextData = data.contexts[contextId];\n    var contextModel = this.context(contextId);\n    // Re-init fetchedDocs counts\n    for (var collectionName in contextData.fetchedDocs) {\n      var collection = contextData.fetchedDocs[collectionName];\n      for (var id in collection) {\n        var count = collection[id];\n        while (count--) {\n          contextModel._context.fetchDoc(collectionName, id);\n          this._fetchedDocs.increment(collectionName, id);\n        }\n      }\n    }\n    // Subscribe to document subscriptions\n    for (var collectionName in contextData.subscribedDocs) {\n      var collection = contextData.subscribedDocs[collectionName];\n      for (var id in collection) {\n        var count = collection[id];\n        while (count--) {\n          contextModel.subscribeDoc(collectionName, id);\n        }\n      }\n    }\n    // Re-init createdDocs counts\n    for (var collectionName in contextData.createdDocs) {\n      var collection = contextData.createdDocs[collectionName];\n      for (var id in collection) {\n        // Count value doesn't matter for tracking creates\n        contextModel._context.createDoc(collectionName, id);\n      }\n    }\n  }\n\n  if (this.connection) this.connection.endBulk();\n\n  // Re-create refs\n  for (var i = 0; i < data.refs.length; i++) {\n    var item = data.refs[i];\n    this.ref(item[0], item[1]);\n  }\n  // Re-create refLists\n  for (var i = 0; i < data.refLists.length; i++) {\n    var item = data.refLists[i];\n    this.refList(item[0], item[1], item[2], item[3]);\n  }\n  // Re-create fns\n  for (var i = 0; i < data.fns.length; i++) {\n    var item = data.fns[i];\n    this.start.apply(this, item);\n  }\n  // Re-create filters\n  for (var i = 0; i < data.filters.length; i++) {\n    var item = data.filters[i];\n    var filter = this._filters.add(item[1], item[2], item[3], item[4], item[5]);\n    filter.ref(item[0]);\n  }\n};\n",
    "var EventEmitter = require('events').EventEmitter;\nvar Model = require('./Model');\nvar util = require('./util');\n\nmodule.exports = Racer;\n\nfunction Racer() {\n  EventEmitter.call(this);\n}\n\nutil.mergeInto(Racer.prototype, EventEmitter.prototype);\n\n// Make classes accessible for use by plugins and tests\nRacer.prototype.Model = Model;\nRacer.prototype.util = util;\n\n// Support plugins on racer instances\nRacer.prototype.use = util.use;\nRacer.prototype.serverUse = util.serverUse;\n\nRacer.prototype.createModel = function(data) {\n  var model = new Model();\n  if (data) {\n    model.createConnection(data);\n    model.unbundle(data);\n  }\n  return model;\n};\n\nutil.serverRequire(module, './Racer.server');\n",
    "var deepEqual = require('fast-deep-equal');\n\nvar isServer = process.title !== 'browser';\nexports.isServer = isServer;\n\nexports.asyncGroup = asyncGroup;\nexports.castSegments = castSegments;\nexports.contains = contains;\nexports.copy = copy;\nexports.copyObject = copyObject;\nexports.deepCopy = deepCopy;\nexports.deepEqual = deepEqual;\nexports.equal = equal;\nexports.equalsNaN = equalsNaN;\nexports.isArrayIndex = isArrayIndex;\nexports.lookup = lookup;\nexports.mergeInto = mergeInto;\nexports.mayImpact = mayImpact;\nexports.mayImpactAny = mayImpactAny;\nexports.serverRequire = serverRequire;\nexports.serverUse = serverUse;\nexports.use = use;\n\nfunction asyncGroup(cb) {\n  var group = new AsyncGroup(cb);\n  return function asyncGroupAdd() {\n    return group.add();\n  };\n}\n\n/**\n * @constructor\n * @param {Function} cb(err)\n */\nfunction AsyncGroup(cb) {\n  this.cb = cb;\n  this.isDone = false;\n  this.count = 0;\n}\nAsyncGroup.prototype.add = function() {\n  this.count++;\n  var self = this;\n  return function(err) {\n    self.count--;\n    if (self.isDone) return;\n    if (err) {\n      self.isDone = true;\n      self.cb(err);\n      return;\n    }\n    if (self.count > 0) return;\n    self.isDone = true;\n    self.cb();\n  };\n};\n\n/**\n * @param {Array<string | number>} segments\n * @return {Array<string | number>}\n */\nfunction castSegments(segments) {\n  // Cast number path segments from strings to numbers\n  for (var i = segments.length; i--;) {\n    var segment = segments[i];\n    if (typeof segment === 'string' && isArrayIndex(segment)) {\n      segments[i] = +segment;\n    }\n  }\n  return segments;\n}\n\nfunction contains(segments, testSegments) {\n  for (var i = 0; i < segments.length; i++) {\n    if (segments[i] !== testSegments[i]) return false;\n  }\n  return true;\n}\n\nfunction copy(value) {\n  if (value instanceof Date) return new Date(value);\n  if (typeof value === 'object') {\n    if (value === null) return null;\n    if (Array.isArray(value)) return value.slice();\n    return copyObject(value);\n  }\n  return value;\n}\n\nfunction copyObject(object) {\n  var out = new object.constructor();\n  for (var key in object) {\n    if (object.hasOwnProperty(key)) {\n      out[key] = object[key];\n    }\n  }\n  return out;\n}\n\nfunction deepCopy(value) {\n  if (value instanceof Date) return new Date(value);\n  if (typeof value === 'object') {\n    if (value === null) return null;\n    if (Array.isArray(value)) {\n      var array = [];\n      for (var i = value.length; i--;) {\n        array[i] = deepCopy(value[i]);\n      }\n      return array;\n    }\n    var object = new value.constructor();\n    for (var key in value) {\n      if (value.hasOwnProperty(key)) {\n        object[key] = deepCopy(value[key]);\n      }\n    }\n    return object;\n  }\n  return value;\n}\n\nfunction equal(a, b) {\n  return (a === b) || (equalsNaN(a) && equalsNaN(b));\n}\n\nfunction equalsNaN(x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n}\n\nfunction isArrayIndex(segment) {\n  return (/^[0-9]+$/).test(segment);\n}\n\nfunction lookup(segments, value) {\n  if (!segments) return value;\n\n  for (var i = 0, len = segments.length; i < len; i++) {\n    if (value == null) return value;\n    value = value[segments[i]];\n  }\n  return value;\n}\n\nfunction mayImpactAny(segmentsList, testSegments) {\n  for (var i = 0, len = segmentsList.length; i < len; i++) {\n    if (mayImpact(segmentsList[i], testSegments)) return true;\n  }\n  return false;\n}\n\nfunction mayImpact(segments, testSegments) {\n  var len = Math.min(segments.length, testSegments.length);\n  for (var i = 0; i < len; i++) {\n    if (segments[i] !== testSegments[i]) return false;\n  }\n  return true;\n}\n\nfunction mergeInto(to, from) {\n  for (var key in from) {\n    to[key] = from[key];\n  }\n  return to;\n}\n\nfunction serverRequire(module, id) {\n  if (!isServer) return;\n  return module.require(id);\n}\n\nfunction serverUse(module, id, options) {\n  if (!isServer) return this;\n  var plugin = module.require(id);\n  return this.use(plugin, options);\n}\n\nfunction use(plugin, options) {\n  // Don't include a plugin more than once\n  var plugins = this._plugins || (this._plugins = []);\n  if (plugins.indexOf(plugin) === -1) {\n    plugins.push(plugin);\n    plugin(this, options);\n  }\n  return this;\n}\n",
    "'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n",
    "\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n",
    "//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n",
    "if (typeof require === 'function') {\n  var serializeObject = require('serialize-object');\n}\n\n// UPDATE_PROPERTIES map HTML attribute names to an Element DOM property that\n// should be used for setting on bindings updates instead of setAttribute.\n//\n// https://github.com/jquery/jquery/blob/1.x-master/src/attributes/prop.js\n// https://github.com/jquery/jquery/blob/master/src/attributes/prop.js\n// http://webbugtrack.blogspot.com/2007/08/bug-242-setattribute-doesnt-always-work.html\nvar BOOLEAN_PROPERTIES = {\n  checked: 'checked'\n, disabled: 'disabled'\n, readonly: 'readOnly'\n, selected: 'selected'\n};\nvar INTEGER_PROPERTIES = {\n  colspan: 'colSpan'\n, maxlength: 'maxLength'\n, rowspan: 'rowSpan'\n, tabindex: 'tabIndex'\n};\nvar STRING_PROPERTIES = {\n  cellpadding: 'cellPadding'\n, cellspacing: 'cellSpacing'\n, 'class': 'className'\n, contenteditable: 'contentEditable'\n, enctype: 'encoding'\n, 'for': 'htmlFor'\n, frameborder: 'frameBorder'\n, id: 'id'\n, title: 'title'\n, type: 'type'\n, usemap: 'useMap'\n, value: 'value'\n};\nvar UPDATE_PROPERTIES = {};\nmergeInto(BOOLEAN_PROPERTIES, UPDATE_PROPERTIES);\nmergeInto(INTEGER_PROPERTIES, UPDATE_PROPERTIES);\nmergeInto(STRING_PROPERTIES, UPDATE_PROPERTIES);\n\n// CREATE_PROPERTIES map HTML attribute names to an Element DOM property that\n// should be used for setting on Element rendering instead of setAttribute.\n// input.defaultChecked and input.defaultValue affect the attribute, so we want\n// to use these for initial dynamic rendering. For binding updates,\n// input.checked and input.value are modified.\nvar CREATE_PROPERTIES = {};\nmergeInto(UPDATE_PROPERTIES, CREATE_PROPERTIES);\nCREATE_PROPERTIES.checked = 'defaultChecked';\nCREATE_PROPERTIES.value = 'defaultValue';\n\n// http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\nvar VOID_ELEMENTS = {\n  area: true\n, base: true\n, br: true\n, col: true\n, embed: true\n, hr: true\n, img: true\n, input: true\n, keygen: true\n, link: true\n, menuitem: true\n, meta: true\n, param: true\n, source: true\n, track: true\n, wbr: true\n};\n\nvar NAMESPACE_URIS = {\n  svg: 'http://www.w3.org/2000/svg'\n, xlink: 'http://www.w3.org/1999/xlink'\n, xmlns: 'http://www.w3.org/2000/xmlns/'\n};\n\nexports.CREATE_PROPERTIES = CREATE_PROPERTIES;\nexports.BOOLEAN_PROPERTIES = BOOLEAN_PROPERTIES;\nexports.INTEGER_PROPERTIES = INTEGER_PROPERTIES;\nexports.STRING_PROPERTIES = STRING_PROPERTIES;\nexports.UPDATE_PROPERTIES = UPDATE_PROPERTIES;\nexports.VOID_ELEMENTS = VOID_ELEMENTS;\nexports.NAMESPACE_URIS = NAMESPACE_URIS;\n\n// Template Classes\nexports.Template = Template;\nexports.Doctype = Doctype;\nexports.Text = Text;\nexports.DynamicText = DynamicText;\nexports.Comment = Comment;\nexports.DynamicComment = DynamicComment;\nexports.Html = Html;\nexports.DynamicHtml = DynamicHtml;\nexports.Element = Element;\nexports.DynamicElement = DynamicElement;\nexports.Block = Block;\nexports.ConditionalBlock = ConditionalBlock;\nexports.EachBlock = EachBlock;\n\nexports.Attribute = Attribute;\nexports.DynamicAttribute = DynamicAttribute;\n\n// Binding Classes\nexports.Binding = Binding;\nexports.NodeBinding = NodeBinding;\nexports.AttributeBinding = AttributeBinding;\nexports.RangeBinding = RangeBinding;\n\nfunction Template(content, source) {\n  this.content = content;\n  this.source = source;\n}\nTemplate.prototype.toString = function() {\n  return this.source;\n};\nTemplate.prototype.get = function(context, unescaped) {\n  return contentHtml(this.content, context, unescaped);\n};\nTemplate.prototype.getFragment = function(context, binding) {\n  var fragment = document.createDocumentFragment();\n  this.appendTo(fragment, context, binding);\n  return fragment;\n};\nTemplate.prototype.appendTo = function(parent, context) {\n  context.pause();\n  appendContent(parent, this.content, context);\n  context.unpause();\n};\nTemplate.prototype.attachTo = function(parent, node, context) {\n  context.pause();\n  var node = attachContent(parent, node, this.content, context);\n  context.unpause();\n  return node;\n};\nTemplate.prototype.update = function() {};\nTemplate.prototype.stringify = function(value) {\n  return (value == null) ? '' : value + '';\n};\nTemplate.prototype.equals = function(other) {\n  return this === other;\n};\nTemplate.prototype.module = 'templates';\nTemplate.prototype.type = 'Template';\nTemplate.prototype.serialize = function() {\n  return serializeObject.instance(this, this.content, this.source);\n};\n\n\nfunction Doctype(name, publicId, systemId) {\n  this.name = name;\n  this.publicId = publicId;\n  this.systemId = systemId;\n}\nDoctype.prototype = Object.create(Template.prototype);\nDoctype.prototype.constructor = Doctype;\nDoctype.prototype.get = function() {\n  var publicText = (this.publicId) ?\n    ' PUBLIC \"' + this.publicId  + '\"' :\n    '';\n  var systemText = (this.systemId) ?\n    (this.publicId) ?\n      ' \"' + this.systemId + '\"' :\n      ' SYSTEM \"' + this.systemId + '\"' :\n    '';\n  return '<!DOCTYPE ' + this.name + publicText + systemText + '>';\n};\nDoctype.prototype.appendTo = function() {\n  // Doctype could be created via:\n  //   document.implementation.createDocumentType(this.name, this.publicId, this.systemId)\n  // However, it does not appear possible or useful to append it to the\n  // document fragment. Therefore, just don't render it in the browser\n};\nDoctype.prototype.attachTo = function(parent, node) {\n  if (!node || node.nodeType !== 10) {\n    throw attachError(parent, node);\n  }\n  return node.nextSibling;\n};\nDoctype.prototype.type = 'Doctype';\nDoctype.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.publicId, this.systemId);\n};\n\nfunction Text(data) {\n  this.data = data;\n  this.escaped = escapeHtml(data);\n}\nText.prototype = Object.create(Template.prototype);\nText.prototype.constructor = Text;\nText.prototype.get = function(context, unescaped) {\n  return (unescaped) ? this.data : this.escaped;\n};\nText.prototype.appendTo = function(parent) {\n  var node = document.createTextNode(this.data);\n  parent.appendChild(node);\n};\nText.prototype.attachTo = function(parent, node) {\n  return attachText(parent, node, this.data, this);\n};\nText.prototype.type = 'Text';\nText.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data);\n};\n\n// DynamicText might be more accurately named DynamicContent. When its\n// expression returns a template, it acts similar to a Block, and it renders\n// the template surrounded by comment markers for range replacement. When its\n// expression returns any other type, it renders a DOM Text node with no\n// markers. Text nodes are bound by updating their data property dynamically.\n// The update method must take care to switch between these types of bindings\n// in case the expression return type changes dynamically.\nfunction DynamicText(expression) {\n  this.expression = expression;\n  this.unbound = false;\n}\nDynamicText.prototype = Object.create(Template.prototype);\nDynamicText.prototype.constructor = DynamicText;\nDynamicText.prototype.get = function(context, unescaped) {\n  var value = this.expression.get(context);\n  if (value instanceof Template) {\n    do {\n      value = value.get(context, unescaped);\n    } while (value instanceof Template);\n    return value;\n  }\n  var data = this.stringify(value);\n  return (unescaped) ? data : escapeHtml(data);\n};\nDynamicText.prototype.appendTo = function(parent, context, binding) {\n  var value = this.expression.get(context);\n  if (value instanceof Template) {\n    var start = document.createComment(this.expression);\n    var end = document.createComment('/' + this.expression);\n    var condition = this.getCondition(context);\n    parent.appendChild(start);\n    value.appendTo(parent, context);\n    parent.appendChild(end);\n    updateRange(context, binding, this, start, end, null, condition);\n    return;\n  }\n  var data = this.stringify(value);\n  var node = document.createTextNode(data);\n  parent.appendChild(node);\n  addNodeBinding(this, context, node);\n};\nDynamicText.prototype.attachTo = function(parent, node, context) {\n  var value = this.expression.get(context);\n  if (value instanceof Template) {\n    var start = document.createComment(this.expression);\n    var end = document.createComment('/' + this.expression);\n    var condition = this.getCondition(context);\n    parent.insertBefore(start, node || null);\n    node = value.attachTo(parent, node, context);\n    parent.insertBefore(end, node || null);\n    updateRange(context, null, this, start, end, null, condition);\n    return node;\n  }\n  var data = this.stringify(value);\n  return attachText(parent, node, data, this, context);\n};\nDynamicText.prototype.update = function(context, binding) {\n  if (binding instanceof RangeBinding) {\n    this._blockUpdate(context, binding);\n    return;\n  }\n  var value = this.expression.get(context);\n  if (value instanceof Template) {\n    var start = binding.node;\n    if (!start.parentNode) return;\n    var end = start;\n    var fragment = this.getFragment(context);\n    replaceRange(context, start, end, fragment, binding);\n    return;\n  }\n  binding.node.data = this.stringify(value);\n};\nDynamicText.prototype.getCondition = function(context) {\n  return this.expression.get(context);\n};\nDynamicText.prototype.type = 'DynamicText';\nDynamicText.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression);\n};\n\nfunction attachText(parent, node, data, template, context) {\n  if (!node) {\n    var newNode = document.createTextNode(data);\n    parent.appendChild(newNode);\n    addNodeBinding(template, context, newNode);\n    return;\n  }\n  if (node.nodeType === 3) {\n    // Proceed if nodes already match\n    if (node.data === data) {\n      addNodeBinding(template, context, node);\n      return node.nextSibling;\n    }\n    data = normalizeLineBreaks(data);\n    // Split adjacent text nodes that would have been merged together in HTML\n    var nextNode = splitData(node, data.length);\n    if (node.data !== data) {\n      throw attachError(parent, node);\n    }\n    addNodeBinding(template, context, node);\n    return nextNode;\n  }\n  // An empty text node might not be created at the end of some text\n  if (data === '') {\n    var newNode = document.createTextNode('');\n    parent.insertBefore(newNode, node || null);\n    addNodeBinding(template, context, newNode);\n    return node;\n  }\n  throw attachError(parent, node);\n}\n\nfunction Comment(data, hooks) {\n  this.data = data;\n  this.hooks = hooks;\n}\nComment.prototype = Object.create(Template.prototype);\nComment.prototype.constructor = Comment;\nComment.prototype.get = function() {\n  return '<!--' + this.data + '-->';\n};\nComment.prototype.appendTo = function(parent, context) {\n  var node = document.createComment(this.data);\n  parent.appendChild(node);\n  emitHooks(this.hooks, context, node);\n};\nComment.prototype.attachTo = function(parent, node, context) {\n  return attachComment(parent, node, this.data, this, context);\n};\nComment.prototype.type = 'Comment';\nComment.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data, this.hooks);\n}\n\nfunction DynamicComment(expression, hooks) {\n  this.expression = expression;\n  this.hooks = hooks;\n}\nDynamicComment.prototype = Object.create(Template.prototype);\nDynamicComment.prototype.constructor = DynamicComment;\nDynamicComment.prototype.get = function(context) {\n  var value = getUnescapedValue(this.expression, context);\n  var data = this.stringify(value);\n  return '<!--' + data + '-->';\n};\nDynamicComment.prototype.appendTo = function(parent, context) {\n  var value = getUnescapedValue(this.expression, context);\n  var data = this.stringify(value);\n  var node = document.createComment(data);\n  parent.appendChild(node);\n  addNodeBinding(this, context, node);\n};\nDynamicComment.prototype.attachTo = function(parent, node, context) {\n  var value = getUnescapedValue(this.expression, context);\n  var data = this.stringify(value);\n  return attachComment(parent, node, data, this, context);\n};\nDynamicComment.prototype.update = function(context, binding) {\n  var value = getUnescapedValue(this.expression, context);\n  binding.node.data = this.stringify(value);\n};\nDynamicComment.prototype.type = 'DynamicComment';\nDynamicComment.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.hooks);\n}\n\nfunction attachComment(parent, node, data, template, context) {\n  // Sometimes IE fails to create Comment nodes from HTML or innerHTML.\n  // This is an issue inside of <select> elements, for example.\n  if (!node || node.nodeType !== 8) {\n    var newNode = document.createComment(data);\n    parent.insertBefore(newNode, node || null);\n    addNodeBinding(template, context, newNode);\n    return node;\n  }\n  // Proceed if nodes already match\n  if (node.data === data) {\n    addNodeBinding(template, context, node);\n    return node.nextSibling;\n  }\n  throw attachError(parent, node);\n}\n\nfunction addNodeBinding(template, context, node) {\n  if (template.expression && !template.unbound) {\n    context.addBinding(new NodeBinding(template, context, node));\n  }\n  emitHooks(template.hooks, context, node);\n}\n\nfunction Html(data) {\n  this.data = data;\n}\nHtml.prototype = Object.create(Template.prototype);\nHtml.prototype.constructor = Html;\nHtml.prototype.get = function() {\n  return this.data;\n};\nHtml.prototype.appendTo = function(parent) {\n  var fragment = createHtmlFragment(parent, this.data);\n  parent.appendChild(fragment);\n};\nHtml.prototype.attachTo = function(parent, node) {\n  return attachHtml(parent, node, this.data);\n};\nHtml.prototype.type = \"Html\";\nHtml.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data);\n};\n\nfunction DynamicHtml(expression) {\n  this.expression = expression;\n  this.ending = '/' + expression;\n}\nDynamicHtml.prototype = Object.create(Template.prototype);\nDynamicHtml.prototype.constructor = DynamicHtml;\nDynamicHtml.prototype.get = function(context) {\n  var value = getUnescapedValue(this.expression, context);\n  return this.stringify(value);\n};\nDynamicHtml.prototype.appendTo = function(parent, context, binding) {\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  var value = getUnescapedValue(this.expression, context);\n  var html = this.stringify(value);\n  var fragment = createHtmlFragment(parent, html);\n  parent.appendChild(start);\n  parent.appendChild(fragment);\n  parent.appendChild(end);\n  updateRange(context, binding, this, start, end);\n};\nDynamicHtml.prototype.attachTo = function(parent, node, context) {\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  var value = getUnescapedValue(this.expression, context);\n  var html = this.stringify(value);\n  parent.insertBefore(start, node || null);\n  node = attachHtml(parent, node, html);\n  parent.insertBefore(end, node || null);\n  updateRange(context, null, this, start, end);\n  return node;\n};\nDynamicHtml.prototype.update = function(context, binding) {\n  var parent = binding.start.parentNode;\n  if (!parent) return;\n  // Get start and end in advance, since binding is mutated in getFragment\n  var start = binding.start;\n  var end = binding.end;\n  var value = getUnescapedValue(this.expression, context);\n  var html = this.stringify(value);\n  var fragment = createHtmlFragment(parent, html);\n  var innerOnly = true;\n  replaceRange(context, start, end, fragment, binding, innerOnly);\n};\nDynamicHtml.prototype.type = 'DynamicHtml';\nDynamicHtml.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression);\n};\n\nfunction createHtmlFragment(parent, html) {\n  if (parent && parent.nodeType === 1) {\n    var range = document.createRange();\n    range.selectNodeContents(parent);\n    return range.createContextualFragment(html);\n  }\n  var div = document.createElement('div');\n  var range = document.createRange();\n  div.innerHTML = html;\n  range.selectNodeContents(div);\n  return range.extractContents();\n}\nfunction attachHtml(parent, node, html) {\n  var fragment = createHtmlFragment(parent, html);\n  for (var i = 0, len = fragment.childNodes.length; i < len; i++) {\n    if (!node) throw attachError(parent, node);\n    node = node.nextSibling;\n  }\n  return node;\n}\n\nfunction Attribute(data, ns) {\n  this.data = data;\n  this.ns = ns;\n}\nAttribute.prototype = Object.create(Template.prototype);\nAttribute.prototype.constructor = Attribute;\nAttribute.prototype.get = Attribute.prototype.getBound = function(context) {\n  return this.data;\n};\nAttribute.prototype.type = 'Attribute';\nAttribute.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data, this.ns);\n};\n\nfunction DynamicAttribute(expression, ns) {\n  // In attributes, expression may be an instance of Template or Expression\n  this.expression = expression;\n  this.ns = ns;\n  this.elementNs = null;\n}\nDynamicAttribute.prototype = Object.create(Attribute.prototype);\nDynamicAttribute.prototype.constructor = DynamicAttribute;\nDynamicAttribute.prototype.get = function(context) {\n  return getUnescapedValue(this.expression, context);\n};\nDynamicAttribute.prototype.getBound = function(context, element, name, elementNs) {\n  this.elementNs = elementNs;\n  context.addBinding(new AttributeBinding(this, context, element, name));\n  return getUnescapedValue(this.expression, context);\n};\nDynamicAttribute.prototype.update = function(context, binding) {\n  var value = getUnescapedValue(this.expression, context);\n  var element = binding.element;\n  var propertyName = !this.elementNs && UPDATE_PROPERTIES[binding.name];\n  if (propertyName) {\n    // Update via DOM property, short-circuiting if no update is needed.\n    // Certain properties must be strings, so for those properties, the value gets stringified.\n    //\n    // There is one special case, when updating the string `input.value` property with a number.\n    // If a user tries to type \"1.01\" in an `<input type=\"number\">, then once they've typed \"1.0\",\n    // the context value is set to `1`, triggering this update function to set the input value to\n    // \"1\". That means typing \"1.01\" would be impossible without special handling to avoid\n    // overwriting an existing input value of \"1.0\" with a new value of \"1\".\n    if (element.tagName === 'INPUT' && propertyName === 'value' && typeof value === 'number') {\n      if (parseFloat(element.value) === value) {\n        return;\n      }\n    }\n    var propertyValue = (STRING_PROPERTIES[binding.name]) ?\n      this.stringify(value) : value;\n    if (element[propertyName] === propertyValue) return;\n    element[propertyName] = propertyValue;\n    return;\n  }\n  if (value === false || value == null) {\n    if (this.ns) {\n      element.removeAttributeNS(this.ns, binding.name);\n    } else {\n      element.removeAttribute(binding.name);\n    }\n    return;\n  }\n  if (value === true) value = binding.name;\n  if (this.ns) {\n    element.setAttributeNS(this.ns, binding.name, value);\n  } else {\n    element.setAttribute(binding.name, value);\n  }\n};\nDynamicAttribute.prototype.type = 'DynamicAttribute';\nDynamicAttribute.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.ns);\n};\n\nfunction getUnescapedValue(expression, context) {\n  var unescaped = true;\n  var value = expression.get(context, unescaped);\n  while (value instanceof Template) {\n    value = value.get(context, unescaped);\n  }\n  return value;\n}\n\nfunction Element(tagName, attributes, content, hooks, selfClosing, notClosed, ns) {\n  this.tagName = tagName;\n  this.attributes = attributes;\n  this.content = content;\n  this.hooks = hooks;\n  this.selfClosing = selfClosing;\n  this.notClosed = notClosed;\n  this.ns = ns;\n\n  this.endTag = getEndTag(tagName, selfClosing, notClosed);\n  this.startClose = getStartClose(selfClosing);\n  var lowerTagName = tagName && tagName.toLowerCase();\n  this.unescapedContent = (lowerTagName === 'script' || lowerTagName === 'style');\n  this.bindContentToValue = (lowerTagName === 'textarea');\n}\nElement.prototype = Object.create(Template.prototype);\nElement.prototype.constructor = Element;\nElement.prototype.getTagName = function() {\n  return this.tagName;\n};\nElement.prototype.getEndTag = function() {\n  return this.endTag;\n};\nElement.prototype.get = function(context) {\n  var tagName = this.getTagName(context);\n  var endTag = this.getEndTag(tagName);\n  var tagItems = [tagName];\n  for (var key in this.attributes) {\n    var value = this.attributes[key].get(context);\n    if (value === true) {\n      tagItems.push(key);\n    } else if (value !== false && value != null) {\n      tagItems.push(key + '=\"' + escapeAttribute(value) + '\"');\n    }\n  }\n  var startTag = '<' + tagItems.join(' ') + this.startClose;\n  if (this.content) {\n    var inner = contentHtml(this.content, context, this.unescapedContent);\n    return startTag + inner + endTag;\n  }\n  return startTag + endTag;\n};\nElement.prototype.appendTo = function(parent, context) {\n  var tagName = this.getTagName(context);\n  var element = (this.ns) ?\n    document.createElementNS(this.ns, tagName) :\n    document.createElement(tagName);\n  for (var key in this.attributes) {\n    var attribute = this.attributes[key];\n    var value = attribute.getBound(context, element, key, this.ns);\n    if (value === false || value == null) continue;\n    var propertyName = !this.ns && CREATE_PROPERTIES[key];\n    if (propertyName) {\n      element[propertyName] = value;\n      continue;\n    }\n    if (value === true) value = key;\n    if (attribute.ns) {\n      element.setAttributeNS(attribute.ns, key, value);\n    } else {\n      element.setAttribute(key, value);\n    }\n  }\n  if (this.content) {\n    this._bindContent(context, element);\n    appendContent(element, this.content, context);\n  }\n  parent.appendChild(element);\n  emitHooks(this.hooks, context, element);\n};\nElement.prototype.attachTo = function(parent, node, context) {\n  var tagName = this.getTagName(context);\n  if (\n    !node ||\n    node.nodeType !== 1 ||\n    node.tagName.toLowerCase() !== tagName.toLowerCase()\n  ) {\n    throw attachError(parent, node);\n  }\n  for (var key in this.attributes) {\n    // Get each attribute to create bindings\n    this.attributes[key].getBound(context, node, key, this.ns);\n    // TODO: Ideally, this would also check that the node's current attributes\n    // are equivalent, but there are some tricky edge cases\n  }\n  if (this.content) {\n    this._bindContent(context, node);\n    attachContent(node, node.firstChild, this.content, context);\n  }\n  emitHooks(this.hooks, context, node);\n  return node.nextSibling;\n};\nElement.prototype._bindContent = function(context, element) {\n  // For textareas with dynamic text content, bind to the value property\n  var child = this.bindContentToValue &&\n    this.content.length === 1 &&\n    this.content[0];\n  if (child instanceof DynamicText) {\n    child.unbound = true;\n    var template = new DynamicAttribute(child.expression);\n    context.addBinding(new AttributeBinding(template, context, element, 'value'));\n  }\n};\nElement.prototype.type = 'Element';\nElement.prototype.serialize = function() {\n  return serializeObject.instance(\n    this\n  , this.tagName\n  , this.attributes\n  , this.content\n  , this.hooks\n  , this.selfClosing\n  , this.notClosed\n  , this.ns\n  );\n};\n\nfunction DynamicElement(tagName, attributes, content, hooks, selfClosing, notClosed, ns) {\n  this.tagName = tagName;\n  this.attributes = attributes;\n  this.content = content;\n  this.hooks = hooks;\n  this.selfClosing = selfClosing;\n  this.notClosed = notClosed;\n  this.ns = ns;\n\n  this.startClose = getStartClose(selfClosing);\n  this.unescapedContent = false;\n}\nDynamicElement.prototype = Object.create(Element.prototype);\nDynamicElement.prototype.constructor = DynamicElement;\nDynamicElement.prototype.getTagName = function(context) {\n  return getUnescapedValue(this.tagName, context);\n};\nDynamicElement.prototype.getEndTag = function(tagName) {\n  return getEndTag(tagName, this.selfClosing, this.notClosed);\n};\nDynamicElement.prototype.type = 'DynamicElement';\n\nfunction getStartClose(selfClosing) {\n  return (selfClosing) ? ' />' : '>';\n}\n\nfunction getEndTag(tagName, selfClosing, notClosed) {\n  var lowerTagName = tagName && tagName.toLowerCase();\n  var isVoid = VOID_ELEMENTS[lowerTagName];\n  return (isVoid || selfClosing || notClosed) ? '' : '</' + tagName + '>';\n}\n\nfunction getAttributeValue(element, name) {\n  var propertyName = UPDATE_PROPERTIES[name];\n  return (propertyName) ? element[propertyName] : element.getAttribute(name);\n}\n\nfunction emitHooks(hooks, context, value) {\n  if (!hooks) return;\n  context.queue(function queuedHooks() {\n    for (var i = 0, len = hooks.length; i < len; i++) {\n      hooks[i].emit(context, value);\n    }\n  });\n}\n\nfunction Block(expression, content) {\n  this.expression = expression;\n  this.ending = '/' + expression;\n  this.content = content;\n}\nBlock.prototype = Object.create(Template.prototype);\nBlock.prototype.constructor = Block;\nBlock.prototype.get = function(context, unescaped) {\n  var blockContext = context.child(this.expression);\n  return contentHtml(this.content, blockContext, unescaped);\n};\nBlock.prototype.appendTo = function(parent, context, binding) {\n  var blockContext = context.child(this.expression);\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  var condition = this.getCondition(context);\n  parent.appendChild(start);\n  appendContent(parent, this.content, blockContext);\n  parent.appendChild(end);\n  updateRange(context, binding, this, start, end, null, condition);\n};\nBlock.prototype.attachTo = function(parent, node, context) {\n  var blockContext = context.child(this.expression);\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  var condition = this.getCondition(context);\n  parent.insertBefore(start, node || null);\n  node = attachContent(parent, node, this.content, blockContext);\n  parent.insertBefore(end, node || null);\n  updateRange(context, null, this, start, end, null, condition);\n  return node;\n};\nBlock.prototype.type = 'Block';\nBlock.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.content);\n};\nBlock.prototype.update = function(context, binding) {\n  if (!binding.start.parentNode) return;\n  var condition = this.getCondition(context);\n  // Cancel update if prior condition is equivalent to current value\n  if (equalConditions(condition, binding.condition)) return;\n  binding.condition = condition;\n  // Get start and end in advance, since binding is mutated in getFragment\n  var start = binding.start;\n  var end = binding.end;\n  var fragment = this.getFragment(context, binding);\n  replaceRange(context, start, end, fragment, binding);\n};\nBlock.prototype.getCondition = function(context) {\n  // We do an identity check to see if the value has changed before updating.\n  // With objects, the object would still be the same, so this identity check\n  // would fail to update enough. Thus, return NaN, which never equals anything\n  // including itself, so that we always update on objects.\n  //\n  // We could also JSON stringify or use some other hashing approach. However,\n  // that could be really expensive on gets of things that never change, and\n  // is probably not a good tradeoff. Perhaps there should be a separate block\n  // type that is only used in the case of dynamic updates\n  var value = this.expression.get(context);\n  return (typeof value === 'object') ? NaN : value;\n};\nDynamicText.prototype._blockUpdate = Block.prototype.update;\n\nfunction ConditionalBlock(expressions, contents) {\n  this.expressions = expressions;\n  this.beginning = expressions.join('; ');\n  this.ending = '/' + this.beginning;\n  this.contents = contents;\n}\nConditionalBlock.prototype = Object.create(Block.prototype);\nConditionalBlock.prototype.constructor = ConditionalBlock;\nConditionalBlock.prototype.get = function(context, unescaped) {\n  var condition = this.getCondition(context);\n  if (condition == null) return '';\n  var expression = this.expressions[condition];\n  var blockContext = context.child(expression);\n  return contentHtml(this.contents[condition], blockContext, unescaped);\n};\nConditionalBlock.prototype.appendTo = function(parent, context, binding) {\n  var start = document.createComment(this.beginning);\n  var end = document.createComment(this.ending);\n  parent.appendChild(start);\n  var condition = this.getCondition(context);\n  if (condition != null) {\n    var expression = this.expressions[condition];\n    var blockContext = context.child(expression);\n    appendContent(parent, this.contents[condition], blockContext);\n  }\n  parent.appendChild(end);\n  updateRange(context, binding, this, start, end, null, condition);\n};\nConditionalBlock.prototype.attachTo = function(parent, node, context) {\n  var start = document.createComment(this.beginning);\n  var end = document.createComment(this.ending);\n  parent.insertBefore(start, node || null);\n  var condition = this.getCondition(context);\n  if (condition != null) {\n    var expression = this.expressions[condition];\n    var blockContext = context.child(expression);\n    node = attachContent(parent, node, this.contents[condition], blockContext);\n  }\n  parent.insertBefore(end, node || null);\n  updateRange(context, null, this, start, end, null, condition);\n  return node;\n};\nConditionalBlock.prototype.type = 'ConditionalBlock';\nConditionalBlock.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expressions, this.contents);\n};\nConditionalBlock.prototype.update = function(context, binding) {\n  if (!binding.start.parentNode) return;\n  var condition = this.getCondition(context);\n  // Cancel update if prior condition is equivalent to current value\n  if (equalConditions(condition, binding.condition)) return;\n  binding.condition = condition;\n  // Get start and end in advance, since binding is mutated in getFragment\n  var start = binding.start;\n  var end = binding.end;\n  var fragment = this.getFragment(context, binding);\n  replaceRange(context, start, end, fragment, binding);\n};\nConditionalBlock.prototype.getCondition = function(context) {\n  for (var i = 0, len = this.expressions.length; i < len; i++) {\n    if (this.expressions[i].truthy(context)) {\n      return i;\n    }\n  }\n};\n\nfunction EachBlock(expression, content, elseContent) {\n  this.expression = expression;\n  this.ending = '/' + expression;\n  this.content = content;\n  this.elseContent = elseContent;\n}\nEachBlock.prototype = Object.create(Block.prototype);\nEachBlock.prototype.constructor = EachBlock;\nEachBlock.prototype.get = function(context, unescaped) {\n  var items = this.expression.get(context);\n  if (items && items.length) {\n    var html = '';\n    for (var i = 0, len = items.length; i < len; i++) {\n      var itemContext = context.eachChild(this.expression, i);\n      html += contentHtml(this.content, itemContext, unescaped);\n    }\n    return html;\n  } else if (this.elseContent) {\n    return contentHtml(this.elseContent, context, unescaped);\n  }\n  return '';\n};\nEachBlock.prototype.appendTo = function(parent, context, binding) {\n  var items = this.expression.get(context);\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  parent.appendChild(start);\n  if (items && items.length) {\n    for (var i = 0, len = items.length; i < len; i++) {\n      var itemContext = context.eachChild(this.expression, i);\n      this.appendItemTo(parent, itemContext, start);\n    }\n  } else if (this.elseContent) {\n    appendContent(parent, this.elseContent, context);\n  }\n  parent.appendChild(end);\n  updateRange(context, binding, this, start, end);\n};\nEachBlock.prototype.appendItemTo = function(parent, context, itemFor, binding) {\n  var before = parent.lastChild;\n  var start, end;\n  appendContent(parent, this.content, context);\n  if (before === parent.lastChild) {\n    start = end = document.createComment('empty');\n    parent.appendChild(start);\n  } else {\n    start = (before && before.nextSibling) || parent.firstChild;\n    end = parent.lastChild;\n  }\n  updateRange(context, binding, this, start, end, itemFor);\n};\nEachBlock.prototype.attachTo = function(parent, node, context) {\n  var items = this.expression.get(context);\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  parent.insertBefore(start, node || null);\n  if (items && items.length) {\n    for (var i = 0, len = items.length; i < len; i++) {\n      var itemContext = context.eachChild(this.expression, i);\n      node = this.attachItemTo(parent, node, itemContext, start);\n    }\n  } else if (this.elseContent) {\n    node = attachContent(parent, node, this.elseContent, context);\n  }\n  parent.insertBefore(end, node || null);\n  updateRange(context, null, this, start, end);\n  return node;\n};\nEachBlock.prototype.attachItemTo = function(parent, node, context, itemFor) {\n  var start, end;\n  var oldPrevious = node && node.previousSibling;\n  var nextNode = attachContent(parent, node, this.content, context);\n  if (nextNode === node) {\n    start = end = document.createComment('empty');\n    parent.insertBefore(start, node || null);\n  } else {\n    start = (oldPrevious && oldPrevious.nextSibling) || parent.firstChild;\n    end = (nextNode && nextNode.previousSibling) || parent.lastChild;\n  }\n  updateRange(context, null, this, start, end, itemFor);\n  return nextNode;\n};\nEachBlock.prototype.update = function(context, binding) {\n  if (!binding.start.parentNode) return;\n  var start = binding.start;\n  var end = binding.end;\n  if (binding.itemFor) {\n    var fragment = document.createDocumentFragment();\n    this.appendItemTo(fragment, context, binding.itemFor, binding);\n  } else {\n    var fragment = this.getFragment(context, binding);\n  }\n  replaceRange(context, start, end, fragment, binding);\n};\nEachBlock.prototype.insert = function(context, binding, index, howMany) {\n  var parent = binding.start.parentNode;\n  if (!parent) return;\n  // In case we are inserting all of the items, update instead. This is needed\n  // when we were previously rendering elseContent so that it is replaced\n  if (index === 0 && this.expression.get(context).length === howMany) {\n    return this.update(context, binding);\n  }\n  var node = indexStartNode(binding, index);\n  var fragment = document.createDocumentFragment();\n  for (var i = index, len = index + howMany; i < len; i++) {\n    var itemContext = context.eachChild(this.expression, i);\n    this.appendItemTo(fragment, itemContext, binding.start);\n  }\n  parent.insertBefore(fragment, node || null);\n};\nEachBlock.prototype.remove = function(context, binding, index, howMany) {\n  var parent = binding.start.parentNode;\n  if (!parent) return;\n  // In case we are removing all of the items, update instead. This is needed\n  // when elseContent should be rendered\n  if (index === 0 && this.expression.get(context).length === 0) {\n    return this.update(context, binding);\n  }\n  var node = indexStartNode(binding, index);\n  var i = 0;\n  while (node) {\n    if (node === binding.end) return;\n    if (node.$bindItemStart && node.$bindItemStart.itemFor === binding.start) {\n      if (howMany === i++) return;\n    }\n    var nextNode = node.nextSibling;\n    parent.removeChild(node);\n    emitRemoved(context, node, binding);\n    node = nextNode;\n  }\n};\nEachBlock.prototype.move = function(context, binding, from, to, howMany) {\n  var parent = binding.start.parentNode;\n  if (!parent) return;\n  var node = indexStartNode(binding, from);\n  var fragment = document.createDocumentFragment();\n  var i = 0;\n  while (node) {\n    if (node === binding.end) break;\n    if (node.$bindItemStart && node.$bindItemStart.itemFor === binding.start) {\n      if (howMany === i++) break;\n    }\n    var nextNode = node.nextSibling;\n    fragment.appendChild(node);\n    node = nextNode;\n  }\n  node = indexStartNode(binding, to);\n  parent.insertBefore(fragment, node || null);\n};\nEachBlock.prototype.type = 'EachBlock';\nEachBlock.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.content, this.elseContent);\n};\n\nfunction indexStartNode(binding, index) {\n  var node = binding.start;\n  var i = 0;\n  while (node = node.nextSibling) {\n    if (node === binding.end) return node;\n    if (node.$bindItemStart && node.$bindItemStart.itemFor === binding.start) {\n      if (index === i) return node;\n      i++;\n    }\n  }\n}\n\nfunction updateRange(context, binding, template, start, end, itemFor, condition) {\n  if (binding) {\n    binding.start = start;\n    binding.end = end;\n    binding.condition = condition;\n    setNodeBounds(binding, start, itemFor);\n  } else {\n    context.addBinding(new RangeBinding(template, context, start, end, itemFor, condition));\n  }\n}\nfunction setNodeBounds(binding, start, itemFor) {\n  if (itemFor) {\n    setNodeProperty(start, '$bindItemStart', binding);\n  } else {\n    setNodeProperty(start, '$bindStart', binding);\n  }\n}\n\nfunction appendContent(parent, content, context) {\n  for (var i = 0, len = content.length; i < len; i++) {\n    content[i].appendTo(parent, context);\n  }\n}\nfunction attachContent(parent, node, content, context) {\n  for (var i = 0, len = content.length; i < len; i++) {\n    while (node && node.hasAttribute && node.hasAttribute('data-no-attach')) {\n      node = node.nextSibling;\n    }\n    node = content[i].attachTo(parent, node, context);\n  }\n  return node;\n}\nfunction contentHtml(content, context, unescaped) {\n  var html = '';\n  for (var i = 0, len = content.length; i < len; i++) {\n    html += content[i].get(context, unescaped);\n  }\n  return html;\n}\nfunction replaceRange(context, start, end, fragment, binding, innerOnly) {\n  // Note: the calling function must make sure to check that there is a parent\n  var parent = start.parentNode;\n  // Copy item binding from old start to fragment being inserted\n  if (start.$bindItemStart && fragment.firstChild) {\n    setNodeProperty(fragment.firstChild, '$bindItemStart', start.$bindItemStart);\n    start.$bindItemStart.start = fragment.firstChild;\n  }\n  // Fast path for single node replacements\n  if (start === end) {\n    parent.replaceChild(fragment, start);\n    emitRemoved(context, start, binding);\n    return;\n  }\n  // Remove all nodes from start to end\n  var node = (innerOnly) ? start.nextSibling : start;\n  var nextNode;\n  while (node) {\n    nextNode = node.nextSibling;\n    emitRemoved(context, node, binding);\n    if (innerOnly && node === end) {\n      nextNode = end;\n      break;\n    }\n    parent.removeChild(node);\n    if (node === end) break;\n    node = nextNode;\n  }\n  // This also works if nextNode is null, by doing an append\n  parent.insertBefore(fragment, nextNode || null);\n}\nfunction emitRemoved(context, node, ignore) {\n  context.removeNode(node);\n  emitRemovedBinding(context, ignore, node, '$bindNode');\n  emitRemovedBinding(context, ignore, node, '$bindStart');\n  emitRemovedBinding(context, ignore, node, '$bindItemStart');\n  var attributes = node.$bindAttributes;\n  if (attributes) {\n    node.$bindAttributes = null;\n    for (var key in attributes) {\n      context.removeBinding(attributes[key]);\n    }\n  }\n  for (node = node.firstChild; node; node = node.nextSibling) {\n    emitRemoved(context, node, ignore);\n  }\n}\nfunction emitRemovedBinding(context, ignore, node, property) {\n  var binding = node[property];\n  if (binding) {\n    node[property] = null;\n    if (binding !== ignore) {\n      context.removeBinding(binding);\n    }\n  }\n}\n\nfunction attachError(parent, node) {\n  if (typeof console !== 'undefined') {\n    console.error('Attach failed for', node, 'within', parent);\n  }\n  return new Error('Attaching bindings failed, because HTML structure ' +\n    'does not match client rendering.'\n  );\n}\n\nfunction Binding() {\n  this.meta = null;\n}\nBinding.prototype.type = 'Binding';\nBinding.prototype.update = function() {\n  this.context.pause();\n  this.template.update(this.context, this);\n  this.context.unpause();\n};\nBinding.prototype.insert = function() {\n  this.update();\n};\nBinding.prototype.remove = function() {\n  this.update();\n};\nBinding.prototype.move = function() {\n  this.update();\n};\n\nfunction NodeBinding(template, context, node) {\n  this.template = template;\n  this.context = context;\n  this.node = node;\n  this.meta = null;\n  setNodeProperty(node, '$bindNode', this);\n}\nNodeBinding.prototype = Object.create(Binding.prototype);\nNodeBinding.prototype.constructor = NodeBinding;\nNodeBinding.prototype.type = 'NodeBinding';\n\nfunction AttributeBindingsMap() {}\nfunction AttributeBinding(template, context, element, name) {\n  this.template = template;\n  this.context = context;\n  this.element = element;\n  this.name = name;\n  this.meta = null;\n  var map = element.$bindAttributes ||\n    (element.$bindAttributes = new AttributeBindingsMap());\n  map[name] = this;\n}\nAttributeBinding.prototype = Object.create(Binding.prototype);\nAttributeBinding.prototype.constructor = AttributeBinding;\nAttributeBinding.prototype.type = 'AttributeBinding';\n\nfunction RangeBinding(template, context, start, end, itemFor, condition) {\n  this.template = template;\n  this.context = context;\n  this.start = start;\n  this.end = end;\n  this.itemFor = itemFor;\n  this.condition = condition;\n  this.meta = null;\n  setNodeBounds(this, start, itemFor);\n}\nRangeBinding.prototype = Object.create(Binding.prototype);\nRangeBinding.prototype.constructor = RangeBinding;\nRangeBinding.prototype.type = 'RangeBinding';\nRangeBinding.prototype.insert = function(index, howMany) {\n  this.context.pause();\n  if (this.template.insert) {\n    this.template.insert(this.context, this, index, howMany);\n  } else {\n    this.template.update(this.context, this);\n  }\n  this.context.unpause();\n};\nRangeBinding.prototype.remove = function(index, howMany) {\n  this.context.pause();\n  if (this.template.remove) {\n    this.template.remove(this.context, this, index, howMany);\n  } else {\n    this.template.update(this.context, this);\n  }\n  this.context.unpause();\n};\nRangeBinding.prototype.move = function(from, to, howMany) {\n  this.context.pause();\n  if (this.template.move) {\n    this.template.move(this.context, this, from, to, howMany);\n  } else {\n    this.template.update(this.context, this);\n  }\n  this.context.unpause();\n};\n\n\n//// Utility functions ////\n\nfunction noop() {}\n\nfunction mergeInto(from, to) {\n  for (var key in from) {\n    to[key] = from[key];\n  }\n}\n\nfunction escapeHtml(string) {\n  string = string + '';\n  return string.replace(/[&<]/g, function(match) {\n    return (match === '&') ? '&amp;' : '&lt;';\n  });\n}\n\nfunction escapeAttribute(string) {\n  string = string + '';\n  return string.replace(/[&\"]/g, function(match) {\n    return (match === '&') ? '&amp;' : '&quot;';\n  });\n}\n\nfunction equalConditions(a, b) {\n  // First, test for strict equality\n  if (a === b) return true;\n  // Failing that, allow for template objects used as a condition to define a\n  // custom `equals()` method to indicate equivalence\n  return (a instanceof Template) && a.equals(b);\n}\n\n\n//// Shims & workarounds ////\n\n// General notes:\n//\n// In all cases, Node.insertBefore should have `|| null` after its second\n// argument. IE works correctly when the argument is ommitted or equal\n// to null, but it throws and error if it is equal to undefined.\n\nif (!Array.isArray) {\n  Array.isArray = function(value) {\n    return Object.prototype.toString.call(value) === '[object Array]';\n  };\n}\n\n// Equivalent to textNode.splitText, which is buggy in IE <=9\nfunction splitData(node, index) {\n  var newNode = node.cloneNode(false);\n  newNode.deleteData(0, index);\n  node.deleteData(index, node.length - index);\n  node.parentNode.insertBefore(newNode, node.nextSibling || null);\n  return newNode;\n}\n\n// Defined so that it can be overriden in IE <=8\nfunction setNodeProperty(node, key, value) {\n  return node[key] = value;\n}\n\nfunction normalizeLineBreaks(string) {\n  return string;\n}\n\n(function() {\n  // Don't try to shim in Node.js environment\n  if (typeof document === 'undefined') return;\n\n  var div = document.createElement('div');\n  div.innerHTML = '\\r\\n<br>\\n'\n  var windowsLength = div.firstChild.data.length;\n  var unixLength = div.lastChild.data.length;\n  if (windowsLength === 1 && unixLength === 1) {\n    normalizeLineBreaks = function(string) {\n      return string.replace(/\\r\\n/g, '\\n');\n    };\n  } else if (windowsLength === 2 && unixLength === 2) {\n    normalizeLineBreaks = function(string) {\n      return string.replace(/(^|[^\\r])(\\n+)/g, function(match, value, newLines) {\n        for (var i = newLines.length; i--;) {\n          value += '\\r\\n';\n        }\n        return value;\n      });\n    };\n  }\n\n  // TODO: Shim createHtmlFragment for old IE\n\n  // TODO: Shim setAttribute('style'), which doesn't work in IE <=7\n  // http://webbugtrack.blogspot.com/2007/10/bug-245-setattribute-style-does-not.html\n\n  // TODO: Investigate whether input name attribute works in IE <=7. We could\n  // override Element::appendTo to use IE's alternative createElement syntax:\n  // document.createElement('<input name=\"xxx\">')\n  // http://webbugtrack.blogspot.com/2007/10/bug-235-createelement-is-broken-in-ie.html\n\n  // In IE, input.defaultValue doesn't work correctly, so use input.value,\n  // which mistakenly but conveniently sets both the value property and attribute.\n  //\n  // Surprisingly, in IE <=7, input.defaultChecked must be used instead of\n  // input.checked before the input is in the document.\n  // http://webbugtrack.blogspot.com/2007/11/bug-299-setattribute-checked-does-not.html\n  var input = document.createElement('input');\n  input.defaultValue = 'x';\n  if (input.value !== 'x') {\n    CREATE_PROPERTIES.value = 'value';\n  }\n\n  try {\n    // TextNodes are not expando in IE <=8\n    document.createTextNode('').$try = 0;\n  } catch (err) {\n    setNodeProperty = function(node, key, value) {\n      // If trying to set a property on a TextNode, create a proxy CommentNode\n      // and set the property on that node instead. Put the proxy after the\n      // TextNode if marking the end of a range, and before otherwise.\n      if (node.nodeType === 3) {\n        var proxyNode = node.previousSibling;\n        if (!proxyNode || proxyNode.$bindProxy !== node) {\n          proxyNode = document.createComment('proxy');\n          proxyNode.$bindProxy = node;\n          node.parentNode.insertBefore(proxyNode, node || null);\n        }\n        return proxyNode[key] = value;\n      }\n      // Set the property directly on other node types\n      return node[key] = value;\n    };\n  }\n})();\n",
    "exports.instance = serializeInstance;\nexports.args = serializeArgs;\nexports.value = serializeValue;\n\nfunction serializeInstance(instance) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return 'new ' + instance.module + '.' + instance.type +\n    '(' + serializeArgs(args) + ')';\n}\n\nfunction serializeArgs(args) {\n  // Map each argument into its string representation\n  var items = [];\n  for (var i = args.length; i--;) {\n    var item = serializeValue(args[i]);\n    items.unshift(item);\n  }\n  // Remove trailing null values, assuming they are optional\n  for (var i = items.length; i--;) {\n    var item = items[i];\n    if (item !== 'void 0' && item !== 'null') break;\n    items.pop();\n  }\n  return items.join(', ');\n}\n\nfunction serializeValue(input) {\n  if (input && input.serialize) {\n    return input.serialize();\n\n  } else if (typeof input === 'undefined') {\n    return 'void 0';\n\n  } else if (input === null) {\n    return 'null';\n\n  } else if (typeof input === 'string') {\n    return formatString(input);\n\n  } else if (typeof input === 'number' || typeof input === 'boolean') {\n    return input + '';\n\n  } else if (Array.isArray(input)) {\n    var items = [];\n    for (var i = 0; i < input.length; i++) {\n      var value = serializeValue(input[i]);\n      items.push(value);\n    }\n    return '[' + items.join(', ') + ']';\n\n  } else if (typeof input === 'object') {\n    var items = [];\n    for (var key in input) {\n      var value = serializeValue(input[key]);\n      items.push(formatString(key) + ': ' + value);\n    }\n    return '{' + items.join(', ') + '}';\n  }\n}\nfunction formatString(value) {\n  var escaped = value.replace(/['\\r\\n\\\\]/g, function(match) {\n    return (match === '\\'') ? '\\\\\\'' :\n      (match === '\\r') ? '\\\\r' :\n      (match === '\\n') ? '\\\\n' :\n      (match === '\\\\') ? '\\\\\\\\' :\n      '';\n  });\n  return '\\'' + escaped + '\\'';\n}\n",
    "var Doc = require('./doc');\nvar Query = require('./query');\nvar Presence = require('./presence/presence');\nvar DocPresence = require('./presence/doc-presence');\nvar SnapshotVersionRequest = require('./snapshot-request/snapshot-version-request');\nvar SnapshotTimestampRequest = require('./snapshot-request/snapshot-timestamp-request');\nvar emitter = require('../emitter');\nvar ShareDBError = require('../error');\nvar types = require('../types');\nvar util = require('../util');\nvar logger = require('../logger');\n\nvar ERROR_CODE = ShareDBError.CODES;\n\nfunction connectionState(socket) {\n  if (socket.readyState === 0 || socket.readyState === 1) return 'connecting';\n  return 'disconnected';\n}\n\n/**\n * Handles communication with the sharejs server and provides queries and\n * documents.\n *\n * We create a connection with a socket object\n *   connection = new sharejs.Connection(sockset)\n * The socket may be any object handling the websocket protocol. See the\n * documentation of bindToSocket() for details. We then wait for the connection\n * to connect\n *   connection.on('connected', ...)\n * and are finally able to work with shared documents\n *   connection.get('food', 'steak') // Doc\n *\n * @param socket @see bindToSocket\n */\nmodule.exports = Connection;\nfunction Connection(socket) {\n  emitter.EventEmitter.call(this);\n\n  // Map of collection -> id -> doc object for created documents.\n  // (created documents MUST BE UNIQUE)\n  this.collections = {};\n\n  // Each query and snapshot request is created with an id that the server uses when it sends us\n  // info about the request (updates, etc)\n  this.nextQueryId = 1;\n  this.nextSnapshotRequestId = 1;\n\n  // Map from query ID -> query object.\n  this.queries = {};\n\n  // Maps from channel -> presence objects\n  this._presences = {};\n\n  // Map from snapshot request ID -> snapshot request\n  this._snapshotRequests = {};\n\n  // A unique message number for the given id\n  this.seq = 1;\n\n  // A unique message number for presence\n  this._presenceSeq = 1;\n\n  // Equals agent.src on the server\n  this.id = null;\n\n  // This direct reference from connection to agent is not used internal to\n  // ShareDB, but it is handy for server-side only user code that may cache\n  // state on the agent and read it in middleware\n  this.agent = null;\n\n  this.debug = false;\n\n  this.state = connectionState(socket);\n\n  this.bindToSocket(socket);\n}\nemitter.mixin(Connection);\n\n\n/**\n * Use socket to communicate with server\n *\n * Socket is an object that can handle the websocket protocol. This method\n * installs the onopen, onclose, onmessage and onerror handlers on the socket to\n * handle communication and sends messages by calling socket.send(message). The\n * sockets `readyState` property is used to determine the initaial state.\n *\n * @param socket Handles the websocket protocol\n * @param socket.readyState\n * @param socket.close\n * @param socket.send\n * @param socket.onopen\n * @param socket.onclose\n * @param socket.onmessage\n * @param socket.onerror\n */\nConnection.prototype.bindToSocket = function(socket) {\n  if (this.socket) {\n    this.socket.close();\n    this.socket.onmessage = null;\n    this.socket.onopen = null;\n    this.socket.onerror = null;\n    this.socket.onclose = null;\n  }\n\n  this.socket = socket;\n\n  // State of the connection. The corresponding events are emitted when this changes\n  //\n  // - 'connecting'   The connection is still being established, or we are still\n  //                    waiting on the server to send us the initialization message\n  // - 'connected'    The connection is open and we have connected to a server\n  //                    and recieved the initialization message\n  // - 'disconnected' Connection is closed, but it will reconnect automatically\n  // - 'closed'       The connection was closed by the client, and will not reconnect\n  // - 'stopped'      The connection was closed by the server, and will not reconnect\n  var newState = connectionState(socket);\n  this._setState(newState);\n\n  // This is a helper variable the document uses to see whether we're\n  // currently in a 'live' state. It is true if and only if we're connected\n  this.canSend = false;\n\n  var connection = this;\n\n  socket.onmessage = function(event) {\n    try {\n      var data = (typeof event.data === 'string') ?\n        JSON.parse(event.data) : event.data;\n    } catch (err) {\n      logger.warn('Failed to parse message', event);\n      return;\n    }\n\n    if (connection.debug) logger.info('RECV', JSON.stringify(data));\n\n    var request = {data: data};\n    connection.emit('receive', request);\n    if (!request.data) return;\n\n    try {\n      connection.handleMessage(request.data);\n    } catch (err) {\n      process.nextTick(function() {\n        connection.emit('error', err);\n      });\n    }\n  };\n\n  // If socket is already open, do handshake immediately.\n  if (socket.readyState === 1) {\n    connection._initializeHandshake();\n  }\n  socket.onopen = function() {\n    connection._setState('connecting');\n    connection._initializeHandshake();\n  };\n\n  socket.onerror = function(err) {\n    // This isn't the same as a regular error, because it will happen normally\n    // from time to time. Your connection should probably automatically\n    // reconnect anyway, but that should be triggered off onclose not onerror.\n    // (onclose happens when onerror gets called anyway).\n    connection.emit('connection error', err);\n  };\n\n  socket.onclose = function(reason) {\n    // node-browserchannel reason values:\n    //   'Closed' - The socket was manually closed by calling socket.close()\n    //   'Stopped by server' - The server sent the stop message to tell the client not to try connecting\n    //   'Request failed' - Server didn't respond to request (temporary, usually offline)\n    //   'Unknown session ID' - Server session for client is missing (temporary, will immediately reestablish)\n\n    if (reason === 'closed' || reason === 'Closed') {\n      connection._setState('closed', reason);\n    } else if (reason === 'stopped' || reason === 'Stopped by server') {\n      connection._setState('stopped', reason);\n    } else {\n      connection._setState('disconnected', reason);\n    }\n  };\n};\n\n/**\n * @param {object} message\n * @param {String} message.a action\n */\nConnection.prototype.handleMessage = function(message) {\n  var err = null;\n  if (message.error) {\n    err = wrapErrorData(message.error, message);\n    delete message.error;\n  }\n  // Switch on the message action. Most messages are for documents and are\n  // handled in the doc class.\n  switch (message.a) {\n    case 'init':\n      // Client initialization packet\n      return this._handleLegacyInit(message);\n    case 'hs':\n      return this._handleHandshake(err, message);\n    case 'qf':\n      var query = this.queries[message.id];\n      if (query) query._handleFetch(err, message.data, message.extra);\n      return;\n    case 'qs':\n      var query = this.queries[message.id];\n      if (query) query._handleSubscribe(err, message.data, message.extra);\n      return;\n    case 'qu':\n      // Queries are removed immediately on calls to destroy, so we ignore\n      // replies to query unsubscribes. Perhaps there should be a callback for\n      // destroy, but this is currently unimplemented\n      return;\n    case 'q':\n      // Query message. Pass this to the appropriate query object.\n      var query = this.queries[message.id];\n      if (!query) return;\n      if (err) return query._handleError(err);\n      if (message.diff) query._handleDiff(message.diff);\n      if (message.hasOwnProperty('extra')) query._handleExtra(message.extra);\n      return;\n\n    case 'bf':\n      return this._handleBulkMessage(err, message, '_handleFetch');\n    case 'bs':\n    case 'bu':\n      return this._handleBulkMessage(err, message, '_handleSubscribe');\n\n    case 'nf':\n    case 'nt':\n      return this._handleSnapshotFetch(err, message);\n\n    case 'f':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleFetch(err, message.data);\n      return;\n    case 's':\n    case 'u':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleSubscribe(err, message.data);\n      return;\n    case 'op':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleOp(err, message);\n      return;\n    case 'p':\n      return this._handlePresence(err, message);\n    case 'ps':\n      return this._handlePresenceSubscribe(err, message);\n    case 'pu':\n      return this._handlePresenceUnsubscribe(err, message);\n    case 'pr':\n      return this._handlePresenceRequest(err, message);\n\n    default:\n      logger.warn('Ignoring unrecognized message', message);\n  }\n};\n\nfunction wrapErrorData(errorData, fullMessage) {\n  // wrap in Error object so can be passed through event emitters\n  var err = new Error(errorData.message);\n  err.code = errorData.code;\n  if (fullMessage) {\n    // Add the message data to the error object for more context\n    err.data = fullMessage;\n  }\n  return err;\n}\n\nConnection.prototype._handleBulkMessage = function(err, message, method) {\n  if (message.data) {\n    for (var id in message.data) {\n      var dataForId = message.data[id];\n      var doc = this.getExisting(message.c, id);\n      if (doc) {\n        if (err) {\n          doc[method](err);\n        } else if (dataForId.error) {\n          // Bulk reply snapshot-specific errorr - see agent.js getMapResult\n          doc[method](wrapErrorData(dataForId.error));\n        } else {\n          doc[method](null, dataForId);\n        }\n      }\n    }\n  } else if (Array.isArray(message.b)) {\n    for (var i = 0; i < message.b.length; i++) {\n      var id = message.b[i];\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](err);\n    }\n  } else if (message.b) {\n    for (var id in message.b) {\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](err);\n    }\n  } else {\n    logger.error('Invalid bulk message', message);\n  }\n};\n\nConnection.prototype._reset = function() {\n  this.agent = null;\n};\n\n// Set the connection's state. The connection is basically a state machine.\nConnection.prototype._setState = function(newState, reason) {\n  if (this.state === newState) return;\n\n  // I made a state diagram. The only invalid transitions are getting to\n  // 'connecting' from anywhere other than 'disconnected' and getting to\n  // 'connected' from anywhere other than 'connecting'.\n  if (\n    (\n      newState === 'connecting' &&\n      this.state !== 'disconnected' &&\n      this.state !== 'stopped' &&\n      this.state !== 'closed'\n    ) || (\n      newState === 'connected' &&\n      this.state !== 'connecting'\n    )\n  ) {\n    var err = new ShareDBError(\n      ERROR_CODE.ERR_CONNECTION_STATE_TRANSITION_INVALID,\n      'Cannot transition directly from ' + this.state + ' to ' + newState\n    );\n    return this.emit('error', err);\n  }\n\n  this.state = newState;\n  this.canSend = (newState === 'connected');\n\n  if (\n    newState === 'disconnected' ||\n    newState === 'stopped' ||\n    newState === 'closed'\n  ) {\n    this._reset();\n  }\n\n  // Group subscribes together to help server make more efficient calls\n  this.startBulk();\n  // Emit the event to all queries\n  for (var id in this.queries) {\n    var query = this.queries[id];\n    query._onConnectionStateChanged();\n  }\n  // Emit the event to all documents\n  for (var collection in this.collections) {\n    var docs = this.collections[collection];\n    for (var id in docs) {\n      docs[id]._onConnectionStateChanged();\n    }\n  }\n  // Emit the event to all Presences\n  for (var channel in this._presences) {\n    this._presences[channel]._onConnectionStateChanged();\n  }\n  // Emit the event to all snapshots\n  for (var id in this._snapshotRequests) {\n    var snapshotRequest = this._snapshotRequests[id];\n    snapshotRequest._onConnectionStateChanged();\n  }\n  this.endBulk();\n\n  this.emit(newState, reason);\n  this.emit('state', newState, reason);\n};\n\nConnection.prototype.startBulk = function() {\n  if (!this.bulk) this.bulk = {};\n};\n\nConnection.prototype.endBulk = function() {\n  if (this.bulk) {\n    for (var collection in this.bulk) {\n      var actions = this.bulk[collection];\n      this._sendBulk('f', collection, actions.f);\n      this._sendBulk('s', collection, actions.s);\n      this._sendBulk('u', collection, actions.u);\n    }\n  }\n  this.bulk = null;\n};\n\nConnection.prototype._sendBulk = function(action, collection, values) {\n  if (!values) return;\n  var ids = [];\n  var versions = {};\n  var versionsCount = 0;\n  var versionId;\n  for (var id in values) {\n    var value = values[id];\n    if (value == null) {\n      ids.push(id);\n    } else {\n      versions[id] = value;\n      versionId = id;\n      versionsCount++;\n    }\n  }\n  if (ids.length === 1) {\n    var id = ids[0];\n    this.send({a: action, c: collection, d: id});\n  } else if (ids.length) {\n    this.send({a: 'b' + action, c: collection, b: ids});\n  }\n  if (versionsCount === 1) {\n    var version = versions[versionId];\n    this.send({a: action, c: collection, d: versionId, v: version});\n  } else if (versionsCount) {\n    this.send({a: 'b' + action, c: collection, b: versions});\n  }\n};\n\nConnection.prototype._sendAction = function(action, doc, version) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  if (this.bulk) {\n    // Bulk subscribe\n    var actions = this.bulk[doc.collection] || (this.bulk[doc.collection] = {});\n    var versions = actions[action] || (actions[action] = {});\n    var isDuplicate = versions.hasOwnProperty(doc.id);\n    versions[doc.id] = version;\n    return isDuplicate;\n  } else {\n    // Send single doc subscribe message\n    var message = {a: action, c: doc.collection, d: doc.id, v: version};\n    this.send(message);\n  }\n};\n\nConnection.prototype.sendFetch = function(doc) {\n  return this._sendAction('f', doc, doc.version);\n};\n\nConnection.prototype.sendSubscribe = function(doc) {\n  return this._sendAction('s', doc, doc.version);\n};\n\nConnection.prototype.sendUnsubscribe = function(doc) {\n  return this._sendAction('u', doc);\n};\n\nConnection.prototype.sendOp = function(doc, op) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  var message = {\n    a: 'op',\n    c: doc.collection,\n    d: doc.id,\n    v: doc.version,\n    src: op.src,\n    seq: op.seq\n  };\n  if ('op' in op) message.op = op.op;\n  if (op.create) message.create = op.create;\n  if (op.del) message.del = op.del;\n  this.send(message);\n};\n\n\n/**\n * Sends a message down the socket\n */\nConnection.prototype.send = function(message) {\n  if (this.debug) logger.info('SEND', JSON.stringify(message));\n\n  this.emit('send', message);\n  this.socket.send(JSON.stringify(message));\n};\n\n\n/**\n * Closes the socket and emits 'closed'\n */\nConnection.prototype.close = function() {\n  this.socket.close();\n};\n\nConnection.prototype.getExisting = function(collection, id) {\n  if (this.collections[collection]) return this.collections[collection][id];\n};\n\n\n/**\n * Get or create a document.\n *\n * @param collection\n * @param id\n * @return {Doc}\n */\nConnection.prototype.get = function(collection, id) {\n  var docs = this.collections[collection] ||\n    (this.collections[collection] = {});\n\n  var doc = docs[id];\n  if (!doc) {\n    doc = docs[id] = new Doc(this, collection, id);\n    this.emit('doc', doc);\n  }\n\n  return doc;\n};\n\n\n/**\n * Remove document from this.collections\n *\n * @private\n */\nConnection.prototype._destroyDoc = function(doc) {\n  util.digAndRemove(this.collections, doc.collection, doc.id);\n};\n\nConnection.prototype._addDoc = function(doc) {\n  var docs = this.collections[doc.collection];\n  if (!docs) {\n    docs = this.collections[doc.collection] = {};\n  }\n  if (docs[doc.id] !== doc) {\n    docs[doc.id] = doc;\n  }\n};\n\n// Helper for createFetchQuery and createSubscribeQuery, below.\nConnection.prototype._createQuery = function(action, collection, q, options, callback) {\n  var id = this.nextQueryId++;\n  var query = new Query(action, this, id, collection, q, options, callback);\n  this.queries[id] = query;\n  query.send();\n  return query;\n};\n\n// Internal function. Use query.destroy() to remove queries.\nConnection.prototype._destroyQuery = function(query) {\n  delete this.queries[query.id];\n};\n\n// The query options object can contain the following fields:\n//\n// db: Name of the db for the query. You can attach extraDbs to ShareDB and\n//   pick which one the query should hit using this parameter.\n\n// Create a fetch query. Fetch queries are only issued once, returning the\n// results directly into the callback.\n//\n// The callback should have the signature function(error, results, extra)\n// where results is a list of Doc objects.\nConnection.prototype.createFetchQuery = function(collection, q, options, callback) {\n  return this._createQuery('qf', collection, q, options, callback);\n};\n\n// Create a subscribe query. Subscribe queries return with the initial data\n// through the callback, then update themselves whenever the query result set\n// changes via their own event emitter.\n//\n// If present, the callback should have the signature function(error, results, extra)\n// where results is a list of Doc objects.\nConnection.prototype.createSubscribeQuery = function(collection, q, options, callback) {\n  return this._createQuery('qs', collection, q, options, callback);\n};\n\nConnection.prototype.hasPending = function() {\n  return !!(\n    this._firstDoc(hasPending) ||\n    this._firstQuery(hasPending) ||\n    this._firstSnapshotRequest()\n  );\n};\nfunction hasPending(object) {\n  return object.hasPending();\n}\n\nConnection.prototype.hasWritePending = function() {\n  return !!this._firstDoc(hasWritePending);\n};\nfunction hasWritePending(object) {\n  return object.hasWritePending();\n}\n\nConnection.prototype.whenNothingPending = function(callback) {\n  var doc = this._firstDoc(hasPending);\n  if (doc) {\n    // If a document is found with a pending operation, wait for it to emit\n    // that nothing is pending anymore, and then recheck all documents again.\n    // We have to recheck all documents, just in case another mutation has\n    // been made in the meantime as a result of an event callback\n    doc.once('nothing pending', this._nothingPendingRetry(callback));\n    return;\n  }\n  var query = this._firstQuery(hasPending);\n  if (query) {\n    query.once('ready', this._nothingPendingRetry(callback));\n    return;\n  }\n  var snapshotRequest = this._firstSnapshotRequest();\n  if (snapshotRequest) {\n    snapshotRequest.once('ready', this._nothingPendingRetry(callback));\n    return;\n  }\n  // Call back when no pending operations\n  process.nextTick(callback);\n};\nConnection.prototype._nothingPendingRetry = function(callback) {\n  var connection = this;\n  return function() {\n    process.nextTick(function() {\n      connection.whenNothingPending(callback);\n    });\n  };\n};\n\nConnection.prototype._firstDoc = function(fn) {\n  for (var collection in this.collections) {\n    var docs = this.collections[collection];\n    for (var id in docs) {\n      var doc = docs[id];\n      if (fn(doc)) {\n        return doc;\n      }\n    }\n  }\n};\n\nConnection.prototype._firstQuery = function(fn) {\n  for (var id in this.queries) {\n    var query = this.queries[id];\n    if (fn(query)) {\n      return query;\n    }\n  }\n};\n\nConnection.prototype._firstSnapshotRequest = function() {\n  for (var id in this._snapshotRequests) {\n    return this._snapshotRequests[id];\n  }\n};\n\n/**\n * Fetch a read-only snapshot at a given version\n *\n * @param collection - the collection name of the snapshot\n * @param id - the ID of the snapshot\n * @param version (optional) - the version number to fetch. If null, the latest version is fetched.\n * @param callback - (error, snapshot) => void, where snapshot takes the following schema:\n *\n * {\n *   id: string;         // ID of the snapshot\n *   v: number;          // version number of the snapshot\n *   type: string;       // the OT type of the snapshot, or null if it doesn't exist or is deleted\n *   data: any;          // the snapshot\n * }\n *\n */\nConnection.prototype.fetchSnapshot = function(collection, id, version, callback) {\n  if (typeof version === 'function') {\n    callback = version;\n    version = null;\n  }\n\n  var requestId = this.nextSnapshotRequestId++;\n  var snapshotRequest = new SnapshotVersionRequest(this, requestId, collection, id, version, callback);\n  this._snapshotRequests[snapshotRequest.requestId] = snapshotRequest;\n  snapshotRequest.send();\n};\n\n/**\n * Fetch a read-only snapshot at a given timestamp\n *\n * @param collection - the collection name of the snapshot\n * @param id - the ID of the snapshot\n * @param timestamp (optional) - the timestamp to fetch. If null, the latest version is fetched.\n * @param callback - (error, snapshot) => void, where snapshot takes the following schema:\n *\n * {\n *   id: string;         // ID of the snapshot\n *   v: number;          // version number of the snapshot\n *   type: string;       // the OT type of the snapshot, or null if it doesn't exist or is deleted\n *   data: any;          // the snapshot\n * }\n *\n */\nConnection.prototype.fetchSnapshotByTimestamp = function(collection, id, timestamp, callback) {\n  if (typeof timestamp === 'function') {\n    callback = timestamp;\n    timestamp = null;\n  }\n\n  var requestId = this.nextSnapshotRequestId++;\n  var snapshotRequest = new SnapshotTimestampRequest(this, requestId, collection, id, timestamp, callback);\n  this._snapshotRequests[snapshotRequest.requestId] = snapshotRequest;\n  snapshotRequest.send();\n};\n\nConnection.prototype._handleSnapshotFetch = function(error, message) {\n  var snapshotRequest = this._snapshotRequests[message.id];\n  if (!snapshotRequest) return;\n  delete this._snapshotRequests[message.id];\n  snapshotRequest._handleResponse(error, message);\n};\n\nConnection.prototype._handleLegacyInit = function(message) {\n  // If the minor protocol version has been set, we can ignore this legacy\n  // init message, and wait for a response to our handshake message.\n  if (message.protocolMinor) return;\n  this._initialize(message);\n};\n\nConnection.prototype._initializeHandshake = function() {\n  this.send({a: 'hs', id: this.id});\n};\n\nConnection.prototype._handleHandshake = function(error, message) {\n  if (error) return this.emit('error', error);\n  this._initialize(message);\n};\n\nConnection.prototype._initialize = function(message) {\n  if (message.protocol !== 1) {\n    return this.emit('error', new ShareDBError(\n      ERROR_CODE.ERR_PROTOCOL_VERSION_NOT_SUPPORTED,\n      'Unsupported protocol version: ' + message.protocol\n    ));\n  }\n  if (types.map[message.type] !== types.defaultType) {\n    return this.emit('error', new ShareDBError(\n      ERROR_CODE.ERR_DEFAULT_TYPE_MISMATCH,\n      message.type + ' does not match the server default type'\n    ));\n  }\n  if (typeof message.id !== 'string') {\n    return this.emit('error', new ShareDBError(\n      ERROR_CODE.ERR_CLIENT_ID_BADLY_FORMED,\n      'Client id must be a string'\n    ));\n  }\n  this.id = message.id;\n\n  this._setState('connected');\n};\n\nConnection.prototype.getPresence = function(channel) {\n  var connection = this;\n  return util.digOrCreate(this._presences, channel, function() {\n    return new Presence(connection, channel);\n  });\n};\n\nConnection.prototype.getDocPresence = function(collection, id) {\n  var channel = DocPresence.channel(collection, id);\n  var connection = this;\n  return util.digOrCreate(this._presences, channel, function() {\n    return new DocPresence(connection, collection, id);\n  });\n};\n\nConnection.prototype._sendPresenceAction = function(action, seq, presence) {\n  // Ensure the presence is registered so that it receives the reply message\n  this._addPresence(presence);\n  var message = {a: action, ch: presence.channel, seq: seq};\n  this.send(message);\n  return message.seq;\n};\n\nConnection.prototype._addPresence = function(presence) {\n  util.digOrCreate(this._presences, presence.channel, function() {\n    return presence;\n  });\n};\n\nConnection.prototype._handlePresenceSubscribe = function(error, message) {\n  var presence = util.dig(this._presences, message.ch);\n  if (presence) presence._handleSubscribe(error, message.seq);\n};\n\nConnection.prototype._handlePresenceUnsubscribe = function(error, message) {\n  var presence = util.dig(this._presences, message.ch);\n  if (presence) presence._handleUnsubscribe(error, message.seq);\n};\n\nConnection.prototype._handlePresence = function(error, message) {\n  var presence = util.dig(this._presences, message.ch);\n  if (presence) presence._receiveUpdate(error, message);\n};\n\nConnection.prototype._handlePresenceRequest = function(error, message) {\n  var presence = util.dig(this._presences, message.ch);\n  if (presence) presence._broadcastAllLocalPresence(error, message);\n};\n",
    "var emitter = require('../emitter');\nvar logger = require('../logger');\nvar ShareDBError = require('../error');\nvar types = require('../types');\nvar util = require('../util');\n\nvar ERROR_CODE = ShareDBError.CODES;\n\n/**\n * A Doc is a client's view on a sharejs document.\n *\n * It is is uniquely identified by its `id` and `collection`.  Documents\n * should not be created directly. Create them with connection.get()\n *\n *\n * Subscriptions\n * -------------\n *\n * We can subscribe a document to stay in sync with the server.\n *   doc.subscribe(function(error) {\n *     doc.subscribed // = true\n *   })\n * The server now sends us all changes concerning this document and these are\n * applied to our data. If the subscription was successful the initial\n * data and version sent by the server are loaded into the document.\n *\n * To stop listening to the changes we call `doc.unsubscribe()`.\n *\n * If we just want to load the data but not stay up-to-date, we call\n *   doc.fetch(function(error) {\n *     doc.data // sent by server\n *   })\n *\n *\n * Events\n * ------\n *\n * You can use doc.on(eventName, callback) to subscribe to the following events:\n * - `before op (op, source)` Fired before a partial operation is applied to the data.\n *   It may be used to read the old data just before applying an operation\n * - `op (op, source)` Fired after every partial operation with this operation as the\n *   first argument\n * - `create (source)` The document was created. That means its type was\n *   set and it has some initial data.\n * - `del (data, source)` Fired after the document is deleted, that is\n *   the data is null. It is passed the data before delteion as an\n *   arguments\n * - `load ()` Fired when a new snapshot is ingested from a fetch, subscribe, or query\n */\n\nmodule.exports = Doc;\nfunction Doc(connection, collection, id) {\n  emitter.EventEmitter.call(this);\n\n  this.connection = connection;\n\n  this.collection = collection;\n  this.id = id;\n\n  this.version = null;\n  this.type = null;\n  this.data = undefined;\n\n  // Array of callbacks or nulls as placeholders\n  this.inflightFetch = [];\n  this.inflightSubscribe = null;\n  this.pendingFetch = [];\n  this.pendingSubscribe = [];\n\n  // Whether we think we are subscribed on the server. Synchronously set to\n  // false on calls to unsubscribe and disconnect. Should never be true when\n  // this.wantSubscribe is false\n  this.subscribed = false;\n  // Whether to re-establish the subscription on reconnect\n  this.wantSubscribe = false;\n\n  // The op that is currently roundtripping to the server, or null.\n  //\n  // When the connection reconnects, the inflight op is resubmitted.\n  //\n  // This has the same format as an entry in pendingOps\n  this.inflightOp = null;\n\n  // All ops that are waiting for the server to acknowledge this.inflightOp\n  // This used to just be a single operation, but creates & deletes can't be\n  // composed with regular operations.\n  //\n  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}\n  this.pendingOps = [];\n\n  // The OT type of this document. An uncreated document has type `null`\n  this.type = null;\n\n  // The applyStack enables us to track any ops submitted while we are\n  // applying an op incrementally. This value is an array when we are\n  // performing an incremental apply and null otherwise. When it is an array,\n  // all submitted ops should be pushed onto it. The `_otApply` method will\n  // reset it back to null when all incremental apply loops are complete.\n  this.applyStack = null;\n\n  // Disable the default behavior of composing submitted ops. This is read at\n  // the time of op submit, so it may be toggled on before submitting a\n  // specifc op and toggled off afterward\n  this.preventCompose = false;\n}\nemitter.mixin(Doc);\n\nDoc.prototype.destroy = function(callback) {\n  var doc = this;\n  doc.whenNothingPending(function() {\n    if (doc.wantSubscribe) {\n      doc.unsubscribe(function(err) {\n        if (err) {\n          if (callback) return callback(err);\n          return doc.emit('error', err);\n        }\n        doc.connection._destroyDoc(doc);\n        doc.emit('destroy');\n        if (callback) callback();\n      });\n    } else {\n      doc.connection._destroyDoc(doc);\n      doc.emit('destroy');\n      if (callback) callback();\n    }\n  });\n};\n\n\n// ****** Manipulating the document data, version and type.\n\n// Set the document's type, and associated properties. Most of the logic in\n// this function exists to update the document based on any added & removed API\n// methods.\n//\n// @param newType OT type provided by the ottypes library or its name or uri\nDoc.prototype._setType = function(newType) {\n  if (typeof newType === 'string') {\n    newType = types.map[newType];\n  }\n\n  if (newType) {\n    this.type = newType;\n  } else if (newType === null) {\n    this.type = newType;\n    // If we removed the type from the object, also remove its data\n    this.data = undefined;\n  } else {\n    var err = new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, 'Missing type ' + newType);\n    return this.emit('error', err);\n  }\n};\n\n// Ingest snapshot data. This data must include a version, snapshot and type.\n// This is used both to ingest data that was exported with a webpage and data\n// that was received from the server during a fetch.\n//\n// @param snapshot.v    version\n// @param snapshot.data\n// @param snapshot.type\n// @param callback\nDoc.prototype.ingestSnapshot = function(snapshot, callback) {\n  if (!snapshot) return callback && callback();\n\n  if (typeof snapshot.v !== 'number') {\n    var err = new ShareDBError(\n      ERROR_CODE.ERR_INGESTED_SNAPSHOT_HAS_NO_VERSION,\n      'Missing version in ingested snapshot. ' + this.collection + '.' + this.id\n    );\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n\n  // If the doc is already created or there are ops pending, we cannot use the\n  // ingested snapshot and need ops in order to update the document\n  if (this.type || this.hasWritePending()) {\n    // The version should only be null on a created document when it was\n    // created locally without fetching\n    if (this.version == null) {\n      if (this.hasWritePending()) {\n        // If we have pending ops and we get a snapshot for a locally created\n        // document, we have to wait for the pending ops to complete, because\n        // we don't know what version to fetch ops from. It is possible that\n        // the snapshot came from our local op, but it is also possible that\n        // the doc was created remotely (which would conflict and be an error)\n        return callback && this.once('no write pending', callback);\n      }\n      // Otherwise, we've encounted an error state\n      var err = new ShareDBError(\n        ERROR_CODE.ERR_DOC_MISSING_VERSION,\n        'Cannot ingest snapshot in doc with null version. ' + this.collection + '.' + this.id\n      );\n      if (callback) return callback(err);\n      return this.emit('error', err);\n    }\n    // If we got a snapshot for a version further along than the document is\n    // currently, issue a fetch to get the latest ops and catch us up\n    if (snapshot.v > this.version) return this.fetch(callback);\n    return callback && callback();\n  }\n\n  // Ignore the snapshot if we are already at a newer version. Under no\n  // circumstance should we ever set the current version backward\n  if (this.version > snapshot.v) return callback && callback();\n\n  this.version = snapshot.v;\n  var type = (snapshot.type === undefined) ? types.defaultType : snapshot.type;\n  this._setType(type);\n  this.data = (this.type && this.type.deserialize) ?\n    this.type.deserialize(snapshot.data) :\n    snapshot.data;\n  this.emit('load');\n  callback && callback();\n};\n\nDoc.prototype.whenNothingPending = function(callback) {\n  var doc = this;\n  process.nextTick(function() {\n    if (doc.hasPending()) {\n      doc.once('nothing pending', callback);\n      return;\n    }\n    callback();\n  });\n};\n\nDoc.prototype.hasPending = function() {\n  return !!(\n    this.inflightOp ||\n    this.pendingOps.length ||\n    this.inflightFetch.length ||\n    this.inflightSubscribe ||\n    this.pendingFetch.length ||\n    this.pendingSubscribe.length\n  );\n};\n\nDoc.prototype.hasWritePending = function() {\n  return !!(this.inflightOp || this.pendingOps.length);\n};\n\nDoc.prototype._emitNothingPending = function() {\n  if (this.hasWritePending()) return;\n  this.emit('no write pending');\n  if (this.hasPending()) return;\n  this.emit('nothing pending');\n};\n\n// **** Helpers for network messages\n\nDoc.prototype._emitResponseError = function(err, callback) {\n  if (err && err.code === ERROR_CODE.ERR_SNAPSHOT_READ_SILENT_REJECTION) {\n    this.wantSubscribe = false;\n    if (callback) {\n      callback();\n    }\n    this._emitNothingPending();\n    return;\n  }\n  if (callback) {\n    callback(err);\n    this._emitNothingPending();\n    return;\n  }\n  this._emitNothingPending();\n  this.emit('error', err);\n};\n\nDoc.prototype._handleFetch = function(error, snapshot) {\n  var callbacks = this.pendingFetch;\n  this.pendingFetch = [];\n  var callback = this.inflightFetch.shift();\n  if (callback) callbacks.push(callback);\n  if (callbacks.length) {\n    callback = function(error) {\n      util.callEach(callbacks, error);\n    };\n  }\n  if (error) return this._emitResponseError(error, callback);\n  this.ingestSnapshot(snapshot, callback);\n  this._emitNothingPending();\n};\n\nDoc.prototype._handleSubscribe = function(error, snapshot) {\n  var request = this.inflightSubscribe;\n  this.inflightSubscribe = null;\n  var callbacks = this.pendingFetch;\n  this.pendingFetch = [];\n  if (request.callback) callbacks.push(request.callback);\n  var callback;\n  if (callbacks.length) {\n    callback = function(error) {\n      util.callEach(callbacks, error);\n    };\n  }\n  if (error) return this._emitResponseError(error, callback);\n  this.subscribed = request.wantSubscribe;\n  if (this.subscribed) this.ingestSnapshot(snapshot, callback);\n  else if (callback) callback();\n  this._emitNothingPending();\n  this._flushSubscribe();\n};\n\nDoc.prototype._handleOp = function(err, message) {\n  if (err) {\n    if (this.inflightOp) {\n      // The server has rejected submission of the current operation. If we get\n      // an \"Op submit rejected\" error, this was done intentionally\n      // and we should roll back but not return an error to the user.\n      if (err.code === ERROR_CODE.ERR_OP_SUBMIT_REJECTED) err = null;\n      return this._rollback(err);\n    }\n    return this.emit('error', err);\n  }\n\n  if (this.inflightOp &&\n      message.src === this.inflightOp.src &&\n      message.seq === this.inflightOp.seq) {\n    // The op has already been applied locally. Just update the version\n    // and pending state appropriately\n    this._opAcknowledged(message);\n    return;\n  }\n\n  if (this.version == null || message.v > this.version) {\n    // This will happen in normal operation if we become subscribed to a\n    // new document via a query. It can also happen if we get an op for\n    // a future version beyond the version we are expecting next. This\n    // could happen if the server doesn't publish an op for whatever reason\n    // or because of a race condition. In any case, we can send a fetch\n    // command to catch back up.\n    //\n    // Fetch only sends a new fetch command if no fetches are inflight, which\n    // will act as a natural debouncing so we don't send multiple fetch\n    // requests for many ops received at once.\n    this.fetch();\n    return;\n  }\n\n  if (message.v < this.version) {\n    // We can safely ignore the old (duplicate) operation.\n    return;\n  }\n\n  if (this.inflightOp) {\n    var transformErr = transformX(this.inflightOp, message);\n    if (transformErr) return this._hardRollback(transformErr);\n  }\n\n  for (var i = 0; i < this.pendingOps.length; i++) {\n    var transformErr = transformX(this.pendingOps[i], message);\n    if (transformErr) return this._hardRollback(transformErr);\n  }\n\n  this.version++;\n  try {\n    this._otApply(message, false);\n  } catch (error) {\n    return this._hardRollback(error);\n  }\n};\n\n// Called whenever (you guessed it!) the connection state changes. This will\n// happen when we get disconnected & reconnect.\nDoc.prototype._onConnectionStateChanged = function() {\n  if (this.connection.canSend) {\n    this.flush();\n    this._resubscribe();\n  } else {\n    if (this.inflightOp) {\n      this.pendingOps.unshift(this.inflightOp);\n      this.inflightOp = null;\n    }\n    this.subscribed = false;\n    if (this.inflightSubscribe) {\n      if (this.inflightSubscribe.wantSubscribe) {\n        this.pendingSubscribe.unshift(this.inflightSubscribe);\n        this.inflightSubscribe = null;\n      } else {\n        this._handleSubscribe();\n      }\n    }\n    if (this.inflightFetch.length) {\n      this.pendingFetch = this.pendingFetch.concat(this.inflightFetch);\n      this.inflightFetch.length = 0;\n    }\n  }\n};\n\nDoc.prototype._resubscribe = function() {\n  if (!this.pendingSubscribe.length && this.wantSubscribe) {\n    return this.subscribe();\n  }\n  var willFetch = this.pendingSubscribe.some(function(request) {\n    return request.wantSubscribe;\n  });\n  if (!willFetch && this.pendingFetch.length) this.fetch();\n  this._flushSubscribe();\n};\n\n// Request the current document snapshot or ops that bring us up to date\nDoc.prototype.fetch = function(callback) {\n  if (this.connection.canSend) {\n    var isDuplicate = this.connection.sendFetch(this);\n    pushActionCallback(this.inflightFetch, isDuplicate, callback);\n    return;\n  }\n  this.pendingFetch.push(callback);\n};\n\n// Fetch the initial document and keep receiving updates\nDoc.prototype.subscribe = function(callback) {\n  var wantSubscribe = true;\n  this._queueSubscribe(wantSubscribe, callback);\n};\n\n// Unsubscribe. The data will stay around in local memory, but we'll stop\n// receiving updates\nDoc.prototype.unsubscribe = function(callback) {\n  var wantSubscribe = false;\n  this._queueSubscribe(wantSubscribe, callback);\n};\n\nDoc.prototype._queueSubscribe = function(wantSubscribe, callback) {\n  var lastRequest = this.pendingSubscribe[this.pendingSubscribe.length - 1] || this.inflightSubscribe;\n  var isDuplicateRequest = lastRequest && lastRequest.wantSubscribe === wantSubscribe;\n  if (isDuplicateRequest) {\n    lastRequest.callback = combineCallbacks([lastRequest.callback, callback]);\n    return;\n  }\n  this.pendingSubscribe.push({\n    wantSubscribe: !!wantSubscribe,\n    callback: callback\n  });\n  this._flushSubscribe();\n};\n\nDoc.prototype._flushSubscribe = function() {\n  if (this.inflightSubscribe || !this.pendingSubscribe.length) return;\n\n  if (this.connection.canSend) {\n    this.inflightSubscribe = this.pendingSubscribe.shift();\n    this.wantSubscribe = this.inflightSubscribe.wantSubscribe;\n    if (this.wantSubscribe) {\n      this.connection.sendSubscribe(this);\n    } else {\n      // Be conservative about our subscription state. We'll be unsubscribed\n      // some time between sending this request, and receiving the callback,\n      // so let's just set ourselves to unsubscribed now.\n      this.subscribed = false;\n      this.connection.sendUnsubscribe(this);\n    }\n\n    return;\n  }\n\n  // If we're offline, then we're already unsubscribed. Therefore, call back\n  // the next request immediately if it's an unsubscribe request.\n  if (!this.pendingSubscribe[0].wantSubscribe) {\n    this.inflightSubscribe = this.pendingSubscribe.shift();\n    var doc = this;\n    process.nextTick(function() {\n      doc._handleSubscribe();\n    });\n  }\n};\n\nfunction pushActionCallback(inflight, isDuplicate, callback) {\n  if (isDuplicate) {\n    var lastCallback = inflight.pop();\n    inflight.push(function(err) {\n      lastCallback && lastCallback(err);\n      callback && callback(err);\n    });\n  } else {\n    inflight.push(callback);\n  }\n}\n\nfunction combineCallbacks(callbacks) {\n  callbacks = callbacks.filter(util.truthy);\n  if (!callbacks.length) return null;\n  return function(error) {\n    util.callEach(callbacks, error);\n  };\n}\n\n\n// Operations //\n\n// Send the next pending op to the server, if we can.\n//\n// Only one operation can be in-flight at a time. If an operation is already on\n// its way, or we're not currently connected, this method does nothing.\nDoc.prototype.flush = function() {\n  // Ignore if we can't send or we are already sending an op\n  if (!this.connection.canSend || this.inflightOp) return;\n\n  // Send first pending op unless paused\n  if (!this.paused && this.pendingOps.length) {\n    this._sendOp();\n  }\n};\n\n// Helper function to set op to contain a no-op.\nfunction setNoOp(op) {\n  delete op.op;\n  delete op.create;\n  delete op.del;\n}\n\n// Transform server op data by a client op, and vice versa. Ops are edited in place.\nfunction transformX(client, server) {\n  // Order of statements in this function matters. Be especially careful if\n  // refactoring this function\n\n  // A client delete op should dominate if both the server and the client\n  // delete the document. Thus, any ops following the client delete (such as a\n  // subsequent create) will be maintained, since the server op is transformed\n  // to a no-op\n  if (client.del) return setNoOp(server);\n\n  if (server.del) {\n    return new ShareDBError(ERROR_CODE.ERR_DOC_WAS_DELETED, 'Document was deleted');\n  }\n  if (server.create) {\n    return new ShareDBError(ERROR_CODE.ERR_DOC_ALREADY_CREATED, 'Document already created');\n  }\n\n  // Ignore no-op coming from server\n  if (!('op' in server)) return;\n\n  // I believe that this should not occur, but check just in case\n  if (client.create) {\n    return new ShareDBError(ERROR_CODE.ERR_DOC_ALREADY_CREATED, 'Document already created');\n  }\n\n  // They both edited the document. This is the normal case for this function -\n  // as in, most of the time we'll end up down here.\n  //\n  // You should be wondering why I'm using client.type instead of this.type.\n  // The reason is, if we get ops at an old version of the document, this.type\n  // might be undefined or a totally different type. By pinning the type to the\n  // op data, we make sure the right type has its transform function called.\n  if (client.type.transformX) {\n    var result = client.type.transformX(client.op, server.op);\n    client.op = result[0];\n    server.op = result[1];\n  } else {\n    var clientOp = client.type.transform(client.op, server.op, 'left');\n    var serverOp = client.type.transform(server.op, client.op, 'right');\n    client.op = clientOp;\n    server.op = serverOp;\n  }\n};\n\n/**\n * Applies the operation to the snapshot\n *\n * If the operation is create or delete it emits `create` or `del`. Then the\n * operation is applied to the snapshot and `op` and `after op` are emitted.\n * If the type supports incremental updates and `this.incremental` is true we\n * fire `op` after every small operation.\n *\n * This is the only function to fire the above mentioned events.\n *\n * @private\n */\nDoc.prototype._otApply = function(op, source) {\n  if ('op' in op) {\n    if (!this.type) {\n      // Throw here, because all usage of _otApply should be wrapped with a try/catch\n      throw new ShareDBError(\n        ERROR_CODE.ERR_DOC_DOES_NOT_EXIST,\n        'Cannot apply op to uncreated document. ' + this.collection + '.' + this.id\n      );\n    }\n\n    // Iteratively apply multi-component remote operations and rollback ops\n    // (source === false) for the default JSON0 OT type. It could use\n    // type.shatter(), but since this code is so specific to use cases for the\n    // JSON0 type and ShareDB explicitly bundles the default type, we might as\n    // well write it this way and save needing to iterate through the op\n    // components twice.\n    //\n    // Ideally, we would not need this extra complexity. However, it is\n    // helpful for implementing bindings that update DOM nodes and other\n    // stateful objects by translating op events directly into corresponding\n    // mutations. Such bindings are most easily written as responding to\n    // individual op components one at a time in order, and it is important\n    // that the snapshot only include updates from the particular op component\n    // at the time of emission. Eliminating this would require rethinking how\n    // such external bindings are implemented.\n    if (!source && this.type === types.defaultType && op.op.length > 1) {\n      if (!this.applyStack) this.applyStack = [];\n      var stackLength = this.applyStack.length;\n      for (var i = 0; i < op.op.length; i++) {\n        var component = op.op[i];\n        var componentOp = {op: [component]};\n        // Transform componentOp against any ops that have been submitted\n        // sychronously inside of an op event handler since we began apply of\n        // our operation\n        for (var j = stackLength; j < this.applyStack.length; j++) {\n          var transformErr = transformX(this.applyStack[j], componentOp);\n          if (transformErr) return this._hardRollback(transformErr);\n        }\n        // Apply the individual op component\n        this.emit('before op', componentOp.op, source, op.src);\n        this.data = this.type.apply(this.data, componentOp.op);\n        this.emit('op', componentOp.op, source, op.src);\n      }\n      // Pop whatever was submitted since we started applying this op\n      this._popApplyStack(stackLength);\n      return;\n    }\n\n    // The 'before op' event enables clients to pull any necessary data out of\n    // the snapshot before it gets changed\n    this.emit('before op', op.op, source, op.src);\n    // Apply the operation to the local data, mutating it in place\n    this.data = this.type.apply(this.data, op.op);\n    // Emit an 'op' event once the local data includes the changes from the\n    // op. For locally submitted ops, this will be synchronously with\n    // submission and before the server or other clients have received the op.\n    // For ops from other clients, this will be after the op has been\n    // committed to the database and published\n    this.emit('op', op.op, source, op.src);\n    return;\n  }\n\n  if (op.create) {\n    this._setType(op.create.type);\n    this.data = (this.type.deserialize) ?\n      (this.type.createDeserialized) ?\n        this.type.createDeserialized(op.create.data) :\n        this.type.deserialize(this.type.create(op.create.data)) :\n      this.type.create(op.create.data);\n    this.emit('create', source);\n    return;\n  }\n\n  if (op.del) {\n    var oldData = this.data;\n    this._setType(null);\n    this.emit('del', oldData, source);\n    return;\n  }\n};\n\n\n// ***** Sending operations\n\n// Actually send op to the server.\nDoc.prototype._sendOp = function() {\n  if (!this.connection.canSend) return;\n  var src = this.connection.id;\n\n  // When there is no inflightOp, send the first item in pendingOps. If\n  // there is inflightOp, try sending it again\n  if (!this.inflightOp) {\n    // Send first pending op\n    this.inflightOp = this.pendingOps.shift();\n  }\n  var op = this.inflightOp;\n  if (!op) {\n    var err = new ShareDBError(ERROR_CODE.ERR_INFLIGHT_OP_MISSING, 'No op to send on call to _sendOp');\n    return this.emit('error', err);\n  }\n\n  // Track data for retrying ops\n  op.sentAt = Date.now();\n  op.retries = (op.retries == null) ? 0 : op.retries + 1;\n\n  // The src + seq number is a unique ID representing this operation. This tuple\n  // is used on the server to detect when ops have been sent multiple times and\n  // on the client to match acknowledgement of an op back to the inflightOp.\n  // Note that the src could be different from this.connection.id after a\n  // reconnect, since an op may still be pending after the reconnection and\n  // this.connection.id will change. In case an op is sent multiple times, we\n  // also need to be careful not to override the original seq value.\n  if (op.seq == null) {\n    if (this.connection.seq >= util.MAX_SAFE_INTEGER) {\n      return this.emit('error', new ShareDBError(\n        ERROR_CODE.ERR_CONNECTION_SEQ_INTEGER_OVERFLOW,\n        'Connection seq has exceeded the max safe integer, maybe from being open for too long'\n      ));\n    }\n\n    op.seq = this.connection.seq++;\n  }\n\n  this.connection.sendOp(this, op);\n\n  // src isn't needed on the first try, since the server session will have the\n  // same id, but it must be set on the inflightOp in case it is sent again\n  // after a reconnect and the connection's id has changed by then\n  if (op.src == null) op.src = src;\n};\n\n\n// Queues the operation for submission to the server and applies it locally.\n//\n// Internal method called to do the actual work for submit(), create() and del().\n// @private\n//\n// @param op\n// @param [op.op]\n// @param [op.del]\n// @param [op.create]\n// @param [callback] called when operation is submitted\nDoc.prototype._submit = function(op, source, callback) {\n  // Locally submitted ops must always have a truthy source\n  if (!source) source = true;\n\n  // The op contains either op, create, delete, or none of the above (a no-op).\n  if ('op' in op) {\n    if (!this.type) {\n      var err = new ShareDBError(\n        ERROR_CODE.ERR_DOC_DOES_NOT_EXIST,\n        'Cannot submit op. Document has not been created. ' + this.collection + '.' + this.id\n      );\n      if (callback) return callback(err);\n      return this.emit('error', err);\n    }\n    // Try to normalize the op. This removes trailing skip:0's and things like that.\n    if (this.type.normalize) op.op = this.type.normalize(op.op);\n  }\n\n  try {\n    this._pushOp(op, callback);\n    this._otApply(op, source);\n  } catch (error) {\n    return this._hardRollback(error);\n  }\n\n  // The call to flush is delayed so if submit() is called multiple times\n  // synchronously, all the ops are combined before being sent to the server.\n  var doc = this;\n  process.nextTick(function() {\n    doc.flush();\n  });\n};\n\nDoc.prototype._pushOp = function(op, callback) {\n  if (this.applyStack) {\n    // If we are in the process of incrementally applying an operation, don't\n    // compose the op and push it onto the applyStack so it can be transformed\n    // against other components from the op or ops being applied\n    this.applyStack.push(op);\n  } else {\n    // If the type supports composes, try to compose the operation onto the\n    // end of the last pending operation.\n    var composed = this._tryCompose(op);\n    if (composed) {\n      composed.callbacks.push(callback);\n      return;\n    }\n  }\n  // Push on to the pendingOps queue of ops to submit if we didn't compose\n  op.type = this.type;\n  op.callbacks = [callback];\n  this.pendingOps.push(op);\n};\n\nDoc.prototype._popApplyStack = function(to) {\n  if (to > 0) {\n    this.applyStack.length = to;\n    return;\n  }\n  // Once we have completed the outermost apply loop, reset to null and no\n  // longer add ops to the applyStack as they are submitted\n  var op = this.applyStack[0];\n  this.applyStack = null;\n  if (!op) return;\n  // Compose the ops added since the beginning of the apply stack, since we\n  // had to skip compose when they were originally pushed\n  var i = this.pendingOps.indexOf(op);\n  if (i === -1) return;\n  var ops = this.pendingOps.splice(i);\n  for (var i = 0; i < ops.length; i++) {\n    var op = ops[i];\n    var composed = this._tryCompose(op);\n    if (composed) {\n      composed.callbacks = composed.callbacks.concat(op.callbacks);\n    } else {\n      this.pendingOps.push(op);\n    }\n  }\n};\n\n// Try to compose a submitted op into the last pending op. Returns the\n// composed op if it succeeds, undefined otherwise\nDoc.prototype._tryCompose = function(op) {\n  if (this.preventCompose) return;\n\n  // We can only compose into the last pending op. Inflight ops have already\n  // been sent to the server, so we can't modify them\n  var last = this.pendingOps[this.pendingOps.length - 1];\n  if (!last || last.sentAt) return;\n\n  // Compose an op into a create by applying it. This effectively makes the op\n  // invisible, as if the document were created including the op originally\n  if (last.create && 'op' in op) {\n    last.create.data = this.type.apply(last.create.data, op.op);\n    return last;\n  }\n\n  // Compose two ops into a single op if supported by the type. Types that\n  // support compose must be able to compose any two ops together\n  if ('op' in last && 'op' in op && this.type.compose) {\n    last.op = this.type.compose(last.op, op.op);\n    return last;\n  }\n};\n\n// *** Client OT entrypoints.\n\n// Submit an operation to the document.\n//\n// @param operation handled by the OT type\n// @param options  {source: ...}\n// @param [callback] called after operation submitted\n//\n// @fires before op, op, after op\nDoc.prototype.submitOp = function(component, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  var op = {op: component};\n  var source = options && options.source;\n  this._submit(op, source, callback);\n};\n\n// Create the document, which in ShareJS semantics means to set its type. Every\n// object implicitly exists in the database but has no data and no type. Create\n// sets the type of the object and can optionally set some initial data on the\n// object, depending on the type.\n//\n// @param data  initial\n// @param type  OT type\n// @param options  {source: ...}\n// @param callback  called when operation submitted\nDoc.prototype.create = function(data, type, options, callback) {\n  if (typeof type === 'function') {\n    callback = type;\n    options = null;\n    type = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  if (!type) {\n    type = types.defaultType.uri;\n  }\n  if (this.type) {\n    var err = new ShareDBError(ERROR_CODE.ERR_DOC_ALREADY_CREATED, 'Document already exists');\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n  var op = {create: {type: type, data: data}};\n  var source = options && options.source;\n  this._submit(op, source, callback);\n};\n\n// Delete the document. This creates and submits a delete operation to the\n// server. Deleting resets the object's type to null and deletes its data. The\n// document still exists, and still has the version it used to have before you\n// deleted it (well, old version +1).\n//\n// @param options  {source: ...}\n// @param callback  called when operation submitted\nDoc.prototype.del = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  if (!this.type) {\n    var err = new ShareDBError(ERROR_CODE.ERR_DOC_DOES_NOT_EXIST, 'Document does not exist');\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n  var op = {del: true};\n  var source = options && options.source;\n  this._submit(op, source, callback);\n};\n\n\n// Stops the document from sending any operations to the server.\nDoc.prototype.pause = function() {\n  this.paused = true;\n};\n\n// Continue sending operations to the server\nDoc.prototype.resume = function() {\n  this.paused = false;\n  this.flush();\n};\n\n// *** Receiving operations\n\n// This is called when the server acknowledges an operation from the client.\nDoc.prototype._opAcknowledged = function(message) {\n  if (this.inflightOp.create) {\n    this.version = message.v;\n  } else if (message.v !== this.version) {\n    // We should already be at the same version, because the server should\n    // have sent all the ops that have happened before acknowledging our op\n    logger.warn('Invalid version from server. Expected: ' + this.version + ' Received: ' + message.v, message);\n\n    // Fetching should get us back to a working document state\n    return this.fetch();\n  }\n\n  // The op was committed successfully. Increment the version number\n  this.version++;\n\n  this._clearInflightOp();\n};\n\nDoc.prototype._rollback = function(err) {\n  // The server has rejected submission of the current operation. Invert by\n  // just the inflight op if possible. If not possible to invert, cancel all\n  // pending ops and fetch the latest from the server to get us back into a\n  // working state, then call back\n  var op = this.inflightOp;\n\n  if ('op' in op && op.type.invert) {\n    op.op = op.type.invert(op.op);\n\n    // Transform the undo operation by any pending ops.\n    for (var i = 0; i < this.pendingOps.length; i++) {\n      var transformErr = transformX(this.pendingOps[i], op);\n      if (transformErr) return this._hardRollback(transformErr);\n    }\n\n    // ... and apply it locally, reverting the changes.\n    //\n    // This operation is applied to look like it comes from a remote source.\n    // I'm still not 100% sure about this functionality, because its really a\n    // local op. Basically, the problem is that if the client's op is rejected\n    // by the server, the editor window should update to reflect the undo.\n    try {\n      this._otApply(op, false);\n    } catch (error) {\n      return this._hardRollback(error);\n    }\n\n    this._clearInflightOp(err);\n    return;\n  }\n\n  this._hardRollback(err);\n};\n\nDoc.prototype._hardRollback = function(err) {\n  // Store pending ops so that we can notify their callbacks of the error.\n  // We combine the inflight op and the pending ops, because it's possible\n  // to hit a condition where we have no inflight op, but we do have pending\n  // ops. This can happen when an invalid op is submitted, which causes us\n  // to hard rollback before the pending op was flushed.\n  var pendingOps = [];\n  if (this.inflightOp) pendingOps.push(this.inflightOp);\n  pendingOps = pendingOps.concat(this.pendingOps);\n\n  // Cancel all pending ops and reset if we can't invert\n  this._setType(null);\n  this.version = null;\n  this.inflightOp = null;\n  this.pendingOps = [];\n\n  // Fetch the latest version from the server to get us back into a working state\n  var doc = this;\n  this.fetch(function() {\n    // We want to check that no errors are swallowed, so we check that:\n    // - there are callbacks to call, and\n    // - that every single pending op called a callback\n    // If there are no ops queued, or one of them didn't handle the error,\n    // then we emit the error.\n    var allOpsHadCallbacks = !!pendingOps.length;\n    for (var i = 0; i < pendingOps.length; i++) {\n      allOpsHadCallbacks = util.callEach(pendingOps[i].callbacks, err) && allOpsHadCallbacks;\n    }\n    if (err && !allOpsHadCallbacks) return doc.emit('error', err);\n  });\n};\n\nDoc.prototype._clearInflightOp = function(err) {\n  var inflightOp = this.inflightOp;\n\n  this.inflightOp = null;\n\n  var called = util.callEach(inflightOp.callbacks, err);\n\n  this.flush();\n  this._emitNothingPending();\n\n  if (err && !called) return this.emit('error', err);\n};\n",
    "exports.Connection = require('./connection');\nexports.Doc = require('./doc');\nexports.Error = require('../error');\nexports.Query = require('./query');\nexports.types = require('../types');\nexports.logger = require('../logger');\n",
    "var Presence = require('./presence');\nvar LocalDocPresence = require('./local-doc-presence');\nvar RemoteDocPresence = require('./remote-doc-presence');\n\nfunction DocPresence(connection, collection, id) {\n  var channel = DocPresence.channel(collection, id);\n  Presence.call(this, connection, channel);\n\n  this.collection = collection;\n  this.id = id;\n}\nmodule.exports = DocPresence;\n\nDocPresence.prototype = Object.create(Presence.prototype);\n\nDocPresence.channel = function(collection, id) {\n  return collection + '.' + id;\n};\n\nDocPresence.prototype._createLocalPresence = function(id) {\n  return new LocalDocPresence(this, id);\n};\n\nDocPresence.prototype._createRemotePresence = function(id) {\n  return new RemoteDocPresence(this, id);\n};\n",
    "var LocalPresence = require('./local-presence');\nvar ShareDBError = require('../../error');\nvar ERROR_CODE = ShareDBError.CODES;\n\nmodule.exports = LocalDocPresence;\nfunction LocalDocPresence(presence, presenceId) {\n  LocalPresence.call(this, presence, presenceId);\n\n  this.collection = this.presence.collection;\n  this.id = this.presence.id;\n\n  this._doc = this.connection.get(this.collection, this.id);\n  this._isSending = false;\n\n  this._opHandler = this._transformAgainstOp.bind(this);\n  this._createOrDelHandler = this._handleCreateOrDel.bind(this);\n  this._loadHandler = this._handleLoad.bind(this);\n  this._destroyHandler = this.destroy.bind(this);\n  this._registerWithDoc();\n}\n\nLocalDocPresence.prototype = Object.create(LocalPresence.prototype);\n\nLocalDocPresence.prototype.submit = function(value, callback) {\n  if (!this._doc.type) {\n    // If the Doc hasn't been created, we already assume all presence to\n    // be null. Let's early return, instead of error since this is a harmless\n    // no-op\n    if (value === null) return this._callbackOrEmit(null, callback);\n    var error = {\n      code: ERROR_CODE.ERR_DOC_DOES_NOT_EXIST,\n      message: 'Cannot submit presence. Document has not been created'\n    };\n    return this._callbackOrEmit(error, callback);\n  };\n\n  LocalPresence.prototype.submit.call(this, value, callback);\n};\n\nLocalDocPresence.prototype.destroy = function(callback) {\n  this._doc.removeListener('op', this._opHandler);\n  this._doc.removeListener('create', this._createOrDelHandler);\n  this._doc.removeListener('del', this._createOrDelHandler);\n  this._doc.removeListener('load', this._loadHandler);\n  this._doc.removeListener('destroy', this._destroyHandler);\n\n  LocalPresence.prototype.destroy.call(this, callback);\n};\n\nLocalDocPresence.prototype._sendPending = function() {\n  if (this._isSending) return;\n  this._isSending = true;\n  var presence = this;\n  this._doc.whenNothingPending(function() {\n    presence._isSending = false;\n    if (!presence.connection.canSend) return;\n\n    presence._pendingMessages.forEach(function(message) {\n      message.t = presence._doc.type.uri;\n      message.v = presence._doc.version;\n      presence.connection.send(message);\n    });\n\n    presence._pendingMessages = [];\n  });\n};\n\nLocalDocPresence.prototype._registerWithDoc = function() {\n  this._doc.on('op', this._opHandler);\n  this._doc.on('create', this._createOrDelHandler);\n  this._doc.on('del', this._createOrDelHandler);\n  this._doc.on('load', this._loadHandler);\n  this._doc.on('destroy', this._destroyHandler);\n};\n\nLocalDocPresence.prototype._transformAgainstOp = function(op, source) {\n  var presence = this;\n  this._pendingMessages.forEach(function(message) {\n    try {\n      message.p = presence._doc.type.transformPresence(message.p, op, source);\n    } catch (error) {\n      var callback = presence._getCallback(message.pv);\n      presence._callbackOrEmit(error, callback);\n    }\n  });\n\n  try {\n    this.value = this._doc.type.transformPresence(this.value, op, source);\n  } catch (error) {\n    this.emit('error', error);\n  }\n};\n\nLocalDocPresence.prototype._handleCreateOrDel = function() {\n  this._pendingMessages.forEach(function(message) {\n    message.p = null;\n  });\n\n  this.value = null;\n};\n\nLocalDocPresence.prototype._handleLoad = function() {\n  this.value = null;\n  this._pendingMessages = [];\n};\n\nLocalDocPresence.prototype._message = function() {\n  var message = LocalPresence.prototype._message.call(this);\n  message.c = this.collection,\n  message.d = this.id,\n  message.v = null;\n  message.t = null;\n  return message;\n};\n",
    "var emitter = require('../../emitter');\n\nmodule.exports = LocalPresence;\nfunction LocalPresence(presence, presenceId) {\n  emitter.EventEmitter.call(this);\n\n  if (!presenceId || typeof presenceId !== 'string') {\n    throw new Error('LocalPresence presenceId must be a string');\n  }\n\n  this.presence = presence;\n  this.presenceId = presenceId;\n  this.connection = presence.connection;\n  this.presenceVersion = 0;\n\n  this.value = null;\n\n  this._pendingMessages = [];\n  this._callbacksByPresenceVersion = {};\n}\nemitter.mixin(LocalPresence);\n\nLocalPresence.prototype.submit = function(value, callback) {\n  this.value = value;\n  this.send(callback);\n};\n\nLocalPresence.prototype.send = function(callback) {\n  var message = this._message();\n  this._pendingMessages.push(message);\n  this._callbacksByPresenceVersion[message.pv] = callback;\n  this._sendPending();\n};\n\nLocalPresence.prototype.destroy = function(callback) {\n  var presence = this;\n  this.submit(null, function(error) {\n    if (error) return presence._callbackOrEmit(error, callback);\n    delete presence.presence.localPresences[presence.presenceId];\n    if (callback) callback();\n  });\n};\n\nLocalPresence.prototype._sendPending = function() {\n  if (!this.connection.canSend) return;\n  var presence = this;\n  this._pendingMessages.forEach(function(message) {\n    presence.connection.send(message);\n  });\n\n  this._pendingMessages = [];\n};\n\nLocalPresence.prototype._ack = function(error, presenceVersion) {\n  var callback = this._getCallback(presenceVersion);\n  this._callbackOrEmit(error, callback);\n};\n\nLocalPresence.prototype._message = function() {\n  return {\n    a: 'p',\n    ch: this.presence.channel,\n    id: this.presenceId,\n    p: this.value,\n    pv: this.presenceVersion++\n  };\n};\n\nLocalPresence.prototype._getCallback = function(presenceVersion) {\n  var callback = this._callbacksByPresenceVersion[presenceVersion];\n  delete this._callbacksByPresenceVersion[presenceVersion];\n  return callback;\n};\n\nLocalPresence.prototype._callbackOrEmit = function(error, callback) {\n  if (callback) return process.nextTick(callback, error);\n  if (error) this.emit('error', error);\n};\n",
    "var emitter = require('../../emitter');\nvar LocalPresence = require('./local-presence');\nvar RemotePresence = require('./remote-presence');\nvar util = require('../../util');\nvar async = require('async');\nvar hat = require('hat');\n\nmodule.exports = Presence;\nfunction Presence(connection, channel) {\n  emitter.EventEmitter.call(this);\n\n  if (!channel || typeof channel !== 'string') {\n    throw new Error('Presence channel must be provided');\n  }\n\n  this.connection = connection;\n  this.channel = channel;\n\n  this.wantSubscribe = false;\n  this.subscribed = false;\n  this.remotePresences = {};\n  this.localPresences = {};\n\n  this._remotePresenceInstances = {};\n  this._subscriptionCallbacksBySeq = {};\n}\nemitter.mixin(Presence);\n\nPresence.prototype.subscribe = function(callback) {\n  this._sendSubscriptionAction(true, callback);\n};\n\nPresence.prototype.unsubscribe = function(callback) {\n  this._sendSubscriptionAction(false, callback);\n};\n\nPresence.prototype.create = function(id) {\n  id = id || hat();\n  var localPresence = this._createLocalPresence(id);\n  this.localPresences[id] = localPresence;\n  return localPresence;\n};\n\nPresence.prototype.destroy = function(callback) {\n  var presence = this;\n  this.unsubscribe(function(error) {\n    if (error) return presence._callbackOrEmit(error, callback);\n    var localIds = Object.keys(presence.localPresences);\n    var remoteIds = Object.keys(presence._remotePresenceInstances);\n    async.parallel(\n      [\n        function(next) {\n          async.each(localIds, function(presenceId, next) {\n            presence.localPresences[presenceId].destroy(next);\n          }, next);\n        },\n        function(next) {\n          async.each(remoteIds, function(presenceId, next) {\n            presence._remotePresenceInstances[presenceId].destroy(next);\n          }, next);\n        }\n      ],\n      function(error) {\n        delete presence.connection._presences[presence.channel];\n        presence._callbackOrEmit(error, callback);\n      }\n    );\n  });\n};\n\nPresence.prototype._sendSubscriptionAction = function(wantSubscribe, callback) {\n  this.wantSubscribe = !!wantSubscribe;\n  var action = this.wantSubscribe ? 'ps' : 'pu';\n  var seq = this.connection._presenceSeq++;\n  this._subscriptionCallbacksBySeq[seq] = callback;\n  if (this.connection.canSend) {\n    this.connection._sendPresenceAction(action, seq, this);\n  }\n};\n\nPresence.prototype._handleSubscribe = function(error, seq) {\n  if (this.wantSubscribe) this.subscribed = true;\n  var callback = this._subscriptionCallback(seq);\n  this._callbackOrEmit(error, callback);\n};\n\nPresence.prototype._handleUnsubscribe = function(error, seq) {\n  this.subscribed = false;\n  var callback = this._subscriptionCallback(seq);\n  this._callbackOrEmit(error, callback);\n};\n\nPresence.prototype._receiveUpdate = function(error, message) {\n  var localPresence = util.dig(this.localPresences, message.id);\n  if (localPresence) return localPresence._ack(error, message.pv);\n\n  if (error) return this.emit('error', error);\n  var presence = this;\n  var remotePresence = util.digOrCreate(this._remotePresenceInstances, message.id, function() {\n    return presence._createRemotePresence(message.id);\n  });\n\n  remotePresence.receiveUpdate(message);\n};\n\nPresence.prototype._updateRemotePresence = function(remotePresence) {\n  this.remotePresences[remotePresence.presenceId] = remotePresence.value;\n  if (remotePresence.value === null) this._removeRemotePresence(remotePresence.presenceId);\n  this.emit('receive', remotePresence.presenceId, remotePresence.value);\n};\n\nPresence.prototype._broadcastAllLocalPresence = function(error) {\n  if (error) return this.emit('error', error);\n  for (var id in this.localPresences) {\n    var localPresence = this.localPresences[id];\n    if (localPresence.value !== null) localPresence.send();\n  }\n};\n\nPresence.prototype._removeRemotePresence = function(id) {\n  this._remotePresenceInstances[id].destroy();\n  delete this._remotePresenceInstances[id];\n  delete this.remotePresences[id];\n};\n\nPresence.prototype._onConnectionStateChanged = function() {\n  if (!this.connection.canSend) return;\n  this._resubscribe();\n  for (var id in this.localPresences) {\n    this.localPresences[id]._sendPending();\n  }\n};\n\nPresence.prototype._resubscribe = function() {\n  var callbacks = [];\n  for (var seq in this._subscriptionCallbacksBySeq) {\n    var callback = this._subscriptionCallback(seq);\n    callbacks.push(callback);\n  }\n\n  if (!this.wantSubscribe) return this._callEachOrEmit(callbacks);\n\n  var presence = this;\n  this.subscribe(function(error) {\n    presence._callEachOrEmit(callbacks, error);\n  });\n};\n\nPresence.prototype._subscriptionCallback = function(seq) {\n  var callback = this._subscriptionCallbacksBySeq[seq];\n  delete this._subscriptionCallbacksBySeq[seq];\n  return callback;\n};\n\nPresence.prototype._callbackOrEmit = function(error, callback) {\n  if (callback) return process.nextTick(callback, error);\n  if (error) this.emit('error', error);\n};\n\nPresence.prototype._createLocalPresence = function(id) {\n  return new LocalPresence(this, id);\n};\n\nPresence.prototype._createRemotePresence = function(id) {\n  return new RemotePresence(this, id);\n};\n\nPresence.prototype._callEachOrEmit = function(callbacks, error) {\n  var called = util.callEach(callbacks, error);\n  if (!called && error) this.emit('error', error);\n};\n",
    "var RemotePresence = require('./remote-presence');\nvar ot = require('../../ot');\n\nmodule.exports = RemoteDocPresence;\nfunction RemoteDocPresence(presence, presenceId) {\n  RemotePresence.call(this, presence, presenceId);\n\n  this.collection = this.presence.collection;\n  this.id = this.presence.id;\n  this.src = null;\n  this.presenceVersion = null;\n\n  this._doc = this.connection.get(this.collection, this.id);\n  this._pending = null;\n  this._opCache = null;\n  this._pendingSetPending = false;\n\n  this._opHandler = this._handleOp.bind(this);\n  this._createDelHandler = this._handleCreateDel.bind(this);\n  this._loadHandler = this._handleLoad.bind(this);\n  this._registerWithDoc();\n}\n\nRemoteDocPresence.prototype = Object.create(RemotePresence.prototype);\n\nRemoteDocPresence.prototype.receiveUpdate = function(message) {\n  if (this._pending && message.pv < this._pending.pv) return;\n  this.src = message.src;\n  this._pending = message;\n  this._setPendingPresence();\n};\n\nRemoteDocPresence.prototype.destroy = function(callback) {\n  this._doc.removeListener('op', this._opHandler);\n  this._doc.removeListener('create', this._createDelHandler);\n  this._doc.removeListener('del', this._createDelHandler);\n  this._doc.removeListener('load', this._loadHandler);\n\n  RemotePresence.prototype.destroy.call(this, callback);\n};\n\nRemoteDocPresence.prototype._registerWithDoc = function() {\n  this._doc.on('op', this._opHandler);\n  this._doc.on('create', this._createDelHandler);\n  this._doc.on('del', this._createDelHandler);\n  this._doc.on('load', this._loadHandler);\n};\n\nRemoteDocPresence.prototype._setPendingPresence = function() {\n  if (this._pendingSetPending) return;\n  this._pendingSetPending = true;\n  var presence = this;\n  this._doc.whenNothingPending(function() {\n    presence._pendingSetPending = false;\n    if (!presence._pending) return;\n    if (presence._pending.pv < presence.presenceVersion) return presence._pending = null;\n\n    if (presence._pending.v > presence._doc.version) {\n      return presence._doc.fetch();\n    }\n\n    if (!presence._catchUpStalePresence()) return;\n\n    presence.value = presence._pending.p;\n    presence.presenceVersion = presence._pending.pv;\n    presence._pending = null;\n    presence.presence._updateRemotePresence(presence);\n  });\n};\n\nRemoteDocPresence.prototype._handleOp = function(op, source, connectionId) {\n  var isOwnOp = connectionId === this.src;\n  this._transformAgainstOp(op, isOwnOp);\n  this._cacheOp(op, isOwnOp);\n  this._setPendingPresence();\n};\n\nRemotePresence.prototype._handleCreateDel = function() {\n  this._cacheOp(null);\n  this._setPendingPresence();\n};\n\nRemotePresence.prototype._handleLoad = function() {\n  this.value = null;\n  this._pending = null;\n  this._opCache = null;\n  this.presence._updateRemotePresence(this);\n};\n\nRemoteDocPresence.prototype._transformAgainstOp = function(op, isOwnOp) {\n  if (!this.value) return;\n\n  try {\n    this.value = this._doc.type.transformPresence(this.value, op, isOwnOp);\n  } catch (error) {\n    return this.presence.emit('error', error);\n  }\n  this.presence._updateRemotePresence(this);\n};\n\nRemoteDocPresence.prototype._catchUpStalePresence = function() {\n  if (this._pending.v >= this._doc.version) return true;\n\n  if (!this._opCache) {\n    this._startCachingOps();\n    this._doc.fetch();\n    // We're already subscribed, but we send another subscribe message\n    // to force presence updates from other clients\n    this.presence.subscribe();\n    return false;\n  }\n\n  while (this._opCache[this._pending.v]) {\n    var item = this._opCache[this._pending.v];\n    var op = item.op;\n    var isOwnOp = item.isOwnOp;\n    // We use a null op to signify a create or a delete operation. In both\n    // cases we just want to reset the presence (which doesn't make sense\n    // in a new document), so just set the presence to null.\n    if (op === null) {\n      this._pending.p = null;\n      this._pending.v++;\n    } else {\n      ot.transformPresence(this._pending, op, isOwnOp);\n    }\n  }\n\n  var hasCaughtUp = this._pending.v >= this._doc.version;\n  if (hasCaughtUp) {\n    this._stopCachingOps();\n  }\n\n  return hasCaughtUp;\n};\n\nRemoteDocPresence.prototype._startCachingOps = function() {\n  this._opCache = [];\n};\n\nRemoteDocPresence.prototype._stopCachingOps = function() {\n  this._opCache = null;\n};\n\nRemoteDocPresence.prototype._cacheOp = function(op, isOwnOp) {\n  if (this._opCache) {\n    op = op ? {op: op} : null;\n    // Subtract 1 from the current doc version, because an op with v3\n    // should be read as the op that takes a doc from v3 -> v4\n    this._opCache[this._doc.version - 1] = {op: op, isOwnOp: isOwnOp};\n  }\n};\n",
    "module.exports = RemotePresence;\nfunction RemotePresence(presence, presenceId) {\n  this.presence = presence;\n  this.presenceId = presenceId;\n  this.connection = this.presence.connection;\n\n  this.value = null;\n  this.presenceVersion = 0;\n}\n\nRemotePresence.prototype.receiveUpdate = function(message) {\n  if (message.pv < this.presenceVersion) return;\n  this.value = message.p;\n  this.presenceVersion = message.pv;\n  this.presence._updateRemotePresence(this);\n};\n\nRemotePresence.prototype.destroy = function(callback) {\n  delete this.presence._remotePresenceInstances[this.presenceId];\n  delete this.presence.remotePresences[this.presenceId];\n  if (callback) process.nextTick(callback);\n};\n",
    "var emitter = require('../emitter');\n\n// Queries are live requests to the database for particular sets of fields.\n//\n// The server actively tells the client when there's new data that matches\n// a set of conditions.\nmodule.exports = Query;\nfunction Query(action, connection, id, collection, query, options, callback) {\n  emitter.EventEmitter.call(this);\n\n  // 'qf' or 'qs'\n  this.action = action;\n\n  this.connection = connection;\n  this.id = id;\n  this.collection = collection;\n\n  // The query itself. For mongo, this should look something like {\"data.x\":5}\n  this.query = query;\n\n  // A list of resulting documents. These are actual documents, complete with\n  // data and all the rest. It is possible to pass in an initial results set,\n  // so that a query can be serialized and then re-established\n  this.results = null;\n  if (options && options.results) {\n    this.results = options.results;\n    delete options.results;\n  }\n  this.extra = undefined;\n\n  // Options to pass through with the query\n  this.options = options;\n\n  this.callback = callback;\n  this.ready = false;\n  this.sent = false;\n}\nemitter.mixin(Query);\n\nQuery.prototype.hasPending = function() {\n  return !this.ready;\n};\n\n// Helper for subscribe & fetch, since they share the same message format.\n//\n// This function actually issues the query.\nQuery.prototype.send = function() {\n  if (!this.connection.canSend) return;\n\n  var message = {\n    a: this.action,\n    id: this.id,\n    c: this.collection,\n    q: this.query\n  };\n  if (this.options) {\n    message.o = this.options;\n  }\n  if (this.results) {\n    // Collect the version of all the documents in the current result set so we\n    // don't need to be sent their snapshots again.\n    var results = [];\n    for (var i = 0; i < this.results.length; i++) {\n      var doc = this.results[i];\n      results.push([doc.id, doc.version]);\n    }\n    message.r = results;\n  }\n\n  this.connection.send(message);\n  this.sent = true;\n};\n\n// Destroy the query object. Any subsequent messages for the query will be\n// ignored by the connection.\nQuery.prototype.destroy = function(callback) {\n  if (this.connection.canSend && this.action === 'qs') {\n    this.connection.send({a: 'qu', id: this.id});\n  }\n  this.connection._destroyQuery(this);\n  // There is a callback for consistency, but we don't actually wait for the\n  // server's unsubscribe message currently\n  if (callback) process.nextTick(callback);\n};\n\nQuery.prototype._onConnectionStateChanged = function() {\n  if (this.connection.canSend && !this.sent) {\n    this.send();\n  } else {\n    this.sent = false;\n  }\n};\n\nQuery.prototype._handleFetch = function(err, data, extra) {\n  // Once a fetch query gets its data, it is destroyed.\n  this.connection._destroyQuery(this);\n  this._handleResponse(err, data, extra);\n};\n\nQuery.prototype._handleSubscribe = function(err, data, extra) {\n  this._handleResponse(err, data, extra);\n};\n\nQuery.prototype._handleResponse = function(err, data, extra) {\n  var callback = this.callback;\n  this.callback = null;\n  if (err) return this._finishResponse(err, callback);\n  if (!data) return this._finishResponse(null, callback);\n\n  var query = this;\n  var wait = 1;\n  var finish = function(err) {\n    if (err) return query._finishResponse(err, callback);\n    if (--wait) return;\n    query._finishResponse(null, callback);\n  };\n\n  if (Array.isArray(data)) {\n    wait += data.length;\n    this.results = this._ingestSnapshots(data, finish);\n    this.extra = extra;\n  } else {\n    for (var id in data) {\n      wait++;\n      var snapshot = data[id];\n      var doc = this.connection.get(snapshot.c || this.collection, id);\n      doc.ingestSnapshot(snapshot, finish);\n    }\n  }\n\n  finish();\n};\n\nQuery.prototype._ingestSnapshots = function(snapshots, finish) {\n  var results = [];\n  for (var i = 0; i < snapshots.length; i++) {\n    var snapshot = snapshots[i];\n    var doc = this.connection.get(snapshot.c || this.collection, snapshot.d);\n    doc.ingestSnapshot(snapshot, finish);\n    results.push(doc);\n  }\n  return results;\n};\n\nQuery.prototype._finishResponse = function(err, callback) {\n  this.emit('ready');\n  this.ready = true;\n  if (err) {\n    this.connection._destroyQuery(this);\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n  if (callback) callback(null, this.results, this.extra);\n};\n\nQuery.prototype._handleError = function(err) {\n  this.emit('error', err);\n};\n\nQuery.prototype._handleDiff = function(diff) {\n  // We need to go through the list twice. First, we'll ingest all the new\n  // documents. After that we'll emit events and actually update our list.\n  // This avoids race conditions around setting documents to be subscribed &\n  // unsubscribing documents in event callbacks.\n  for (var i = 0; i < diff.length; i++) {\n    var d = diff[i];\n    if (d.type === 'insert') d.values = this._ingestSnapshots(d.values);\n  }\n\n  for (var i = 0; i < diff.length; i++) {\n    var d = diff[i];\n    switch (d.type) {\n      case 'insert':\n        var newDocs = d.values;\n        Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));\n        this.emit('insert', newDocs, d.index);\n        break;\n      case 'remove':\n        var howMany = d.howMany || 1;\n        var removed = this.results.splice(d.index, howMany);\n        this.emit('remove', removed, d.index);\n        break;\n      case 'move':\n        var howMany = d.howMany || 1;\n        var docs = this.results.splice(d.from, howMany);\n        Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));\n        this.emit('move', docs, d.from, d.to);\n        break;\n    }\n  }\n\n  this.emit('changed', this.results);\n};\n\nQuery.prototype._handleExtra = function(extra) {\n  this.extra = extra;\n  this.emit('extra', extra);\n};\n",
    "var Snapshot = require('../../snapshot');\nvar emitter = require('../../emitter');\n\nmodule.exports = SnapshotRequest;\n\nfunction SnapshotRequest(connection, requestId, collection, id, callback) {\n  emitter.EventEmitter.call(this);\n\n  if (typeof callback !== 'function') {\n    throw new Error('Callback is required for SnapshotRequest');\n  }\n\n  this.requestId = requestId;\n  this.connection = connection;\n  this.id = id;\n  this.collection = collection;\n  this.callback = callback;\n\n  this.sent = false;\n}\nemitter.mixin(SnapshotRequest);\n\nSnapshotRequest.prototype.send = function() {\n  if (!this.connection.canSend) {\n    return;\n  }\n\n  this.connection.send(this._message());\n  this.sent = true;\n};\n\nSnapshotRequest.prototype._onConnectionStateChanged = function() {\n  if (this.connection.canSend) {\n    if (!this.sent) this.send();\n  } else {\n    // If the connection can't send, then we've had a disconnection, and even if we've already sent\n    // the request previously, we need to re-send it over this reconnected client, so reset the\n    // sent flag to false.\n    this.sent = false;\n  }\n};\n\nSnapshotRequest.prototype._handleResponse = function(error, message) {\n  this.emit('ready');\n\n  if (error) {\n    return this.callback(error);\n  }\n\n  var metadata = message.meta ? message.meta : null;\n  var snapshot = new Snapshot(this.id, message.v, message.type, message.data, metadata);\n\n  this.callback(null, snapshot);\n};\n",
    "var SnapshotRequest = require('./snapshot-request');\nvar util = require('../../util');\n\nmodule.exports = SnapshotTimestampRequest;\n\nfunction SnapshotTimestampRequest(connection, requestId, collection, id, timestamp, callback) {\n  SnapshotRequest.call(this, connection, requestId, collection, id, callback);\n\n  if (!util.isValidTimestamp(timestamp)) {\n    throw new Error('Snapshot timestamp must be a positive integer or null');\n  }\n\n  this.timestamp = timestamp;\n}\n\nSnapshotTimestampRequest.prototype = Object.create(SnapshotRequest.prototype);\n\nSnapshotTimestampRequest.prototype._message = function() {\n  return {\n    a: 'nt',\n    id: this.requestId,\n    c: this.collection,\n    d: this.id,\n    ts: this.timestamp\n  };\n};\n",
    "var SnapshotRequest = require('./snapshot-request');\nvar util = require('../../util');\n\nmodule.exports = SnapshotVersionRequest;\n\nfunction SnapshotVersionRequest(connection, requestId, collection, id, version, callback) {\n  SnapshotRequest.call(this, connection, requestId, collection, id, callback);\n\n  if (!util.isValidVersion(version)) {\n    throw new Error('Snapshot version must be a positive integer or null');\n  }\n\n  this.version = version;\n}\n\nSnapshotVersionRequest.prototype = Object.create(SnapshotRequest.prototype);\n\nSnapshotVersionRequest.prototype._message = function() {\n  return {\n    a: 'nf',\n    id: this.requestId,\n    c: this.collection,\n    d: this.id,\n    v: this.version\n  };\n};\n",
    "var EventEmitter = require('events').EventEmitter;\n\nexports.EventEmitter = EventEmitter;\nexports.mixin = mixin;\n\nfunction mixin(Constructor) {\n  for (var key in EventEmitter.prototype) {\n    Constructor.prototype[key] = EventEmitter.prototype[key];\n  }\n}\n",
    "function ShareDBError(code, message) {\n  this.code = code;\n  this.message = message || '';\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, ShareDBError);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nShareDBError.prototype = Object.create(Error.prototype);\nShareDBError.prototype.constructor = ShareDBError;\nShareDBError.prototype.name = 'ShareDBError';\n\nShareDBError.CODES = {\n  ERR_APPLY_OP_VERSION_DOES_NOT_MATCH_SNAPSHOT: 'ERR_APPLY_OP_VERSION_DOES_NOT_MATCH_SNAPSHOT',\n  ERR_APPLY_SNAPSHOT_NOT_PROVIDED: 'ERR_APPLY_SNAPSHOT_NOT_PROVIDED',\n  ERR_CLIENT_ID_BADLY_FORMED: 'ERR_CLIENT_ID_BADLY_FORMED',\n  ERR_CONNECTION_SEQ_INTEGER_OVERFLOW: 'ERR_CONNECTION_SEQ_INTEGER_OVERFLOW',\n  ERR_CONNECTION_STATE_TRANSITION_INVALID: 'ERR_CONNECTION_STATE_TRANSITION_INVALID',\n  ERR_DATABASE_ADAPTER_NOT_FOUND: 'ERR_DATABASE_ADAPTER_NOT_FOUND',\n  ERR_DATABASE_DOES_NOT_SUPPORT_SUBSCRIBE: 'ERR_DATABASE_DOES_NOT_SUPPORT_SUBSCRIBE',\n  ERR_DATABASE_METHOD_NOT_IMPLEMENTED: 'ERR_DATABASE_METHOD_NOT_IMPLEMENTED',\n  ERR_DEFAULT_TYPE_MISMATCH: 'ERR_DEFAULT_TYPE_MISMATCH',\n  ERR_DOC_MISSING_VERSION: 'ERR_DOC_MISSING_VERSION',\n  ERR_DOC_ALREADY_CREATED: 'ERR_DOC_ALREADY_CREATED',\n  ERR_DOC_DOES_NOT_EXIST: 'ERR_DOC_DOES_NOT_EXIST',\n  ERR_DOC_TYPE_NOT_RECOGNIZED: 'ERR_DOC_TYPE_NOT_RECOGNIZED',\n  ERR_DOC_WAS_DELETED: 'ERR_DOC_WAS_DELETED',\n  ERR_INFLIGHT_OP_MISSING: 'ERR_INFLIGHT_OP_MISSING',\n  ERR_INGESTED_SNAPSHOT_HAS_NO_VERSION: 'ERR_INGESTED_SNAPSHOT_HAS_NO_VERSION',\n  ERR_MAX_SUBMIT_RETRIES_EXCEEDED: 'ERR_MAX_SUBMIT_RETRIES_EXCEEDED',\n  ERR_MESSAGE_BADLY_FORMED: 'ERR_MESSAGE_BADLY_FORMED',\n  ERR_MILESTONE_ARGUMENT_INVALID: 'ERR_MILESTONE_ARGUMENT_INVALID',\n  ERR_OP_ALREADY_SUBMITTED: 'ERR_OP_ALREADY_SUBMITTED',\n  ERR_OP_NOT_ALLOWED_IN_PROJECTION: 'ERR_OP_NOT_ALLOWED_IN_PROJECTION',\n  ERR_OP_SUBMIT_REJECTED: 'ERR_OP_SUBMIT_REJECTED',\n  ERR_OP_VERSION_MISMATCH_AFTER_TRANSFORM: 'ERR_OP_VERSION_MISMATCH_AFTER_TRANSFORM',\n  ERR_OP_VERSION_MISMATCH_DURING_TRANSFORM: 'ERR_OP_VERSION_MISMATCH_DURING_TRANSFORM',\n  ERR_OP_VERSION_NEWER_THAN_CURRENT_SNAPSHOT: 'ERR_OP_VERSION_NEWER_THAN_CURRENT_SNAPSHOT',\n  ERR_OT_OP_BADLY_FORMED: 'ERR_OT_OP_BADLY_FORMED',\n  ERR_OT_OP_NOT_PROVIDED: 'ERR_OT_OP_NOT_PROVIDED',\n  ERR_PRESENCE_TRANSFORM_FAILED: 'ERR_PRESENCE_TRANSFORM_FAILED',\n  ERR_PROTOCOL_VERSION_NOT_SUPPORTED: 'ERR_PROTOCOL_VERSION_NOT_SUPPORTED',\n  ERR_QUERY_EMITTER_LISTENER_NOT_ASSIGNED: 'ERR_QUERY_EMITTER_LISTENER_NOT_ASSIGNED',\n  /**\n   * A special error that a \"readSnapshots\" middleware implementation can use to indicate that it\n   * wishes for the ShareDB client to treat it as a silent rejection, not passing the error back to\n   * user code.\n   *\n   * For subscribes, the ShareDB client will still cancel the document subscription.\n   */\n  ERR_SNAPSHOT_READ_SILENT_REJECTION: 'ERR_SNAPSHOT_READ_SILENT_REJECTION',\n  /**\n   * A \"readSnapshots\" middleware rejected the reads of specific snapshots.\n   *\n   * This error code is mostly for server use and generally will not be encountered on the client.\n   * Instead, each specific doc that encountered an error will receive its specific error.\n   *\n   * The one exception is for queries, where a \"readSnapshots\" rejection of specific snapshots will\n   * cause the client to receive this error for the whole query, since queries don't support\n   * doc-specific errors.\n   */\n  ERR_SNAPSHOT_READS_REJECTED: 'ERR_SNAPSHOT_READS_REJECTED',\n  ERR_SUBMIT_TRANSFORM_OPS_NOT_FOUND: 'ERR_SUBMIT_TRANSFORM_OPS_NOT_FOUND',\n  ERR_TYPE_CANNOT_BE_PROJECTED: 'ERR_TYPE_CANNOT_BE_PROJECTED',\n  ERR_TYPE_DOES_NOT_SUPPORT_PRESENCE: 'ERR_TYPE_DOES_NOT_SUPPORT_PRESENCE',\n  ERR_UNKNOWN_ERROR: 'ERR_UNKNOWN_ERROR'\n};\n\nmodule.exports = ShareDBError;\n",
    "var Logger = require('./logger');\nvar logger = new Logger();\nmodule.exports = logger;\n",
    "var SUPPORTED_METHODS = [\n  'info',\n  'warn',\n  'error'\n];\n\nfunction Logger() {\n  var defaultMethods = {};\n  SUPPORTED_METHODS.forEach(function(method) {\n    // Deal with Chrome issue: https://bugs.chromium.org/p/chromium/issues/detail?id=179628\n    defaultMethods[method] = console[method].bind(console);\n  });\n  this.setMethods(defaultMethods);\n}\nmodule.exports = Logger;\n\nLogger.prototype.setMethods = function(overrides) {\n  overrides = overrides || {};\n  var logger = this;\n\n  SUPPORTED_METHODS.forEach(function(method) {\n    if (typeof overrides[method] === 'function') {\n      logger[method] = overrides[method];\n    }\n  });\n};\n",
    "// This contains the master OT functions for the database. They look like\n// ot-types style operational transform functions, but they're a bit different.\n// These functions understand versions and can deal with out of bound create &\n// delete operations.\n\nvar types = require('./types').map;\nvar ShareDBError = require('./error');\nvar util = require('./util');\n\nvar ERROR_CODE = ShareDBError.CODES;\n\n// Returns an error string on failure. Rockin' it C style.\nexports.checkOp = function(op) {\n  if (op == null || typeof op !== 'object') {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'Op must be an object');\n  }\n\n  if (op.create != null) {\n    if (typeof op.create !== 'object') {\n      return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'Create data must be an object');\n    }\n    var typeName = op.create.type;\n    if (typeof typeName !== 'string') {\n      return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'Missing create type');\n    }\n    var type = types[typeName];\n    if (type == null || typeof type !== 'object') {\n      return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, 'Unknown type');\n    }\n  } else if (op.del != null) {\n    if (op.del !== true) return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'del value must be true');\n  } else if (!('op' in op)) {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'Missing op, create, or del');\n  }\n\n  if (op.src != null && typeof op.src !== 'string') {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'src must be a string');\n  }\n  if (op.seq != null && typeof op.seq !== 'number') {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'seq must be a string');\n  }\n  if (\n    (op.src == null && op.seq != null) ||\n    (op.src != null && op.seq == null)\n  ) {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'Both src and seq must be set together');\n  }\n\n  if (op.m != null && typeof op.m !== 'object') {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'op.m must be an object or null');\n  }\n};\n\n// Takes in a string (type name or URI) and returns the normalized name (uri)\nexports.normalizeType = function(typeName) {\n  return types[typeName] && types[typeName].uri;\n};\n\n// This is the super apply function that takes in snapshot data (including the\n// type) and edits it in-place. Returns an error or null for success.\nexports.apply = function(snapshot, op) {\n  if (typeof snapshot !== 'object') {\n    return new ShareDBError(ERROR_CODE.ERR_APPLY_SNAPSHOT_NOT_PROVIDED, 'Missing snapshot');\n  }\n  if (snapshot.v != null && op.v != null && snapshot.v !== op.v) {\n    return new ShareDBError(ERROR_CODE.ERR_APPLY_OP_VERSION_DOES_NOT_MATCH_SNAPSHOT, 'Version mismatch');\n  }\n\n  // Create operation\n  if (op.create) {\n    if (snapshot.type) return new ShareDBError(ERROR_CODE.ERR_DOC_ALREADY_CREATED, 'Document already exists');\n\n    // The document doesn't exist, although it might have once existed\n    var create = op.create;\n    var type = types[create.type];\n    if (!type) return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, 'Unknown type');\n\n    try {\n      snapshot.data = type.create(create.data);\n      snapshot.type = type.uri;\n      snapshot.v++;\n    } catch (err) {\n      return err;\n    }\n\n  // Delete operation\n  } else if (op.del) {\n    snapshot.data = undefined;\n    snapshot.type = null;\n    snapshot.v++;\n\n  // Edit operation\n  } else if ('op' in op) {\n    var err = applyOpEdit(snapshot, op.op);\n    if (err) return err;\n    snapshot.v++;\n\n  // No-op, and we don't have to do anything\n  } else {\n    snapshot.v++;\n  }\n};\n\nfunction applyOpEdit(snapshot, edit) {\n  if (!snapshot.type) return new ShareDBError(ERROR_CODE.ERR_DOC_DOES_NOT_EXIST, 'Document does not exist');\n\n  if (edit === undefined) return new ShareDBError(ERROR_CODE.ERR_OT_OP_NOT_PROVIDED, 'Missing op');\n  var type = types[snapshot.type];\n  if (!type) return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, 'Unknown type');\n\n  try {\n    snapshot.data = type.apply(snapshot.data, edit);\n  } catch (err) {\n    return err;\n  }\n}\n\nexports.transform = function(type, op, appliedOp) {\n  // There are 16 cases this function needs to deal with - which are all the\n  // combinations of create/delete/op/noop from both op and appliedOp\n  if (op.v != null && op.v !== appliedOp.v) {\n    return new ShareDBError(ERROR_CODE.ERR_OP_VERSION_MISMATCH_DURING_TRANSFORM, 'Version mismatch');\n  }\n\n  if (appliedOp.del) {\n    if (op.create || 'op' in op) {\n      return new ShareDBError(ERROR_CODE.ERR_DOC_WAS_DELETED, 'Document was deleted');\n    }\n  } else if (\n    (appliedOp.create && ('op' in op || op.create || op.del)) ||\n    ('op' in appliedOp && op.create)\n  ) {\n    // If appliedOp.create is not true, appliedOp contains an op - which\n    // also means the document exists remotely.\n    return new ShareDBError(ERROR_CODE.ERR_DOC_ALREADY_CREATED, 'Document was created remotely');\n  } else if ('op' in appliedOp && 'op' in op) {\n    // If we reach here, they both have a .op property.\n    if (!type) return new ShareDBError(ERROR_CODE.ERR_DOC_DOES_NOT_EXIST, 'Document does not exist');\n\n    if (typeof type === 'string') {\n      type = types[type];\n      if (!type) return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, 'Unknown type');\n    }\n\n    try {\n      op.op = type.transform(op.op, appliedOp.op, 'left');\n    } catch (err) {\n      return err;\n    }\n  }\n\n  if (op.v != null) op.v++;\n};\n\n/**\n * Apply an array of ops to the provided snapshot.\n *\n * @param snapshot - a Snapshot object which will be mutated by the provided ops\n * @param ops - an array of ops to apply to the snapshot\n * @return an error object if applicable\n */\nexports.applyOps = function(snapshot, ops) {\n  var type = null;\n\n  if (snapshot.type) {\n    type = types[snapshot.type];\n    if (!type) return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, 'Unknown type');\n  }\n\n  for (var index = 0; index < ops.length; index++) {\n    var op = ops[index];\n\n    snapshot.v = op.v + 1;\n\n    if (op.create) {\n      type = types[op.create.type];\n      if (!type) return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, 'Unknown type');\n      snapshot.data = type.create(op.create.data);\n      snapshot.type = type.uri;\n    } else if (op.del) {\n      snapshot.data = undefined;\n      type = null;\n      snapshot.type = null;\n    } else {\n      snapshot.data = type.apply(snapshot.data, op.op);\n    }\n  }\n};\n\nexports.transformPresence = function(presence, op, isOwnOp) {\n  var opError = this.checkOp(op);\n  if (opError) return opError;\n\n  var type = presence.t;\n  if (typeof type === 'string') {\n    type = types[type];\n  }\n  if (!type) return {code: ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, message: 'Unknown type'};\n  if (!util.supportsPresence(type)) {\n    return {code: ERROR_CODE.ERR_TYPE_DOES_NOT_SUPPORT_PRESENCE, message: 'Type does not support presence'};\n  }\n\n  if (op.create || op.del) {\n    presence.p = null;\n    presence.v++;\n    return;\n  }\n\n  try {\n    presence.p = presence.p === null ?\n      null :\n      type.transformPresence(presence.p, op.op, isOwnOp);\n  } catch (error) {\n    return {code: ERROR_CODE.ERR_PRESENCE_TRANSFORM_FAILED, message: error.message || error};\n  }\n\n  presence.v++;\n};\n",
    "module.exports = Snapshot;\nfunction Snapshot(id, version, type, data, meta) {\n  this.id = id;\n  this.v = version;\n  this.type = type;\n  this.data = data;\n  this.m = meta;\n}\n",
    "\nexports.defaultType = require('ot-json0').type;\n\nexports.map = {};\n\nexports.register = function(type) {\n  if (type.name) exports.map[type.name] = type;\n  if (type.uri) exports.map[type.uri] = type;\n};\n\nexports.register(exports.defaultType);\n",
    "\nexports.doNothing = doNothing;\nfunction doNothing() {}\n\nexports.hasKeys = function(object) {\n  for (var key in object) return true;\n  return false;\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nexports.isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\nexports.isValidVersion = function(version) {\n  if (version === null) return true;\n  return exports.isInteger(version) && version >= 0;\n};\n\nexports.isValidTimestamp = function(timestamp) {\n  return exports.isValidVersion(timestamp);\n};\n\nexports.MAX_SAFE_INTEGER = 9007199254740991;\n\nexports.dig = function() {\n  var obj = arguments[0];\n  for (var i = 1; i < arguments.length; i++) {\n    var key = arguments[i];\n    obj = obj[key] || (i === arguments.length - 1 ? undefined : {});\n  }\n  return obj;\n};\n\nexports.digOrCreate = function() {\n  var obj = arguments[0];\n  var createCallback = arguments[arguments.length - 1];\n  for (var i = 1; i < arguments.length - 1; i++) {\n    var key = arguments[i];\n    obj = obj[key] ||\n      (obj[key] = i === arguments.length - 2 ? createCallback() : {});\n  }\n  return obj;\n};\n\nexports.digAndRemove = function() {\n  var obj = arguments[0];\n  var objects = [obj];\n  for (var i = 1; i < arguments.length - 1; i++) {\n    var key = arguments[i];\n    if (!obj.hasOwnProperty(key)) break;\n    obj = obj[key];\n    objects.push(obj);\n  };\n\n  for (var i = objects.length - 1; i >= 0; i--) {\n    var parent = objects[i];\n    var key = arguments[i + 1];\n    var child = parent[key];\n    if (i === objects.length - 1 || !exports.hasKeys(child)) delete parent[key];\n  }\n};\n\nexports.supportsPresence = function(type) {\n  return type && typeof type.transformPresence === 'function';\n};\n\nexports.callEach = function(callbacks, error) {\n  var called = false;\n  callbacks.forEach(function(callback) {\n    if (callback) {\n      callback(error);\n      called = true;\n    }\n  });\n  return called;\n};\n\nexports.truthy = function(arg) {\n  return !!arg;\n};\n",
    "var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};",
    "var qs = require('qs')\nvar parseUrl = require('url').parse\nvar resolveUrl = require('url').resolve\nvar router = require('./router')\nvar currentPath = window.location.pathname + window.location.search\n\n// Replace the initial state with the current URL immediately,\n// so that it will be rendered if the state is later popped\nif (window.history.replaceState) {\n  window.history.replaceState({\n    $render: true,\n    $method: 'get'\n  }, null, window.location.href)\n}\n\nmodule.exports = History\n\nfunction History(app, routes) {\n  this.app = app\n  this.routes = routes\n\n  if (window.history.pushState) {\n    addListeners(this)\n    return\n  }\n  this.push = function(url) {\n    window.location.assign(url)\n  }\n  this.replace = function(url) {\n    window.location.replace(url)\n  }\n}\n\nHistory.prototype.push = function(url, render, state, e) {\n  this._update('pushState', url, render, state, e)\n}\n\nHistory.prototype.replace = function(url, render, state, e) {\n  this._update('replaceState', url, render, state, e)\n}\n\n// Rerender the current url locally\nHistory.prototype.refresh = function() {\n  var path = routePath(window.location.href)\n  // Note that we don't pass previous to avoid triggering transitions\n  router.render(this, {url: path, method: 'get'})\n}\n\nHistory.prototype.back = function() {\n  window.history.back()\n}\n\nHistory.prototype.forward = function() {\n  window.history.forward()\n}\n\nHistory.prototype.go = function(i) {\n  window.history.go(i)\n}\n\nHistory.prototype._update = function(historyMethod, relativeUrl, render, state, e) {\n  var url = resolveUrl(window.location.href, relativeUrl)\n  var path = routePath(url)\n\n  // TODO: history.push should set the window.location with external urls\n  if (!path) return\n  if (render == null) render = true\n  if (state == null) state = {}\n\n  // Update the URL\n  var options = renderOptions(e, path)\n  state.$render = true\n  state.$method = options.method\n  window.history[historyMethod](state, null, options.url)\n  currentPath = window.location.pathname + window.location.search\n  if (render) router.render(this, options, e)\n}\n\nHistory.prototype.page = function() {\n  var page = this.app.createPage()\n  var history = this\n\n  function redirect(url) {\n    if (url === 'back') return history.back()\n    // TODO: Add support for `basepath` option like Express\n    if (url === 'home') url = '\\\\'\n    history.replace(url, true)\n  }\n\n  page.redirect = redirect\n  return page\n}\n\n// Get the pathname if it is on the same protocol and domain\nfunction routePath(url) {\n  var match = parseUrl(url)\n  return match &&\n    match.protocol === window.location.protocol &&\n    match.host === window.location.host &&\n    match.pathname + (match.search || '')\n}\n\nfunction renderOptions(e, path) {\n  // If this is a form submission, extract the form data and\n  // append it to the url for a get or params.body for a post\n  if (e && e.type === 'submit') {\n    var form = e.target\n    var elements = form.elements\n    var query = []\n    for (var i = 0, len = elements.length, el; i < len; i++) {\n      el = elements[i]\n      var name = el.name\n      if (!name) continue\n      var value = el.value\n      query.push(encodeURIComponent(name) + '=' + encodeURIComponent(value))\n      if (name === '_method') {\n        var override = value.toLowerCase()\n        if (override === 'delete') override = 'del'\n      }\n    }\n    query = query.join('&')\n    if (form.method.toLowerCase() === 'post') {\n      var method = override || 'post'\n      var body = qs.parse(query)\n    } else {\n      method = 'get'\n      path += '?' + query\n    }\n  } else {\n    method = 'get'\n  }\n  return {\n    method: method\n  , url: path\n  , previous: window.location.pathname + window.location.search\n  , body: body\n  , form: form\n  , link: e && e._tracksLink\n  }\n}\n\nfunction addListeners(history) {\n\n  // Detect clicks on links\n  function onClick(e) {\n    var el = e.target\n\n    // Ignore command click, control click, and non-left click\n    if (e.metaKey || e.which !== 1) return\n\n    // Ignore if already prevented\n    if (e.defaultPrevented) return\n\n    // Also look up for parent links (<a><img></a>)\n    while (el) {\n      var url = el.href\n      if (url) {\n\n        // Ignore if created by Tracks\n        if (el.hasAttribute && el.hasAttribute('data-router-ignore')) return\n\n        // Ignore links meant to open in a different window or frame\n        if (el.target && el.target !== '_self') return\n\n        // Ignore hash links to the same page\n        var hashIndex = url.indexOf('#')\n        if (~hashIndex && url.slice(0, hashIndex) === window.location.href.replace(/#.*/, '')) {\n          return\n        }\n\n        e._tracksLink = el\n        history.push(url, true, null, e)\n        return\n      }\n\n      el = el.parentNode\n    }\n  }\n\n  function onSubmit(e) {\n    var target = e.target\n\n    // Ignore if already prevented\n    if (e.defaultPrevented) return\n\n    // Only handle if emitted on a form element that isn't multipart\n    if (target.tagName.toLowerCase() !== 'form') return\n    if (target.enctype === 'multipart/form-data') return\n\n    // Ignore if created by Tracks\n    if (target.hasAttribute && target.hasAttribute('data-router-ignore')) return\n\n    // Use the url from the form action, defaulting to the current url\n    var url = target.action || window.location.href\n    history.push(url, true, null, e)\n  }\n\n  function onPopState(e) {\n    // HACK: Chrome sometimes does a pop state before the app is set up properly\n    if (!history.app.page) return\n\n    var previous = currentPath\n    var state = e.state\n    currentPath = window.location.pathname + window.location.search\n\n    var options = {\n      previous: previous\n    , url: currentPath\n    }\n\n    if (state) {\n      if (!state.$render) return\n      options.method = state.$method\n      // Note that the post body is only sent on the initial reqest\n      // and it is empty if the state is later popped\n      return router.render(history, options)\n    }\n\n    // The state object will be null for states created by jump links.\n    // window.location.hash cannot be used, because it returns nothing\n    // if the url ends in just a hash character\n    var url = window.location.href\n      , hashIndex = url.indexOf('#')\n      , el, id\n    if (~hashIndex && currentPath !== previous) {\n      options.method = 'get'\n      router.render(history, options)\n      id = url.slice(hashIndex + 1)\n      if (el = document.getElementById(id) || document.getElementsByName(id)[0]) {\n        el.scrollIntoView()\n      }\n    }\n  }\n\n  document.addEventListener('click', onClick, true)\n  document.addEventListener('submit', onSubmit, false)\n  window.addEventListener('popstate', onPopState, true)\n}\n",
    "var Route = require('../vendor/express/router/route')\nvar History = require('./History')\nvar router = module.exports = require('./router')\n\nrouter.setup = setup\n\nfunction setup(app) {\n  var routes = {\n    queue: {}\n  , transitional: {}\n  , app: app\n  }\n  app.history = new History(app, routes)\n\n  ;['get', 'post', 'put', 'del', 'enter', 'exit'].forEach(function(method) {\n    var queue = routes.queue[method] = []\n    var transitional = routes.transitional[method] = []\n\n    app[method] = function(pattern, callback) {\n      if (Array.isArray(pattern)) {\n        pattern.forEach(function(item) {\n          app[method](item, callback)\n        })\n        return app\n      }\n\n      if (router.isTransitional(pattern)) {\n        var from = pattern.from\n        var to = pattern.to\n        var forward = pattern.forward || (callback && callback.forward) || callback\n        var back = pattern.back || (callback && callback.back)\n\n        var fromRoute = new Route(method, from, back)\n        var toRoute = new Route(method, to, forward)\n        fromRoute.isTransitional = true\n        toRoute.isTransitional = true\n        transitional.push({\n          from: fromRoute\n        , to: toRoute\n        })\n        if (back) transitional.push({\n          from: toRoute\n        , to: fromRoute\n        })\n\n        return app\n      }\n\n      queue.push(new Route(method, pattern, callback))\n      return app\n    }\n  })\n}\n",
    "var qs = require('qs')\nvar nodeUrl = require('url');\n\nmodule.exports = {\n  render: render\n, isTransitional: isTransitional\n, mapRoute: mapRoute\n}\n\nfunction isTransitional(pattern) {\n  return pattern.hasOwnProperty('from') && pattern.hasOwnProperty('to')\n}\n\nfunction mapRoute(from, params) {\n  var i = params.url.indexOf('?')\n  var queryString = (~i) ? params.url.slice(i) : ''\n  // If the route looks like /:a/:b?/:c/:d?\n  // and :b and :d are missing, return /a/c\n  // Thus, skip the / if the value is missing\n  var i = 0\n  var path = from.replace(/\\/(?:(?:\\:([^?\\/:*(]+)(?:\\([^)]+\\))?)|\\*)(\\?)?/g, onMatch)\n  function onMatch(match, key, optional) {\n    var value = key ? params[key] : params[i++]\n    return (optional && value == null) ? '' : '/' + encodeURIComponent(value)\n  }\n  return path + queryString\n}\n\nfunction render(history, options, e) {\n  var req = new RenderReq(history.app.page, history.routes, options, e)\n  req.routeTransitional(0, function() {\n    req.page = history.page()\n    req.routeQueue(0, function() {\n      // Cancel rendering by this app if no routes match\n      req.cancel()\n    })\n  })\n}\n\nfunction RenderReq(page, routes, options, e) {\n  this.page = page\n  this.options = options\n  this.e = e\n  this.setUrl(options.url.replace(/#.*/, ''))\n  var queryString = nodeUrl.parse(this.url).query;\n  this.query = queryString ? qs.parse(queryString) : {}\n  this.method = options.method\n  this.body = options.body || {}\n  this.setPrevious(options.previous)\n  this.transitional = routes.transitional[this.method]\n  this.queue = routes.queue[this.method]\n  this.app = routes.app\n}\n\nRenderReq.prototype.cancel = function() {\n  var options = this.options\n  // Don't do anything if this is the result of an event, since the\n  // appropriate action will happen by default\n  if (this.e || options.noNavigate) return\n  // Otherwise, manually perform appropriate action\n  if (options.form) {\n    options.form.setAttribute('data-router-ignore', '')\n    options.form.submit()\n  } else {\n    window.location.assign(options.url)\n  }\n}\n\nRenderReq.prototype.setUrl = function(url) {\n  this.url = url\n  this.path = url.replace(/\\?.*/, '')\n}\nRenderReq.prototype.setPrevious = function(previous) {\n  this.previous = previous\n  this.previousPath = previous && previous.replace(/\\?.*/, '')\n}\n\nRenderReq.prototype.routeTransitional = function(i, next) {\n  i || (i = 0)\n  var item\n  while (item = this.transitional[i++]) {\n    if (!item.to.match(this.path) || !item.from.match(this.previousPath)) continue\n    var req = this\n    var params = this.routeParams(item.to)\n    // Even though we don't need to do anything after a done, pass a\n    // no op function, so that routes can expect it to be defined\n    function done() {}\n    this.onMatch(item.to, params, function(err) {\n      if (err) return req.cancel()\n      req.routeTransitional(i, next)\n    }, done)\n    return\n  }\n  next()\n}\n\nRenderReq.prototype.routeQueue = function(i, next) {\n  i || (i = 0)\n  var route\n  while (route = this.queue[i++]) {\n    if (!route.match(this.path)) continue\n    var req = this\n    var params = this.routeParams(route)\n    this.onMatch(route, params, function(err) {\n      if (err) return req.cancel()\n      req.routeQueue(i, next)\n    })\n    return\n  }\n  next()\n}\n\nRenderReq.prototype.onMatch = function(route, params, next, done) {\n  if (!this.page) return next()\n  // Stop the default browser action, such as clicking a link or submitting a form\n  if (this.e) {\n    this.e.preventDefault()\n    this.e = null\n  }\n  this.page.params = params\n  if (route.isTransitional) {\n    this.app.onRoute(route.callbacks, this.page, next, done)\n  } else {\n    this.app.onRoute(route.callbacks, this.page, next)\n  }\n}\n\nRenderReq.prototype.routeParams = function(route) {\n  var routeParams = route.params\n  var params = routeParams.slice()\n\n  for (var key in routeParams) {\n    params[key] = routeParams[key]\n  }\n  params.previous = this.previous\n  params.url = this.url\n  params.body = this.body\n  params.query = this.query\n  params.method = this.method\n  return params\n}\n",
    "\n/**\n * Module dependencies.\n */\n\nvar utils = require('../utils');\n\n/**\n * Expose `Route`.\n */\n\nmodule.exports = Route;\n\n/**\n * Initialize `Route` with the given HTTP `method`, `path`,\n * and an array of `callbacks` and `options`.\n *\n * Options:\n *\n *   - `sensitive`    enable case-sensitive routes\n *   - `strict`       enable strict matching for trailing slashes\n *\n * @param {String} method\n * @param {String} path\n * @param {Array} callbacks\n * @param {Object} options.\n * @api private\n */\n\nfunction Route(method, path, callbacks, options) {\n  options = options || {};\n  this.path = path;\n  this.method = method;\n  this.callbacks = callbacks;\n  this.regexp = utils.pathRegexp(path\n    , this.keys = []\n    , options.sensitive\n    , options.strict);\n}\n\n/**\n * Check if this route matches `path`, if so\n * populate `.params`.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nRoute.prototype.match = function(path){\n  var keys = this.keys\n    , params = this.params = []\n    , m = this.regexp.exec(path);\n\n  if (!m) return false;\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = keys[i - 1];\n\n    var val = 'string' == typeof m[i]\n      ? decodeURIComponent(m[i])\n      : m[i];\n\n    if (key) {\n      params[key.name] = val;\n    } else {\n      params.push(val);\n    }\n  }\n\n  return true;\n};\n",
    "\n/**\n * Module dependencies.\n */\n\n/**\n * toString ref.\n */\n\nvar toString = {}.toString;\n\n/**\n * Return ETag for `body`.\n *\n * @param {String|Buffer} body\n * @return {String}\n * @api private\n */\n\nexports.etag = function(body){\n  return '\"' + crc32.signed(body) + '\"';\n};\n\n/**\n * Make `locals()` bound to the given `obj`.\n *\n * This is used for `app.locals` and `res.locals`.\n *\n * @param {Object} obj\n * @return {Function}\n * @api private\n */\n\nexports.locals = function(obj){\n  function locals(obj){\n    for (var key in obj) locals[key] = obj[key];\n    return obj;\n  };\n\n  return locals;\n};\n\n/**\n * Check if `path` looks absolute.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nexports.isAbsolute = function(path){\n  if ('/' == path[0]) return true;\n  if (':' == path[1] && '\\\\' == path[2]) return true;\n};\n\n/**\n * Flatten the given `arr`.\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.flatten = function(arr, ret){\n  var ret = ret || []\n    , len = arr.length;\n  for (var i = 0; i < len; ++i) {\n    if (Array.isArray(arr[i])) {\n      exports.flatten(arr[i], ret);\n    } else {\n      ret.push(arr[i]);\n    }\n  }\n  return ret;\n};\n\n/**\n * Normalize the given `type`, for example \"html\" becomes \"text/html\".\n *\n * @param {String} type\n * @return {Object}\n * @api private\n */\n\nexports.normalizeType = function(type){\n  return ~type.indexOf('/')\n    ? acceptParams(type)\n    : { value: mime.lookup(type), params: {} };\n};\n\n/**\n * Normalize `types`, for example \"html\" becomes \"text/html\".\n *\n * @param {Array} types\n * @return {Array}\n * @api private\n */\n\nexports.normalizeTypes = function(types){\n  var ret = [];\n\n  for (var i = 0; i < types.length; ++i) {\n    ret.push(exports.normalizeType(types[i]));\n  }\n\n  return ret;\n};\n\n/**\n * Return the acceptable type in `types`, if any.\n *\n * @param {Array} types\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.acceptsArray = function(types, str){\n  // accept anything when Accept is not present\n  if (!str) return types[0];\n\n  // parse\n  var accepted = exports.parseAccept(str)\n    , normalized = exports.normalizeTypes(types)\n    , len = accepted.length;\n\n  for (var i = 0; i < len; ++i) {\n    for (var j = 0, jlen = types.length; j < jlen; ++j) {\n      if (exports.accept(normalized[j], accepted[i])) {\n        return types[j];\n      }\n    }\n  }\n};\n\n/**\n * Check if `type(s)` are acceptable based on\n * the given `str`.\n *\n * @param {String|Array} type(s)\n * @param {String} str\n * @return {Boolean|String}\n * @api private\n */\n\nexports.accepts = function(type, str){\n  if ('string' == typeof type) type = type.split(/ *, */);\n  return exports.acceptsArray(type, str);\n};\n\n/**\n * Check if `type` array is acceptable for `other`.\n *\n * @param {Object} type\n * @param {Object} other\n * @return {Boolean}\n * @api private\n */\n\nexports.accept = function(type, other){\n  var t = type.value.split('/');\n  return (t[0] == other.type || '*' == other.type)\n    && (t[1] == other.subtype || '*' == other.subtype)\n    && paramsEqual(type.params, other.params);\n};\n\n/**\n * Check if accept params are equal.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Boolean}\n * @api private\n */\n\nfunction paramsEqual(a, b){\n  return !Object.keys(a).some(function(k) {\n    return a[k] != b[k];\n  });\n}\n\n/**\n * Parse accept `str`, returning\n * an array objects containing\n * `.type` and `.subtype` along\n * with the values provided by\n * `parseQuality()`.\n *\n * @param {Type} name\n * @return {Type}\n * @api private\n */\n\nexports.parseAccept = function(str){\n  return exports\n    .parseParams(str)\n    .map(function(obj){\n      var parts = obj.value.split('/');\n      obj.type = parts[0];\n      obj.subtype = parts[1];\n      return obj;\n    });\n};\n\n/**\n * Parse quality `str`, returning an\n * array of objects with `.value`,\n * `.quality` and optional `.params`\n *\n * @param {String} str\n * @return {Array}\n * @api private\n */\n\nexports.parseParams = function(str){\n  return str\n    .split(/ *, */)\n    .map(acceptParams)\n    .filter(function(obj){\n      return obj.quality;\n    })\n    .sort(function(a, b){\n      if (a.quality === b.quality) {\n        return a.originalIndex - b.originalIndex;\n      } else {\n        return b.quality - a.quality;\n      }\n    });\n};\n\n/**\n * Parse accept params `str` returning an\n * object with `.value`, `.quality` and `.params`.\n * also includes `.originalIndex` for stable sorting\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction acceptParams(str, index) {\n  var parts = str.split(/ *; */);\n  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };\n\n  for (var i = 1; i < parts.length; ++i) {\n    var pms = parts[i].split(/ *= */);\n    if ('q' == pms[0]) {\n      ret.quality = parseFloat(pms[1]);\n    } else {\n      ret.params[pms[0]] = pms[1];\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function(html) {\n  return String(html)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n};\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Boolean} sensitive\n * @param  {Boolean} strict\n * @return {RegExp}\n * @api private\n */\n\nexports.pathRegexp = function(path, keys, sensitive, strict) {\n  if (toString.call(path) == '[object RegExp]') return path;\n  if (Array.isArray(path)) path = '(' + path.join('|') + ')';\n  path = path\n    .concat(strict ? '' : '/?')\n    .replace(/\\/\\(/g, '(?:/')\n    .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?(\\*)?/g, function(_, slash, format, key, capture, optional, star){\n      keys.push({ name: key, optional: !! optional });\n      slash = slash || '';\n      return ''\n        + (optional ? '' : slash)\n        + '(?:'\n        + (optional ? slash : '')\n        + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n        + (optional || '')\n        + (star ? '(/*)?' : '');\n    })\n    .replace(/([\\/.])/g, '\\\\$1')\n    .replace(/\\*/g, '(.*)');\n  return new RegExp('^' + path + '$', sensitive ? '' : 'i');\n}\n",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n",
    "'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n",
    "export { default } from './register';",
    "import { Component } from 'derby';\n\nclass RegisterData {\n    value: number = 0;\n}\n\nclass RegisterComponent extends Component<RegisterData> {\n    static view = '/home/aananth/dev/DeNote/views/auth/Components/register.html';\n    static DataConstructor = RegisterData;\n    static is = 'auth-register';\n\n    private model: any;\n    private value: any;\n    getAttribute: any;\n\n    init() {\n        this.value = this.model.ref('value', this.model.scope('random.value'));\n    }\n\n    create() {\n        // console.log(\"create called\");\n        // console.log(document);\n        // console.log(document.getElementById('increase-button'));\n    }\n\n    increase() {\n        this.value.set(this.value.get() + 1);\n    }\n}\n\nexport default RegisterComponent;",
    "import derby from 'derby';\n\n// import DerbyApplication from '../base';\nimport models from './Models';\n\nimport RegisterComponent from './Components/register';\nimport { initializeComponents } from '../base/application';\n\nconst components = [\n    RegisterComponent\n]\n\nconst app = derby.createApp('auth', __filename);\n\n// app.serverUse(module, '../base/Utils/derbyLess');\n\napp.loadViews('/home/aananth/dev/DeNote/views/auth/Pages/register.html');\n\ninitializeComponents(app, components);\n\nexport default app;",
    "export const initializeComponents = (derbyApp: any, components: any[]) => {\n    components.forEach(component => {\n        derbyApp.component(component);\n    });\n}\n\nexport const initializeModels = () => {};",
    "var serverRequire = require('racer').util.serverRequire;\nvar Derby = serverRequire(module, './lib/DerbyForServer') || require('./lib/Derby');\nmodule.exports = new Derby();\n",
    "var Racer = require('./Racer');\nmodule.exports = new Racer();\n"
  ]
}